{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://github.com/timmy6","root":"/timmy6/"},"pages":[{"title":"Repositories","date":"2022-05-11T02:54:02.124Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"repository/index.html","permalink":"https://github.com/timmy6/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-05-11T03:33:53.548Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"categories/index.html","permalink":"https://github.com/timmy6/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"使用 sync.WaitGroup 来实现并发操作","slug":"sync-WaitGroup","date":"2018-12-15T12:22:50.000Z","updated":"2022-05-11T09:08:12.246Z","comments":true,"path":"2018/12/15/sync-WaitGroup/","link":"","permalink":"https://github.com/timmy6/2018/12/15/sync-WaitGroup/","excerpt":"","text":"前言如果你有一个任务可以分解成多个子任务进行处理，同时每个子任务没有先后执行顺序的限制，等到全部子任务执行完毕后，再进行下一步处理。这时每个子任务的执行可以并发处理，这种情景下适合使用 sync.WaitGroup。 虽然 sync.WaitGroup 使用起来比较简单，但是一不留神很有可能踩到坑里。 sync.WaitGroup 正确使用比如，有一个任务需要执行 3 个子任务，那么可以这样写： 12345678910111213141516171819202122232425262728func main() &#123; var wg sync.WaitGroup wg.Add(3) go handlerTask1(&amp;wg) go handlerTask2(&amp;wg) go handlerTask3(&amp;wg) wg.Wait() fmt.Println(&quot;全部任务执行完毕.&quot;)&#125;func handlerTask1(wg *sync.WaitGroup) &#123; defer wg.Done() fmt.Println(&quot;执行任务 1&quot;)&#125;func handlerTask2(wg *sync.WaitGroup) &#123; defer wg.Done() fmt.Println(&quot;执行任务 2&quot;)&#125;func handlerTask3(wg *sync.WaitGroup) &#123; defer wg.Done() fmt.Println(&quot;执行任务 3&quot;)&#125; 执行输出： 1234执行任务 3执行任务 1执行任务 2全部任务执行完毕. sync.WaitGroup 闭坑指南0112345// 正确go handlerTask1(&amp;wg)// 错误go handlerTask1(wg) 执行子任务时，使用的 sync.WaitGroup 一定要是 wg 的引用类型！ 02注意不要将 wg.Add() 放在 go handlerTask1(&amp;wg) 中！ 例如： 1234567891011121314// 错误var wg sync.WaitGroupgo handlerTask1(&amp;wg)wg.Wait()...func handlerTask1(wg *sync.WaitGroup) &#123; wg.Add(1) defer wg.Done() fmt.Println(&quot;执行任务 1&quot;)&#125; 注意 wg.Add() 一定要在 wg.Wait() 执行前执行！ 03注意 wg.Add() 和 wg.Done() 的计数器保持一致！其实 wg.Done() 就是执行的 wg.Add(-1) 。 小结sync.WaitGroup 使用起来比较简单，一定要注意不要踩到坑里。 其实 sync.WaitGroup 使用场景比较局限，仅适用于等待全部子任务执行完毕后，再进行下一步处理，如果需求是当第一个子任务执行失败时，通知其他子任务停止运行，这时 sync.WaitGroup 是无法满足的，需要使用到通知机制（channel）。 以上，希望对你能够有所帮助。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://github.com/timmy6/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://github.com/timmy6/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"使用sync.Map来解决map的并发操作问题","slug":"sync-map","date":"2018-12-12T12:22:50.000Z","updated":"2022-05-11T09:02:58.756Z","comments":true,"path":"2018/12/12/sync-map/","link":"","permalink":"https://github.com/timmy6/2018/12/12/sync-map/","excerpt":"","text":"前言在 Golang 中 map 不是并发安全的，自 1.9 才引入了 sync.Map ，sync.Map 的引入确实解决了 map 的并发安全问题，不过 sync.Map 却没有实现 len() 函数，如果想要计算 sync.Map 的长度，稍微有点麻烦，需要使用 Range 函数。 map 并发操作出现问题1234567891011121314151617func main() &#123; demo := make(map[int]int) go func() &#123; for j := 0; j &lt; 1000; j++ &#123; demo[j] = j &#125; &#125;() go func() &#123; for j := 0; j &lt; 1000; j++ &#123; fmt.Println(demo[j]) &#125; &#125;() time.Sleep(time.Second * 1)&#125; 执行输出： 1fatal error: concurrent map read and map write sync.Map 解决并发操作问题1234567891011121314151617func main() &#123; demo := sync.Map&#123;&#125; go func() &#123; for j := 0; j &lt; 1000; j++ &#123; demo.Store(j, j) &#125; &#125;() go func() &#123; for j := 0; j &lt; 1000; j++ &#123; fmt.Println(demo.Load(j)) &#125; &#125;() time.Sleep(time.Second * 1)&#125; 执行输出： 123456&lt;nil&gt; false1 true...999 true 计算 map 长度123456789func main() &#123; demo := make(map[int]int) for j := 0; j &lt; 1000; j++ &#123; demo[j] = j &#125; fmt.Println(&quot;len of demo:&quot;, len(demo))&#125; 执行输出： 1len of demo: 1000 计算 sync.Map 长度123456789101112131415func main() &#123; demo := sync.Map&#123;&#125; for j := 0; j &lt; 1000; j++ &#123; demo.Store(j, j) &#125; lens := 0 demo.Range(func(key, value interface&#123;&#125;) bool &#123; lens++ return true &#125;) fmt.Println(&quot;len of demo:&quot;, lens)&#125; 执行输出： 1len of demo: 1000 小结 Load 加载 key 数据 Store 更新或新增 key 数据 Delete 删除 key 数据 Range 遍历数据 LoadOrStore 如果存在 key 数据则返回，反之则设置 LoadAndDelete 如果存在 key 数据则删除 以上，希望对你能够有所帮助。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://github.com/timmy6/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://github.com/timmy6/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"基于逃逸分析来提升程序性能","slug":"escape","date":"2018-12-10T11:17:50.000Z","updated":"2022-05-11T08:59:06.242Z","comments":true,"path":"2018/12/10/escape/","link":"","permalink":"https://github.com/timmy6/2018/12/10/escape/","excerpt":"","text":"前言为什么需要了解逃逸分析？ 因为我们想要提升程序性能，通过逃逸分析我们能够知道变量是分配到堆上还是栈上，如果分配到栈上，内存的分配和释放都是由编译器进行管理，分配和释放的速度非常快，如果分配到堆上，堆不像栈那样可以自动清理，它会引起频繁地进行垃圾回收（GC），而垃圾回收会占用比较大的系统开销。 什么是逃逸分析？ 在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法，简单来说就是分析在程序的哪些地方可以访问到该指针。 简单的说，它是在对变量放到堆上还是栈上进行分析，该分析在编译阶段完成。如果一个变量超过了函数调用的生命周期，也就是这个变量在函数外部存在引用，编译器会把这个变量分配到堆上，这时我们就说这个变量发生逃逸了。 如何确定是否逃逸？1go run -gcflags &#x27;-m -l&#x27; main.go 可能出现逃逸的场景011234567891011package maintype Student struct &#123; Name interface&#123;&#125;&#125;func main() &#123; stu := new(Student) stu.Name = &quot;tom&quot;&#125; 分析结果： 1234go run -gcflags &#x27;-m -l&#x27; 01.go# command-line-arguments./01.go:8:12: new(Student) does not escape./01.go:9:11: &quot;tom&quot; escapes to heap interface&#123;&#125; 赋值，会发生逃逸，优化方案是将类型设置为固定类型，例如：string 1234567891011package maintype Student struct &#123; Name string&#125;func main() &#123; stu := new(Student) stu.Name = &quot;tom&quot;&#125; 分析结果： 123go run -gcflags &#x27;-m -l&#x27; 01.go# command-line-arguments./01.go:8:12: new(Student) does not escape 0212345678910111213141516package maintype Student struct &#123; Name string&#125;func GetStudent() *Student &#123; stu := new(Student) stu.Name = &quot;tom&quot; return stu&#125;func main() &#123; GetStudent()&#125; 分析结果： 123go run -gcflags &#x27;-m -l&#x27; 02.go# command-line-arguments./02.go:8:12: new(Student) escapes to heap 返回指针类型，会发生逃逸，优化方案视情况而定。 函数传递指针和传值哪个效率高吗？我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加 GC 的负担，所以传递指针不一定是高效的。 不要盲目使用变量指针作为参数，虽然减少了复制，但变量逃逸的开销可能更大。 03123456789package mainfunc main() &#123; nums := make([]int, 10000, 10000) for i := range nums &#123; nums[i] = i &#125;&#125; 分析结果： 123go run -gcflags &#x27;-m -l&#x27; 03.go# command-line-arguments./03.go:4:14: make([]int, 10000, 10000) escapes to heap 栈空间不足，会发生逃逸，优化方案尽量设置容量，如果容量实在过大那就没办法了。 小结 逃逸分析是编译器在静态编译时完成的。 逃逸分析后可以确定哪些变量可以分配在栈上，栈的性能好。 以上，希望对你能够有所帮助。 推荐阅读 Go - 使用 sync.Pool 来减少 GC 压力 Go - 使用 options 设计模式 Go - json.Unmarshal 遇到的小坑 Go - 两个在开发中需注意的小点 Go - time.RFC3339 时间格式化","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://github.com/timmy6/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://github.com/timmy6/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"不要使用 + 和 fmt.Sprintf 操作字符串","slug":"string-append","date":"2018-12-05T10:17:50.000Z","updated":"2022-05-11T08:51:56.502Z","comments":true,"path":"2018/12/05/string-append/","link":"","permalink":"https://github.com/timmy6/2018/12/05/string-append/","excerpt":"","text":"不要使用 + 和 fmt.Sprintf 操作字符串不要使用 + 和 fmt.Sprintf 操作字符串，虽然很方便，但是真的很慢！ 我们要使用 bytes.NewBufferString 进行处理。 基准测试如下： +123456789101112131415161718func BenchmarkStringOperation1(b *testing.B) &#123; b.ResetTimer() str := &quot;&quot; for i := 0; i &lt; b.N; i++ &#123; str += &quot;golang&quot; &#125;&#125;// 输出goos: darwingoarch: amd64pkg: demo/stringoperationcpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHzBenchmarkStringOperation1BenchmarkStringOperation1-12 353318 114135 ns/opPASSProcess finished with the exit code 0 fmt.Sprintf123456789101112131415161718func BenchmarkStringOperation2(b *testing.B) &#123; b.ResetTimer() str := &quot;&quot; for i := 0; i &lt; b.N; i++ &#123; str = fmt.Sprintf(&quot;%s%s&quot;, str, &quot;golang&quot;) &#125;&#125;// 输出goos: darwingoarch: amd64pkg: demo/stringoperationcpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHzBenchmarkStringOperation2BenchmarkStringOperation2-12 280140 214098 ns/opPASSProcess finished with the exit code 0 bytes.NewBufferString123456789101112131415161718func BenchmarkStringOperation3(b *testing.B) &#123; b.ResetTimer() strBuf := bytes.NewBufferString(&quot;&quot;) for i := 0; i &lt; b.N; i++ &#123; strBuf.WriteString(&quot;golang&quot;) &#125;&#125;// 输出goos: darwingoarch: amd64pkg: demo/stringoperationcpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHzBenchmarkStringOperation3BenchmarkStringOperation3-12 161292136 8.582 ns/opPASSProcess finished with the exit code 0 对于固定字段的键值对，不要使用 map[string]interface{}对于固定字段的键值对，不要使用 map[string]interface&#123;&#125;! 我们要使用临时 Struct。 基准测试如下： map[string]interface{}12345678910111213141516171819func BenchmarkStructOperation1(b *testing.B) &#123; b.ResetTimer() for i := 0; i &lt; b.N; i++ &#123; var demo = map[string]interface&#123;&#125;&#123;&#125; demo[&quot;Name&quot;] = &quot;Tom&quot; demo[&quot;Age&quot;] = 30 &#125;&#125;// 输出goos: darwingoarch: amd64pkg: demo/structoperationcpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHzBenchmarkStructOperation1BenchmarkStructOperation1-12 43300134 27.97 ns/opPASSProcess finished with the exit code 0 临时 Struct12345678910111213141516171819202122func BenchmarkStructOperation2(b *testing.B) &#123; b.ResetTimer() for i := 0; i &lt; b.N; i++ &#123; var demo struct &#123; Name string Age int &#125; demo.Name = &quot;Tom&quot; demo.Age = 30 &#125;&#125;// 输出oos: darwingoarch: amd64pkg: demo/structoperationcpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHzBenchmarkStructOperation2BenchmarkStructOperation2-12 1000000000 0.2388 ns/opPASSProcess finished with the exit code 0 小结你有类似这样的注意点吗，欢迎留言~ 下面推荐阅读的这几篇文章也是关于开发中需要知道的小技术点，更多技术细节和代码讨论，可以加入到我的星球。 推荐阅读 函数的不定参数你是这样用吗？ 优雅地处理错误真是一门学问啊！ 如何设计 API 接口，实现统一格式返回？","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://github.com/timmy6/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://github.com/timmy6/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"json.Unmarshal遇到的小坑","slug":"json-unmarshal","date":"2018-11-25T10:17:50.000Z","updated":"2022-05-11T08:46:29.735Z","comments":true,"path":"2018/11/25/json-unmarshal/","link":"","permalink":"https://github.com/timmy6/2018/11/25/json-unmarshal/","excerpt":"","text":"1.问题现象描述使用 json.Unmarshal()，反序列化时，出现了科学计数法，参考代码如下： 12345678910jsonStr := `&#123;&quot;number&quot;:1234567&#125;`result := make(map[string]interface&#123;&#125;)err := json.Unmarshal([]byte(jsonStr), &amp;result)if err != nil &#123; fmt.Println(err)&#125;fmt.Println(result)// 输出// map[number:1.234567e+06] 这个问题不是必现，只有当数字的位数大于 6 位时，才会变成了科学计数法。 2.问题影响描述当数据结构未知，使用 map[string]interface&#123;&#125; 来接收反序列化结果时，如果数字的位数大于 6 位，都会变成科学计数法，用到的地方都会受到影响。 3.引起问题的原因从 encoding/json 可以找到答案，看一下这段注释： 123456789// To unmarshal JSON into an interface value,// Unmarshal stores one of these in the interface value://// bool, for JSON booleans// float64, for JSON numbers// string, for JSON strings// []interface&#123;&#125;, for JSON arrays// map[string]interface&#123;&#125;, for JSON objects// nil for JSON null 是因为当 JSON 中存在一个比较大的数字时，它会被解析成 float64 类型，就有可能会出现科学计数法的形式。 4.问题的解决方案方案一 强制类型转换，参考代码如下： 12345678910jsonStr := `&#123;&quot;number&quot;:1234567&#125;`result := make(map[string]interface&#123;&#125;)err := json.Unmarshal([]byte(jsonStr), &amp;result)if err != nil &#123; fmt.Println(err)&#125;fmt.Println(int(result[&quot;number&quot;].(float64)))// 输出// 1234567 方案二 尽量避免使用 interface，对 json 字符串结构定义结构体，快捷方法可使用在线工具：https://mholt.github.io/json-to-go/。 1234567891011121314type Num struct &#123; Number int `json:&quot;number&quot;`&#125;jsonStr := `&#123;&quot;number&quot;:1234567&#125;`var result Numerr := json.Unmarshal([]byte(jsonStr), &amp;result)if err != nil &#123; fmt.Println(err)&#125;fmt.Println(result)// 输出// &#123;1234567&#125; 方案三 使用 UseNumber() 方法。 123456789101112jsonStr := `&#123;&quot;number&quot;:1234567&#125;`result := make(map[string]interface&#123;&#125;)d := json.NewDecoder(bytes.NewReader([]byte(jsonStr)))d.UseNumber()err := d.Decode(&amp;result)if err != nil &#123; fmt.Println(err)&#125;fmt.Println(result)// 输出// map[number:1234567] 这时一定要注意 result[&quot;number&quot;] 的数据类型！ 1234fmt.Println(fmt.Sprintf(&quot;type: %v&quot;, reflect.TypeOf(result[&quot;number&quot;])))// 输出// type: json.Number 通过代码可以看出 json.Number 其实就是字符串类型： 12// A Number represents a JSON number literal.type Number string 如果转换其他类型，参考如下代码： 12345678910111213// 转成 int64numInt, _ := result[&quot;number&quot;].(json.Number).Int64()fmt.Println(fmt.Sprintf(&quot;value: %v, type: %v&quot;, numInt, reflect.TypeOf(numInt)))// 输出// value: 1234567, type: int64// 转成 stringnumStr := result[&quot;number&quot;].(json.Number).String()fmt.Println(fmt.Sprintf(&quot;value: %v, type: %v&quot;, numStr, reflect.TypeOf(numStr)))// 输出// value: 1234567, type: string","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://github.com/timmy6/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://github.com/timmy6/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"defer 函数","slug":"defer","date":"2018-11-15T11:17:50.000Z","updated":"2022-05-11T08:41:35.937Z","comments":true,"path":"2018/11/15/defer/","link":"","permalink":"https://github.com/timmy6/2018/11/15/defer/","excerpt":"","text":"概述defer 函数大家肯定都用过，它在声明时不会立刻去执行，而是在函数 return 后去执行的。 它的主要应用场景有异常处理、记录日志、清理数据、释放资源 等等。 这篇文章不是分享 defer 的应用场景，而是分享使用 defer 需要注意的点。 咱们先从一道题开始，一起来感受下 … 1234567891011121314func calc(index string, a, b int) int &#123; ret := a + b fmt.Println(index, a, b, ret) return ret&#125;func main() &#123; x := 1 y := 2 defer calc(&quot;A&quot;, x, calc(&quot;B&quot;, x, y)) x = 3 defer calc(&quot;C&quot;, x, calc(&quot;D&quot;, x, y)) y = 4&#125; 输出什么？ … 接下来，先容我分享几个小例子，再进行作答。 执行顺序12345678func main() &#123; defer fmt.Println(&quot;1&quot;) defer fmt.Println(&quot;2&quot;) defer fmt.Println(&quot;3&quot;) fmt.Println(&quot;main&quot;)&#125; 输出： 1234main321 结论：defer 函数定义的顺序 与 实际执的行顺序是相反的，也就是最先声明的最后才执行。 闭包1234567891011func main() &#123; var a = 1 var b = 2 defer fmt.Println(a + b) a = 2 fmt.Println(&quot;main&quot;)&#125; 输出： 12main3 稍微修改一下，再看看： 123456789101112func main() &#123; var a = 1 var b = 2 defer func() &#123; fmt.Println(a + b) &#125;() a = 2 fmt.Println(&quot;main&quot;)&#125; 输出： 12main4 结论：闭包获取变量相当于引用传递，而非值传递。 稍微再修改一下，再看看： 123456789101112func main() &#123; var a = 1 var b = 2 defer func(a int, b int) &#123; fmt.Println(a + b) &#125;(a, b) a = 2 fmt.Println(&quot;main&quot;)&#125; 输出： 12main3 结论：传参是值复制。 还可以理解为：defer 调用的函数，参数的值在 defer 定义时就确定了，看下代码 defer fmt.Println(a + b)，在这时，参数的值已经确定了。 而 defer 函数内部所使用的变量的值需要在这个函数运行时才确定，看下代码 defer func() &#123; fmt.Println(a + b) &#125;()，a 和 b 的值在函数运行时，才能确定。 Return一1234567func t1() int &#123; a := 1 defer func() &#123; a++ &#125;() return a&#125; 输出：1 二123456func t2() (a int) &#123; defer func() &#123; a++ &#125;() return 1&#125; 输出：2 三1234567func t3() (b int) &#123; a := 1 defer func() &#123; a++ &#125;() return 1&#125; 输出：1 四123456func t4() (a int) &#123; defer func(a int) &#123; a++ &#125;(a) return 1&#125; 输出：1 结论：return 不是原子操作。 os.Exit12345func main() &#123; defer fmt.Println(&quot;1&quot;) fmt.Println(&quot;main&quot;) os.Exit(0)&#125; 输出：main 结论：当os.Exit()方法退出程序时，defer不会被执行。 不同协程12345678910111213141516171819func main() &#123; GoA() time.Sleep(1 * time.Second) fmt.Println(&quot;main&quot;)&#125;func GoA() &#123; defer (func()&#123; if err := recover(); err != nil &#123; fmt.Println(&quot;panic:&quot; + fmt.Sprintf(&quot;%s&quot;, err)) &#125; &#125;)() go GoB()&#125;func GoB() &#123; panic(&quot;error&quot;)&#125; GoB() panic 捕获不到。 结论：defer 只对当前协程有效。 这个问题怎么解？咱们下回再说。 接下来，咱们分析下文章开头的问题吧。 答案解析先列出答案： 1234B 1 2 3D 3 2 5C 3 5 8A 1 3 4 其实上面那道题，可以拆解为： 12345678910111213141516func calc(index string, a, b int) int &#123; ret := a + b fmt.Println(index, a, b, ret) return ret&#125;func main() &#123; x := 1 y := 2 tmp1 := calc(&quot;B&quot;, x, y) defer calc(&quot;A&quot;, x, tmp1) x = 3 tmp2 := calc(&quot;D&quot;, x, y) defer calc(&quot;C&quot;, x, tmp2) y = 4&#125; 所以顺序就是：B D C A。 执行到 tmp1 时，输出：B 1 2 3。 执行到 tmp2 时，输出：D 3 2 5。 根据 defer 执行顺序原则，先声明的后执行，所以下一个该执行 C 了。 又因为传参是值赋值，所以在 A 的时候，无法用到 x = 3 和 y = 4，在 C 的时候，无法用到 y = 4。 执行到 C 时，输出：C 3 5 8 执行到 A 时，输出：A 1 3 4 到这，基本上 defer 就清楚了，大家可以根据自己的理解去记忆。 go-gin-api 系列文章 7. 路由中间件 - 签名验证 6. 路由中间件 - Jaeger 链路追踪（实战篇） 5. 路由中间件 - Jaeger 链路追踪（理论篇） 4. 路由中间件 - 捕获异常 3. 路由中间件 - 日志记录 2. 规划项目目录和参数验证 1. 使用 go modules 初始化项目","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://github.com/timmy6/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://github.com/timmy6/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"chan通道","slug":"chan","date":"2018-11-05T11:17:50.000Z","updated":"2022-05-11T08:32:03.154Z","comments":true,"path":"2018/11/05/chan/","link":"","permalink":"https://github.com/timmy6/2018/11/05/chan/","excerpt":"","text":"概述chan 可以理解为队列，遵循先进先出的规则。 在说 chan 之前，咱们先说一下 go 关键字。 在 go 关键字后面加一个函数，就可以创建一个线程，函数可以为已经写好的函数，也可以是匿名函数。 举个例子： 123456789func main() &#123; fmt.Println(&quot;main start&quot;) go func() &#123; fmt.Println(&quot;goroutine&quot;) &#125;() fmt.Println(&quot;main end&quot;)&#125; 输出： 12main startmain end 为什么没有输出 goroutine ？ 首先，我们清楚 Go 语言的线程是并发机制，不是并行机制。 那么，什么是并发，什么是并行？ 并发是不同的代码块交替执行，也就是交替可以做不同的事情。 并行是不同的代码块同时执行，也就是同时可以做不同的事情。 举个生活化场景的例子： 你正在家看书，忽然电话来了，然后你接电话，通话完成后继续看书，这就是并发，看书和接电话交替做。 如果电话来了，你一边看书一遍接电话，这就是并行，看书和接电话一起做。 说回上面的例子，为什么没有输出 goroutine ？ main 函数是一个主线程，是因为主线程执行太快了，子线程还没来得及执行，所以看不到输出。 现在让主线程休眠 1 秒钟，再试试。 1234567891011func main() &#123; fmt.Println(&quot;main start&quot;) go func() &#123; fmt.Println(&quot;goroutine&quot;) &#125;() time.Sleep(1 * time.Second) fmt.Println(&quot;main end&quot;)&#125; 输出： 123main startgoroutinemain end 这就对了。 接下来，看看如何使用 chan 。 声明 chan1234567891011// 声明不带缓冲的通道ch1 := make(chan string)// 声明带10个缓冲的通道ch2 := make(chan string, 10)// 声明只读通道ch3 := make(&lt;-chan string)// 声明只写通道ch4 := make(chan&lt;- string) 注意： 不带缓冲的通道，进和出都会阻塞。 带缓冲的通道，进一次长度 +1，出一次长度 -1，如果长度等于缓冲长度时，再进就会阻塞。 写入 chan123ch1 := make(chan string, 10)ch1 &lt;- &quot;a&quot; 读取 chan123val, ok := &lt;- ch1// 或val := &lt;- ch1 关闭 chan1close(chan) 注意： close 以后不能再写入，写入会出现 panic 重复 close 会出现 panic 只读的 chan 不能 close close 以后还可以读取数据 示例12345678910func main() &#123; fmt.Println(&quot;main start&quot;) ch := make(chan string) ch &lt;- &quot;a&quot; // 入 chan go func() &#123; val := &lt;- ch // 出 chan fmt.Println(val) &#125;() fmt.Println(&quot;main end&quot;)&#125; 输出： 12main startfatal error: all goroutines are asleep - deadlock! What ? 这是为啥，刚开始就出师不利呀？ 因为，定义的是一个无缓冲的 chan，赋值后就陷入了阻塞。 怎么解决它？ 声明一个有缓冲的 chan。 12345678910func main() &#123; fmt.Println(&quot;main start&quot;) ch := make(chan string, 1) ch &lt;- &quot;a&quot; // 入 chan go func() &#123; val := &lt;- ch // 出 chan fmt.Println(val) &#125;() fmt.Println(&quot;main end&quot;)&#125; 输出： 12main startmain end 为啥没有输出 a , 和前面一样，主线程执行太快了，加个休眠 1 秒钟，再试试。 1234567891011func main() &#123; fmt.Println(&quot;main start&quot;) ch := make(chan string, 1) ch &lt;- &quot;a&quot; // 入 chan go func() &#123; val := &lt;- ch // 出 chan fmt.Println(val) &#125;() time.Sleep(1 * time.Second) fmt.Println(&quot;main end&quot;)&#125; 输出： 123main startamain end 这就对了。 再看一个例子： 12345678910111213func main() &#123; fmt.Println(&quot;main start&quot;) ch := make(chan string) go func() &#123; ch &lt;- &quot;a&quot; // 入 chan &#125;() go func() &#123; val := &lt;- ch // 出 chan fmt.Println(val) &#125;() time.Sleep(1 * time.Second) fmt.Println(&quot;main end&quot;)&#125; 输出： 123main startamain end 再看一个例子： 1234567891011121314151617func producer(ch chan string) &#123; fmt.Println(&quot;producer start&quot;) ch &lt;- &quot;a&quot; ch &lt;- &quot;b&quot; ch &lt;- &quot;c&quot; ch &lt;- &quot;d&quot; fmt.Println(&quot;producer end&quot;)&#125;func main() &#123; fmt.Println(&quot;main start&quot;) ch := make(chan string, 3) go producer(ch) time.Sleep(1 * time.Second) fmt.Println(&quot;main end&quot;)&#125; 输出： 123main startproducer startmain end 带缓冲的通道，如果长度等于缓冲长度时，再进就会阻塞。 再看一个例子： 12345678910111213141516171819202122232425func producer(ch chan string) &#123; fmt.Println(&quot;producer start&quot;) ch &lt;- &quot;a&quot; ch &lt;- &quot;b&quot; ch &lt;- &quot;c&quot; ch &lt;- &quot;d&quot; fmt.Println(&quot;producer end&quot;)&#125;func customer(ch chan string) &#123; for &#123; msg := &lt;- ch fmt.Println(msg) &#125;&#125;func main() &#123; fmt.Println(&quot;main start&quot;) ch := make(chan string, 3) go producer(ch) go customer(ch) time.Sleep(1 * time.Second) fmt.Println(&quot;main end&quot;)&#125; 输出： 12345678main startproducer startproducer endabcdmain end 就到这吧。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://github.com/timmy6/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://github.com/timmy6/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"老项目迁移 go module 大型灾难记录","slug":"gomod","date":"2018-10-26T08:17:50.000Z","updated":"2022-05-11T07:55:59.806Z","comments":true,"path":"2018/10/26/gomod/","link":"","permalink":"https://github.com/timmy6/2018/10/26/gomod/","excerpt":"最近在改造一个比较早期的一个项目，其中就涉及到用将原来 Vendor 管理依赖换成 Go Modules 来管理。 然而过程真是一波三折，在这里总结一下此次 Go Modules 改造中遇到的问题，以及解决方法。","text":"最近在改造一个比较早期的一个项目，其中就涉及到用将原来 Vendor 管理依赖换成 Go Modules 来管理。 然而过程真是一波三折，在这里总结一下此次 Go Modules 改造中遇到的问题，以及解决方法。 背景 go version： 12$ go versiongo version go1.16.5 darwin/amd64 简化的 demo 如下, 很 “简单” 我们只要把 hello world 输出即可。 123456789101112131415161718192021222324252627package mainimport ( &quot;github.com/coreos/etcd/pkg/transport&quot; &quot;github.com/google/certificate-transparency-go/tls&quot; &quot;github.com/qiniu/api.v7/auth/qbox&quot; &quot;go.etcd.io/etcd/clientv3&quot; &quot;google.golang.org/grpc&quot; &quot;qiniupkg.com/x/log.v7&quot;)func main() &#123; _ = transport.TLSInfo&#123;&#125; _ = clientv3.WatchResponse&#123;&#125; _, _ = clientv3.New(clientv3.Config&#123;&#125;) _ = qbox.NewMac(&quot;&quot;, &quot;&quot;) _ = tls.DigitallySigned&#123;&#125; _ = grpc.ClientConn&#123;&#125; log.Info(&quot;hello world&quot;)&#125; 实战直接初始化，并 tidy 一下。 123456789101112131415161718192021222324$ go mod init demo-go/gomodgo: creating new go.mod: module demo-go/gomodgo: to add module requirements and sums: go mod tidy $ go mod tidygo: finding module for ...demo-go/gomod imports qiniupkg.com/x/log.v7: module qiniupkg.com/x@latest found (v1.11.5), but does not contain package qiniupkg.com/x/log.v7demo-go/gomod imports github.com/qiniu/api.v7/auth/qbox imports github.com/qiniu/x/bytes.v7/seekable: module github.com/qiniu/x@latest found (v1.11.5), but does not contain package github.com/qiniu/x/bytes.v7/seekabledemo-go/gomod imports go.etcd.io/etcd/clientv3 imports github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context: package github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context provided by github.com/coreos/etcd at latest version v2.3.8+incompatible but not at required version v3.3.10+incompatibledemo-go/gomod imports go.etcd.io/etcd/clientv3 imports github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc: package github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc provided by github.com/coreos/etcd at latest version v2.3.8+incompatible but not at required version v3.3.10+incompatibledemo-go/gomod imports go.etcd.io/etcd/clientv3 imports github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/credentials: package github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/credentials provided by github.com/coreos/etcd at latest version v2.3.8+incompatible but not at required version v3.3.10+incompatibledemo-go/gomod imports go.etcd.io/etcd/clientv3 imports github.com/coreos/etcd/storage/storagepb: package github.com/coreos/etcd/storage/storagepb provided by github.com/coreos/etcd at latest version v2.3.8+incompatible but not at required version v3.3.10+incompatible 好家伙，报错了。我们先看到前两行 qiniupkg.com/x@latest 中没有 qiniupkg.com/x/log.v7； github.com/qiniu/x@latest 中没有 github.com/qiniu/x/bytes.v7/seekable； 这看起来应该是一个问题， qiniupkg.com/x 和github.com/qiniu/x 应该是同一个包，不同镜像。于是我到 Github 看一下 @lastet 版本的代码，确实没有bytes.v7 包了。人肉查找，最后在 v1.7.8 版本，我们找到了 bytes.v7 包。 于是，我们可以指定一下版本。 12go mod edit -replace qiniupkg.com/x=qiniupkg.com/x@v1.7.8go mod edit -replace github.com/qiniu/x=github.com/qiniu/x@v1.7.8 继续往下看，接下来的几个问题是一类的，都是etcd导致的。 意思是 go.etcd.io/etcd/clientv3 导入了 github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context, 同时 github.com/coreos/etcd@v2.3.8 中 提供了 github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context 。 但是，我们这里需要 github.com/coreos/etcd@v3.3.10, 而该版本并不提供 github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context 。 我们直接更新 etcd 到的 v3.3.10 试试。 1go mod edit -replace go.etcd.io/etcd=go.etcd.io/etcd@v3.3.20+incompatible 我们再 go mod tidy 下。 123456789$ go mod tidygo: demo-go/gomod imports go.etcd.io/etcd/clientv3 tested by go.etcd.io/etcd/clientv3.test imports github.com/coreos/etcd/auth imports github.com/coreos/etcd/mvcc/backend imports github.com/coreos/bbolt: github.com/coreos/bbolt@v1.3.6: parsing go.mod: module declares its path as: go.etcd.io/bbolt but was required as: github.com/coreos/bbolt 这个错误和鸟窝这篇 Etcd使用go module的灾难一致，go.etcd.io/bbolt 和 github.com/coreos/bbolt 包名不一致，我们替换一下。 1go mod edit -replace github.com/coreos/bbolt@v1.3.6=go.etcd.io/bbolt@v1.3.6 继续，go mod tidy 一下。 1234567891011121314151617181920$ go mod tidy...demo-go/gomod imports go.etcd.io/etcd/clientv3 imports github.com/coreos/etcd/clientv3/balancer: module github.com/coreos/etcd@latest found (v2.3.8+incompatible), but does not contain package github.com/coreos/etcd/clientv3/balancerdemo-go/gomod imports go.etcd.io/etcd/clientv3 imports github.com/coreos/etcd/clientv3/balancer/picker: module github.com/coreos/etcd@latest found (v2.3.8+incompatible), but does not contain package github.com/coreos/etcd/clientv3/balancer/pickerdemo-go/gomod imports go.etcd.io/etcd/clientv3 imports github.com/coreos/etcd/clientv3/balancer/resolver/endpoint: module github.com/coreos/etcd@latest found (v2.3.8+incompatible), but does not contain package github.com/coreos/etcd/clientv3/balancer/resolver/endpointdemo-go/gomod imports go.etcd.io/etcd/clientv3 imports github.com/coreos/etcd/clientv3/credentials: module github.com/coreos/etcd@latest found (v2.3.8+incompatible), but does not contain package github.com/coreos/etcd/clientv3/credentialsdemo-go/gomod imports go.etcd.io/etcd/clientv3 tested by go.etcd.io/etcd/clientv3.test imports github.com/coreos/etcd/integration imports github.com/coreos/etcd/proxy/grpcproxy imports google.golang.org/grpc/naming: module google.golang.org/grpc@latest found (v1.39.0), but does not contain package google.golang.org/grpc/naming 好家伙，又是etcd。 仔细一看，我们导入了github.com/coreos/etcd 和 go.etcd.io/etcd 两个版本etcd, 我们前面只替换了一个。现在我们把另外一个也替换了。 1go mod edit -replace github.com/coreos/etcd=github.com/coreos/etcd@v3.3.20+incompatible 再go mod tidy下，这个错误没有了，但还有个grpc的错误，继续找原因。原来是 google.golang.org/grpc v1.39.0 版本没有 google.golang.org/grpc/naming 包。 上 Github 仓库， 找了一下历史版本，v1.29.1上是有这个包的，我们继续替换。 1go mod edit -replace google.golang.org/grpc=google.golang.org/grpc@v1.29.1 这下，终于，go mod tidy通过了，可以开心的输出hello world 了。 然而， 1234567$ go run main.go# github.com/coreos/etcd/clientv3/balancer/resolver/endpoint../../../go/pkg/mod/github.com/coreos/etcd@v3.3.20+incompatible/clientv3/balancer/resolver/endpoint/endpoint.go:114:78: undefined: resolver.BuildOption../../../go/pkg/mod/github.com/coreos/etcd@v3.3.20+incompatible/clientv3/balancer/resolver/endpoint/endpoint.go:182:31: undefined: resolver.ResolveNowOption# github.com/coreos/etcd/clientv3/balancer/picker../../../go/pkg/mod/github.com/coreos/etcd@v3.3.20+incompatible/clientv3/balancer/picker/err.go:37:44: undefined: balancer.PickOptions../../../go/pkg/mod/github.com/coreos/etcd@v3.3.20+incompatible/clientv3/balancer/picker/roundrobin_balanced.go:55:54: undefined: balancer.PickOptions 意不意外，惊不惊喜！! 原来etcd包依赖了grpc的resolver包，但我导入的v1.29.1版本的grpc是没有这个包的。到 grpc仓库 挨个版本看了一下，确实只有v1.26.0版本才声明了type BuildOption 。于是，我们再次使用替换大法。 1go mod edit -replace google.golang.org/grpc=google.golang.org/grpc@v1.26.0 再次tidy, 运行！ 终于，看到了久违的hello world! 12$ go run main.go2021/07/20 12:27:09.642431 [INFO] /Users/razeen/wspace/github/demo-go/gomod/main.go:26: hello world 总结项目规范现在我们回过头看下这个 demo 项目，其实很有问题。 123456&quot;github.com/coreos/etcd/pkg/transport&quot;&quot;github.com/google/certificate-transparency-go/tls&quot;&quot;github.com/qiniu/api.v7/auth/qbox&quot;&quot;go.etcd.io/etcd/clientv3&quot;&quot;google.golang.org/grpc&quot;&quot;qiniupkg.com/x/log.v7&quot; etcd 和 qiniupkg的包完全可以统一，只导入一种！而且，后来我们发现log.v7这包也是意外导入的…. 这也是在改造我们一些老的项目时遇到的问题，以前用vendor go get 没有注意到这些问题，这是需要提前规范的。 看懂 go.mod我们来简单看一下，经历各种坎坷后，得出的go.mod 文件。 12345678910111213141516171819202122232425262728293031module demo-go/gomodgo 1.16replace qiniupkg.com/x =&gt; qiniupkg.com/x v1.7.8replace github.com/qiniu/x =&gt; github.com/qiniu/x v1.7.8replace go.etcd.io/etcd =&gt; go.etcd.io/etcd v3.3.20+incompatiblereplace github.com/coreos/bbolt v1.3.6 =&gt; go.etcd.io/bbolt v1.3.6replace github.com/coreos/etcd =&gt; github.com/coreos/etcd v3.3.20+incompatiblereplace google.golang.org/grpc =&gt; google.golang.org/grpc v1.26.0require ( github.com/coreos/bbolt v1.3.6 // indirect github.com/coreos/etcd v3.3.10+incompatible github.com/dgrijalva/jwt-go v3.2.0+incompatible // indirect github.com/google/certificate-transparency-go v1.1.1 github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0 // indirect github.com/qiniu/api.v7 v7.2.5+incompatible github.com/qiniu/x v0.0.0-00010101000000-000000000000 // indirect github.com/soheilhy/cmux v0.1.5 // indirect github.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2 // indirect go.etcd.io/etcd v0.0.0-20200513171258-e048e166ab9c google.golang.org/grpc v1.29.1 qiniupkg.com/x v0.0.0-00010101000000-000000000000 sigs.k8s.io/yaml v1.2.0 // indirect) 我们先看一个常见的这几个指令， module 定义主模块的路径； go 编写该mod文件时的go版本； require 声明给定模块依赖项的最低要求版本; replace 手动指定的依赖模块 (可以替换全部的版本、指定的版本、本地的版本等等 )； 还有就是 v3.3.20+incompatible 后面的 +incompatible , 这是指兼容的版本，指依赖库的版本是v2 或以上，但go.mod和 依赖库路径 没有按照官方指定的方式命名，会加上这个。 v0.0.0-00010101000000-000000000000 这是一个伪版本，在和 不兼容 module 或 标记的版本不可用的时候，回打上这个伪版本。 // indirect 这指明这些不是我们直接引用的依赖。 除此之外，以下指令也可了解一下。 1234567891011121314# 查看当前模块以及所有的依赖模块go list -m all# 查看某个模块的以及打标签的版本go list -m -versions go.etcd.io/etcd# 升级特定的包go get xx@version 升级特定的包# 了解为什么需要模块go mod why -m all # 为什么需要指定（google.golang.org/grpc）的模块go mod why -m google.golang.org/grpc 更多可以细读官方文档，感谢阅读。 参考 Using Go Modules Minimal Version Selection 跳出Go module的泥潭 Etcd使用go module的灾难 浅谈Go Modules原理","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://github.com/timmy6/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://github.com/timmy6/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"Golang中的RESTful API最佳实践","slug":"restful","date":"2018-10-22T08:17:50.000Z","updated":"2022-05-11T07:52:10.021Z","comments":true,"path":"2018/10/22/restful/","link":"","permalink":"https://github.com/timmy6/2018/10/22/restful/","excerpt":"RESRful API已经流行很多年了，我也一直在使用它。最佳实践也看过不少，但当一个项目完成，再次回顾&#x2F;梳理项目时，会发现很多API和规范还是多少有些出入。在这篇文章中，我们结合Go Web再次梳理一下RESTful API的相关最佳实践。","text":"RESRful API已经流行很多年了，我也一直在使用它。最佳实践也看过不少，但当一个项目完成，再次回顾&#x2F;梳理项目时，会发现很多API和规范还是多少有些出入。在这篇文章中，我们结合Go Web再次梳理一下RESTful API的相关最佳实践。 关于RESTful API关于什么是RESTful API，不再累述。推荐几个相关链接。 理解RESTful架构 REST API Tutorial 1.使用JSON不管是接收还是返回数据都推荐使用JSON。 通常返回数据的格式有JSON和XML，但XML过于冗长，可读性差，而且各种语言的解析上也不如JSON，使用JSON的好处，显而易见。 而接收数据，我们这里也推荐使用JSON，对于后端开发而言，入参直接与模型绑定，省去冗长的参数解析能简化不少代码，而且JSON能更简单的传递一些更复杂的结构等。 正如示例代码中的这一段，我们以gin框架为例。 12345678910111213141516// HandleLogin docfunc HandleLogin(c *gin.Context) &#123; param := &amp;LoginParams&#123;&#125; if err := c.BindJSON(param); err != nil &#123; c.JSON(http.StatusBadRequest, &amp;Resp&#123;Error: &quot;parameters error&quot;&#125;) return &#125; // 做一些校验 // ... session := sessions.Default(c) session.Set(sessionsKey, param.UserID) session.Save() c.JSON(http.StatusOK, &amp;Resp&#123;Data: &quot;login succeed&quot;&#125;)&#125; 通过c.BindJSON,轻松的将入参于模型LoginParams绑定；通过c.JSON轻松的将数据JSON序列化返回。 但所有接口都必须用JSON么？那也未必。比如文件上传，这时我们使用FormData比把文件base64之类的放到JSON里面更高效。 2.路径中不包含动词我们的HTTP请求方法中已经有GET,POST等这些动作了，完全没有必要再路径中加上动词。 我们常用HTTP请求方法包括GET,POST,PUT和DELETE, 这也对应了我们经常需要做的数据库操作。GET查找&#x2F;获取资源，POST新增资源，PUT修改资源，DELETE删除资源。 如下，这些路径中没有任何动词，简洁明了。 12345678// 获取文章列表v1.GET(&quot;/articles&quot;, HandleGetArticles)// 发布文章v1.POST(&quot;/articles&quot;, HandlePostArticles)// 修改文章v1.PUT(&quot;/articles&quot;, HandleUpdateArticles)// 删除文章v1.DELETE(&quot;/articles/:id&quot;, HandleDeleteArticles) 3.路径中对应资源用复数就像我们上面这段代码，articles对于的是我们的文章资源，背后就是一张数据库表articles, 所以操作这个资源的应该都用复数形式。 4.次要资源可分层展示一个博客系统中，最主要的应该是文章了，而评论应该是其子资源，我们可以评论嵌套在它的父资源后面，如： 12345678// 获取评论列表v1.GET(&quot;/articles/:articles_id/comments&quot;, HandleGetComments)// 添加评论v1.POST(&quot;/articles/:articles_id/comments&quot;, HandleAddComments)// 修改评论v1.PUT(&quot;/articles/:articles_id/comments/:id&quot;, HandleUpdateComments)// 删除评论v1.DELETE(&quot;/articles/:articles_id/comments/:id&quot;, HandleDeleteComments) 那么，我们需要获取所有文章的评论怎么办？可以这么写： 1v1.GET(&quot;/articles/-/comments&quot;, HandleGetComments) 但这也不是决对的，资源虽然有层级关系，但这种层级关系不宜太深，个人感觉两层最多了，如果超过，可以直接拿出来放在一级。 5.分页、排序、过滤获取列表时，会使用到分页、排序过滤。一般： 123?page=1&amp;page_size=10 # 指定页面page与分页大小page_size?sort=-create_at,+author # 按照创建时间create_at降序，作者author升序排序?title=helloworld # 按字段title搜索 6.统一数据格式不管是路径的格式，还是参数的格式，还是返回值的格式建议统一形式。 一般常用的格式有蛇形,大驼峰和小驼峰，个人比较喜欢蛇形。Anyway, 不管哪种，只要统一即可。 除了参数的命名统一外，返回的数据格式，最好统一，方便前端对接。 如下，我们定义Resp为通用返回数据结构，Data中存放返回的数据，如果出错，将错误信息放在Error中。 123456789101112131415// Resp doctype Resp struct &#123; Data interface&#123;&#125; `json:&quot;data&quot;` Error string `json:&quot;error&quot;`&#125;// 登陆成功返回 c.JSON(http.StatusOK, &amp;Resp&#123;Data: &quot;login succeed&quot;&#125;)// 查询列表 c.JSON(http.StatusOK, &amp;Resp&#123;Data: map[string]interface&#123;&#125;&#123; &quot;result&quot;: tempStorage, &quot;total&quot;: len(tempStorage), &#125;&#125;)// 参数错误 c.JSON(http.StatusBadRequest, &amp;Resp&#123;Error: &quot;parameters error&quot;&#125;) 7.善用HTTP状态码HTTP状态码有很多，我们没有必要也不可能全部用上，常用如下： 200 StatusOK - 只有成功请求都返回200。 400 StatusBadRequest - 当出现参数不对，用户参数校验不通过时，给出该状态，并返回Error 401 StatusUnauthorized - 没有登陆&#x2F;经过认证 403 Forbidden - 服务端拒绝授权(如密码错误)，不允许访问 404 Not Found - 路径不存在 500 Internal Server Error - 所请求的服务器遇到意外的情况并阻止其执行请求 502 Bad Gateway - 网关或代理从上游接收到了无效的响应 503 Service Unavailable - 服务器尚未处于可以接受请求的状态 其中502,503，我们写程序时并不会明确去抛出。所以我们平常用6个状态码已经能很好的展示服务端状态了。 同时，我们将状态与返回值对应起来，200状态下，返回Data数据；其他状态返回Error。 8.API版本化正如Demo中所示，我们将路由分组到了/api/v1路径下面，版本化API。如果后续的服务端升级，但可能仍有很大部分客户端请求未升级，依然请求老版本的API，那么我们只需要增加/api/v2，然后在该路径下为已升级的客户端提供服务。这样，我们就做到了API的版本控制，可以平滑的从一个版本切换到另外一个版本。 123456v1 := r.Group(&quot;/api/v1&quot;)&#123; v1.POST(&quot;/login&quot;, HandleLogin) v1.GET(&quot;/articles&quot;, HandleGetArticles) v1.GET(&quot;/articles/:id/comments&quot;, HandleGetComments) // .... 9. 统一 ‘&#x2F;‘ 开头所以路由中，路径都以’&#x2F;‘开头，虽然框架会为我们做这件事，但还是建议统一加上。 10. 增加&#x2F;更新操作 返回资源对于POST,PUT操作，建议操作后，返回更新后的资源。 11. 使用HTTPS对于暴露出去的接口&#x2F;OpenAPI，一定使用HTTPS。一般时候，我们可以直接在服务前面架设一个WebServer，在WebServer内部署证书即可。当然，如果是直接由后端暴露出的接口，有必要直接在后端开启HTTPS！ 12. 规范的API文档对于我们这种前后端分离的架构，API文档是很重要。在Go中，我们很容易的能用swag结合代码注释自动生成API文档。 总结API写的好不好，重要的还是看是否遵循WEB标准和保持一致性，最终目的也是让这些API更清晰，易懂，安全，希望这些建议对你有所帮助。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://github.com/timmy6/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://github.com/timmy6/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"gin文件上传与下载","slug":"gin-file","date":"2018-10-12T08:17:50.000Z","updated":"2022-05-11T07:43:28.368Z","comments":true,"path":"2018/10/12/gin-file/","link":"","permalink":"https://github.com/timmy6/2018/10/12/gin-file/","excerpt":"","text":"Gin是用Go编写的web框架。性能还不错，而且使用比较简单，还支持RESTful API。 日常的使用中我们可能要处理一些文件的上传与下载，我这里简单总结一下。 单文件上传我们使用multipart/form-data格式上传文件，利用c.Request.FormFile解析文件。 123456789101112131415161718// HandleUploadFile 上传单个文件func HandleUploadFile(c *gin.Context) &#123; file, header, err := c.Request.FormFile(&quot;file&quot;) if err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;msg&quot;: &quot;文件上传失败&quot;&#125;) return &#125; content, err := ioutil.ReadAll(file) if err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;msg&quot;: &quot;文件读取失败&quot;&#125;) return &#125; fmt.Println(header.Filename) fmt.Println(string(content)) c.JSON(http.StatusOK, gin.H&#123;&quot;msg&quot;: &quot;上传成功&quot;&#125;)&#125; 我们上传文件可以看到。 我们已经看到文件上传成功，已经文件名字与内容。 多文件上传多文件的上传利用c.Request.MultipartForm解析。 12345678910111213141516171819202122232425262728293031// HandleUploadMutiFile 上传多个文件func HandleUploadMutiFile(c *gin.Context) &#123; // 限制放入内存的文件大小 err := c.Request.ParseMultipartForm(4 &lt;&lt; 20) if err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;msg&quot;: &quot;文件太大&quot;&#125;) return &#125; formdata := c.Request.MultipartForm files := formdata.File[&quot;file&quot;] for _, v := range files &#123; file, err := v.Open() if err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;msg&quot;: &quot;文件读取失败&quot;&#125;) return &#125; defer file.Close() content, err := ioutil.ReadAll(file) if err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;msg&quot;: &quot;文件读取失败&quot;&#125;) return &#125; fmt.Println(v.Filename) fmt.Println(string(content)) &#125; c.JSON(http.StatusOK, gin.H&#123;&quot;msg&quot;: &quot;上传成功&quot;&#125;)&#125; 多个文件，遍历文件内容即可读取。 利用c.Request.ParseMultipartForm()可设置上传文件的大小，这里限制了4MB。 c.Request.ParseMultipartForm()并不能限制上传文件的大小，只是限制了上传的文件读取到内存部分的大小，如果超过了就存入了系统的临时文件中。如果需要限制文件大小，需要使用github.com/gin-contrib/size中间件，如demo中使用r.Use(limits.RequestSizeLimiter(4 &lt;&lt; 20))限制最大4Mb。 我们看到 两个文件已经上传成功。 文件下载文件的下载主要是注意设置文件名，文件类型等。 123456789101112// HandleDownloadFile 下载文件func HandleDownloadFile(c *gin.Context) &#123; content := c.Query(&quot;content&quot;) content = &quot;hello world, 我是一个文件，&quot; + content c.Writer.WriteHeader(http.StatusOK) c.Header(&quot;Content-Disposition&quot;, &quot;attachment; filename=hello.txt&quot;) c.Header(&quot;Content-Type&quot;, &quot;application/text/plain&quot;) c.Header(&quot;Accept-Length&quot;, fmt.Sprintf(&quot;%d&quot;, len(content))) c.Writer.Write([]byte(content))&#125; 通过 Content-Disposition设置文件名字； Content-Type设置文件类型，可以到这里查阅； Accept-Length这个设置文件长度； c.Writer.Write写出文件。 成功下载可以看到：","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://github.com/timmy6/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://github.com/timmy6/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"gRPC在Go中的使用（三）gRPC实现TLS加密通信与流通信","slug":"grpc3","date":"2018-10-02T08:17:50.000Z","updated":"2022-05-11T07:38:32.048Z","comments":true,"path":"2018/10/02/grpc3/","link":"","permalink":"https://github.com/timmy6/2018/10/02/grpc3/","excerpt":"在前面的两篇博客中，我们已经知道了如何利用gRPC建立简单RPC通信。但这样简单的实现有时候满足不了我们的业务需求。在一些场景中我们需要防止数据被劫持，或是一些场景中我们希望客户端与服务器不是简单的一问一答，而是建立起一个流式的RPC通信，那么该怎么做到呢？","text":"在前面的两篇博客中，我们已经知道了如何利用gRPC建立简单RPC通信。但这样简单的实现有时候满足不了我们的业务需求。在一些场景中我们需要防止数据被劫持，或是一些场景中我们希望客户端与服务器不是简单的一问一答，而是建立起一个流式的RPC通信，那么该怎么做到呢？ TLS加密通信TLS加密无非就是认证客户端与服务器，如果对SSL&#x2F;TLS加密通信有所了解的童鞋都知道我们首先需要两张证书。 所以作为准备工作，我们首先要申请两张测试证书。一张客户端证书，一张服务器证书。 生成测试证书利用MySSL测试证书生成工具我们可以很简单的生成两张证书，如下所示： 如图，填入域名生成一张服务器证书，然后将私钥，证书链，根证书都下载下来，保存到文件。 同样，生成一张客户端证书并保存。 客户端与服务器TLS认证在gRPC通信中，我们完成服务器认证与客户端认证主要使用的是grpc下的credentials库。下面通过实例来看看怎么使用。 代码实例 服务端实现 1234567891011121314151617181920212223242526272829303132333435363738func main() &#123; lis, err := net.Listen(&quot;tcp&quot;, &quot;:8080&quot;) if err != nil &#123; panic(err) &#125; // 加载证书和密钥 （同时能验证证书与私钥是否匹配） cert, err := tls.LoadX509KeyPair(&quot;certs/test_server.pem&quot;, &quot;certs/test_server.key&quot;) if err != nil &#123; panic(err) &#125; // 将根证书加入证书池 // 测试证书的根如果不加入可信池，那么测试证书将视为不可惜，无法通过验证。 certPool := x509.NewCertPool() rootBuf, err := ioutil.ReadFile(&quot;certs/root.pem&quot;) if err != nil &#123; panic(err) &#125; if !certPool.AppendCertsFromPEM(rootBuf) &#123; panic(&quot;fail to append test ca&quot;) &#125; tlsConf := &amp;tls.Config&#123; ClientAuth: tls.RequireAndVerifyClientCert, Certificates: []tls.Certificate&#123;cert&#125;, ClientCAs: certPool, &#125; serverOpt := grpc.Creds(credentials.NewTLS(tlsConf)) grpcServer := grpc.NewServer(serverOpt) pb.RegisterHelloWorldServiceServer(grpcServer, &amp;SayHelloServer&#123;&#125;) log.Println(&quot;Server Start...&quot;) grpcServer.Serve(lis)&#125; 客户端实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func main() &#123; cert, err := tls.LoadX509KeyPair(&quot;certs/test_client.pem&quot;, &quot;certs/test_client.key&quot;) if err != nil &#123; panic(err) &#125; // 将根证书加入证书池 certPool := x509.NewCertPool() bs, err := ioutil.ReadFile(&quot;certs/root.pem&quot;) if err != nil &#123; panic(err) &#125; if !certPool.AppendCertsFromPEM(bs) &#123; panic(&quot;fail to append test ca&quot;) &#125; // 新建凭证 // ServerName 需要与服务器证书内的通用名称一致 transportCreds := credentials.NewTLS(&amp;tls.Config&#123; ServerName: &quot;server.razeen.me&quot;, Certificates: []tls.Certificate&#123;cert&#125;, RootCAs: certPool, &#125;) dialOpt := grpc.WithTransportCredentials(transportCreds) conn, err := grpc.Dial(&quot;localhost:8080&quot;, dialOpt) if err != nil &#123; log.Fatalf(&quot;Dial failed:%v&quot;, err) &#125; defer conn.Close() client := pb.NewHelloWorldServiceClient(conn) resp1, err := client.SayHelloWorld(context.Background(), &amp;pb.HelloWorldRequest&#123; Greeting: &quot;Hello Server 1 !!&quot;, Infos: map[string]string&#123;&quot;hello&quot;: &quot;world&quot;&#125;, &#125;) if err != nil &#123; log.Printf(&quot;%v&quot;, err) &#125; log.Printf(&quot;Resp1:%+v&quot;, resp1) resp2, err := client.SayHelloWorld(context.Background(), &amp;pb.HelloWorldRequest&#123; Greeting: &quot;Hello Server 2 !!&quot;, &#125;) if err != nil &#123; log.Printf(&quot;%v&quot;, err) &#125; log.Printf(&quot;Resp2:%+v&quot;, resp2)&#125; 从代码中，我们不难看出，主要是创建一个通信凭证(TransportCredentials)。利用credentials库的NewTLS方法从tls加载一个通信凭证用于通信。而在其中需要注意的是： 如果你使用的是自签发的证书，注意将根加入证书池。如果你使用的是可信CA签发的证书大部分不用添加，因为系统的可信CA库已经有了。如果没有成功添加, 在通信时会出现以下错误： rpc error: code &#x3D; Unavailable desc &#x3D; all SubConns are in TransientFailure, latest connection error: connection error: desc &#x3D; “transport: authentication handshake failed: x509: certificate signed by unknown authority” 或 rpc error: code &#x3D; Unavailable desc &#x3D; all SubConns are in TransientFailure, latest connection error: connection error: desc &#x3D; “transport: authentication handshake failed: remote error: tls: bad certificate” 客户端凭证内 ServerName 需要与服务器证书内的通用名称一致，如果不一致会出现如下错误： rpc error: code &#x3D; Unavailable desc &#x3D; all SubConns are in TransientFailure, latest connection error: connection error: desc &#x3D; “transport: authentication handshake failed: x509: certificate is valid for server.razeen.me, not xxxxx” 之后，我们就可安心的通信了，在私钥不泄漏的情况下，基本不再担心数据劫持问题了。 这里我想多说一句：我们经常在提交代码时会直接 git add . ，这是个不好的习惯，有时后我们会将一些不必要的文件提交上去，特别是一些证书、私钥、密码之类的文件。 流式的RPC通信流式PRC通信可以分为: 服务器端流式 RPC; 客户端发送请求到服务器，拿到一个流去读取返回的消息序列。 客户端读取返回的流，直到里面没有任何消息。如： 1rpc ListHello(HelloWorldRequest) returns (stream HelloWorldResponse) &#123;&#125; 客户端流式 RPC; 客户端写入一个消息序列并将其发送到服务器，同样也是使用流。一旦客户端完成写入消息，它等待服务器完成读取返回它的响应。如： 1rpc SayMoreHello(stream HelloWorldRequest) returns (HelloWorldResponse) &#123;&#125; 双向流式 RPC; 双方使用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务器可以以任意喜欢的顺序读写。如： 1rpc SayHelloChat(stream HelloWorldRequest) returns (stream HelloWorldRequest) &#123;&#125; 从上面的定义不难看出，用stream可以定义一个流式消息。下面我们就通过实例来演示一下流式通信的使用方法。 首先，我们将上面三个rpc server加入.proto , 并且生成新的.pb.go代码。 在生成的代码hello_world.pb.go中，我们可以看到客户端接口如下： 123456type HelloWorldServiceClient interface &#123; SayHelloWorld(ctx context.Context, in *HelloWorldRequest, opts ...grpc.CallOption) (*HelloWorldResponse, error) ListHello(ctx context.Context, in *HelloWorldRequest, opts ...grpc.CallOption) (HelloWorldService_ListHelloClient, error) SayMoreHello(ctx context.Context, opts ...grpc.CallOption) (HelloWorldService_SayMoreHelloClient, error) SayHelloChat(ctx context.Context, opts ...grpc.CallOption) (HelloWorldService_SayHelloChatClient, error)&#125; 服务端接口如下: 1234567// HelloWorldServiceServer is the server API for HelloWorldService service.type HelloWorldServiceServer interface &#123; SayHelloWorld(context.Context, *HelloWorldRequest) (*HelloWorldResponse, error) ListHello(*HelloWorldRequest, HelloWorldService_ListHelloServer) error SayMoreHello(HelloWorldService_SayMoreHelloServer) error SayHelloChat(HelloWorldService_SayHelloChatServer) error&#125; 在客户段的接口中，生成了HelloWorldService_XXXXClient接口类型。 在服务端的接口中，生成了HelloWorldService_XXXXServer接口类型。 我们再查看这些接口的定义，发现这这几个接口都是实现了以下几个方法中的数个： 1234Send(*HelloWorldRequest) errorRecv() (*HelloWorldRequest, error)CloseAndRecv() (*HelloWorldResponse, error)grpc.ClientStream 看其名字，我们不难知道，流式RPC的使用，或者说流的收发也就离不开这几个方法了。下面我们通过几个实例来验证一下。 在服务端，我们实现这三个接口。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 服务器端流式 RPC, 接收一次客户端请求，返回一个流func (s *SayHelloServer) ListHello(in *pb.HelloWorldRequest, stream pb.HelloWorldService_ListHelloServer) error &#123; log.Printf(&quot;Client Say: %v&quot;, in.Greeting) // 我们返回多条数据 stream.Send(&amp;pb.HelloWorldResponse&#123;Reply: &quot;ListHello Reply &quot; + in.Greeting + &quot; 1&quot;&#125;) time.Sleep(1 * time.Second) stream.Send(&amp;pb.HelloWorldResponse&#123;Reply: &quot;ListHello Reply &quot; + in.Greeting + &quot; 2&quot;&#125;) time.Sleep(1 * time.Second) stream.Send(&amp;pb.HelloWorldResponse&#123;Reply: &quot;ListHello Reply &quot; + in.Greeting + &quot; 3&quot;&#125;) time.Sleep(1 * time.Second) return nil&#125;// 客户端流式 RPC， 客户端流式请求，服务器可返回一次func (s *SayHelloServer) SayMoreHello(stream pb.HelloWorldService_SayMoreHelloServer) error &#123; // 接受客户端请求 for &#123; req, err := stream.Recv() if err == io.EOF &#123; break &#125; if err != nil &#123; return err &#125; log.Printf(&quot;SayMoreHello Client Say: %v&quot;, req.Greeting) &#125; // 流读取完成后，返回 return stream.SendAndClose(&amp;pb.HelloWorldResponse&#123;Reply: &quot;SayMoreHello Recv Muti Greeting&quot;&#125;)&#125;// 双向流式 RPCfunc (s *SayHelloServer) SayHelloChat(stream pb.HelloWorldService_SayHelloChatServer) error &#123; // 开一个协程去处理客户端数据 go func() &#123; for &#123; req, err := stream.Recv() if err == io.EOF &#123; break &#125; if err != nil &#123; return &#125; log.Printf(&quot;SayHelloChat Client Say: %v&quot;, req.Greeting) &#125; &#125;() // 向客户端写入多条数据 stream.Send(&amp;pb.HelloWorldRequest&#123;Greeting: &quot;SayHelloChat Server Say Hello 1&quot;&#125;) time.Sleep(1 * time.Second) stream.Send(&amp;pb.HelloWorldRequest&#123;Greeting: &quot;SayHelloChat Server Say Hello 2&quot;&#125;) time.Sleep(1 * time.Second) stream.Send(&amp;pb.HelloWorldRequest&#123;Greeting: &quot;SayHelloChat Server Say Hello 3&quot;&#125;) time.Sleep(1 * time.Second) return nil&#125; 之后我们就可以在客户端分别请求这几个rpc服务。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 // 服务器端流式 RPC; // 我们向服务器SayHello recvListHello, err := client.ListHello(context.Background(), &amp;pb.HelloWorldRequest&#123;Greeting: &quot;Hello Server List Hello&quot;&#125;) if err != nil &#123; log.Fatalf(&quot;ListHello err: %v&quot;, err) &#125; // 服务器以流式返回 // 直到 err==io.EOF时，表示接收完毕。 for &#123; resp, err := recvListHello.Recv() if err == io.EOF &#123; break &#125; if err != nil &#123; log.Fatal(err) &#125; log.Printf(&quot;ListHello Server Resp: %v&quot;, resp.Reply) &#125;// Client Out:// 2018/08/06 01:27:55 ListHello Server Resp: ListHello Reply Hello Server List Hello 1// 2018/08/06 01:27:56 ListHello Server Resp: ListHello Reply Hello Server List Hello 2// 2018/08/06 01:27:57 ListHello Server Resp: ListHello Reply Hello Server List Hello 3// Server Out:// 2018/08/06 01:27:55 Client Say: Hello Server List Hello // 客户端流式 RPC; sayMoreClient, err := client.SayMoreHello(context.Background()) if err != nil &#123; log.Fatal(err) &#125; for i := 0; i &lt; 3; i++ &#123; sayMoreClient.Send(&amp;pb.HelloWorldRequest&#123;Greeting: fmt.Sprintf(&quot;SayMoreHello Hello Server %d&quot;, i)&#125;) &#125; sayMoreResp, err := sayMoreClient.CloseAndRecv() if err != nil &#123; log.Fatal(err) &#125; log.Printf(&quot;SayMoreHello Server Resp: %v&quot;, sayMoreResp.Reply)// Client Out:// 2018/08/06 01:31:11 SayMoreHello Server Resp: SayMoreHello Recv Muti Greeting// Server Out:// 2018/08/06 01:31:11 SayMoreHello Client Say: SayMoreHello Hello Server 0// 2018/08/06 01:31:11 SayMoreHello Client Say: SayMoreHello Hello Server 1// 2018/08/06 01:31:11 SayMoreHello Client Say: SayMoreHello Hello Server 2 // 双向流式 RPC; sayHelloChat, err := client.SayHelloChat(context.Background()) if err != nil &#123; log.Fatal(err) &#125; go func() &#123; for i := 0; i &lt; 3; i++ &#123; sayHelloChat.Send(&amp;pb.HelloWorldRequest&#123;Greeting: fmt.Sprintf(&quot;SayHelloChat Hello Server %d&quot;, i)&#125;) &#125; &#125;() for &#123; resp, err := sayHelloChat.Recv() if err == io.EOF &#123; break &#125; if err != nil &#123; log.Fatal(err) &#125; log.Printf(&quot;SayHelloChat Server Say: %v&quot;, resp.Greeting) &#125;// Client Out:// 2018/08/06 01:31:11 SayHelloChat Server Say: SayHelloChat Server Say Hello 1// 2018/08/06 01:31:12 SayHelloChat Server Say: SayHelloChat Server Say Hello 2// 2018/08/06 01:31:13 SayHelloChat Server Say: SayHelloChat Server Say Hello 3// Server Out:// 2018/08/06 01:31:11 SayHelloChat Client Say: SayHelloChat Hello Server 0// 2018/08/06 01:31:11 SayHelloChat Client Say: SayHelloChat Hello Server 1// 2018/08/06 01:31:11 SayHelloChat Client Say: SayHelloChat Hello Server 2 看了实例，是不是觉得很简单～。三种方式大同小异，只要掌握了怎么去收发流，怎么判断流的结束，基本就可以了。 好了，gRPC在Go中的使用三篇文章到这里也就结束了，如果博客中有错误或者你还有想知道的，记得留言哦。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://github.com/timmy6/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://github.com/timmy6/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"gRPC在Go中的使用（二）gRPC实现简单通讯","slug":"grpc2","date":"2018-09-25T07:27:50.000Z","updated":"2022-05-11T07:36:35.388Z","comments":true,"path":"2018/09/25/grpc2/","link":"","permalink":"https://github.com/timmy6/2018/09/25/grpc2/","excerpt":"Desc:gRPC实现简单通讯,Google 开源 RPC 框架 gRPC 初探 在上一篇中，我们用protobuf定义了两个消息HelloWorldRequest与HelloWorldResponse以及一个HelloWorldService服务。同时，我们还生成了相应的go代码.pb.go。 那么客户端与服务端怎么去通过这些接口去完成通讯呢？下面我们一起实现一个简单的gRPC通讯。","text":"Desc:gRPC实现简单通讯,Google 开源 RPC 框架 gRPC 初探 在上一篇中，我们用protobuf定义了两个消息HelloWorldRequest与HelloWorldResponse以及一个HelloWorldService服务。同时，我们还生成了相应的go代码.pb.go。 那么客户端与服务端怎么去通过这些接口去完成通讯呢？下面我们一起实现一个简单的gRPC通讯。 在RPC通讯中，客户端使用存根(SayHelloWorld)发送请求到服务器并且等待响应返回，整个过程就像我们平常函数调用一样。 123service HelloWorldService &#123; rpc SayHelloWorld(HelloWorldRequest) returns (HelloWorldResponse)&#123;&#125;&#125; 那么接下来，我们先创建一个服务端。 创建服务端在生成的hello_world.pb.go中，已经为我们生成了服务端的接口： 1234// HelloWorldServiceServer is the server API for HelloWorldService service.type HelloWorldServiceServer interface &#123; SayHelloWorld(context.Context, *HelloWorldRequest) (*HelloWorldResponse, error)&#125; 在服务端我们首先要做的就是实现这个接口。 12345678910111213141516171819202122type SayHelloServer struct&#123;&#125;func (s *SayHelloServer) SayHelloWorld(ctx context.Context, in *pb.HelloWorldRequest) (res *pb.HelloWorldResponse, err error) &#123; log.Printf(&quot;Client Greeting:%s&quot;, in.Greeting) log.Printf(&quot;Client Info:%v&quot;, in.Infos) var an *any.Any if in.Infos[&quot;hello&quot;] == &quot;world&quot; &#123; an, err = ptypes.MarshalAny(&amp;pb.HelloWorld&#123;Msg: &quot;Good Request&quot;&#125;) &#125; else &#123; an, err = ptypes.MarshalAny(&amp;pb.Error&#123;Msg: []string&#123;&quot;Bad Request&quot;, &quot;Wrong Info Msg&quot;&#125;&#125;) &#125; if err != nil &#123; return &#125; return &amp;pb.HelloWorldResponse&#123; Reply: &quot;Hello World !!&quot;, Details: []*any.Any&#123;an&#125;, &#125;, nil&#125; 简单如上面的几行，实现了这个接口我们只需要创建一个结构SayHelloServer,同时实现HelloWorldServiceServer的所有方法即可。 这里为了演示效果我打印了一些数据，同时利用any.Any在不同的情况下返回不同的类型数据。 当然，只是现实了接口还不够，我们还需要启动一个服务，这样客户端才能使用该服务。启动服务很简单，就像我们平常启用一个Server一样。 1234567891011121314func main() &#123; // 我们首先须监听一个tcp端口 lis, err := net.Listen(&quot;tcp&quot;, &quot;:8080&quot;) if err != nil &#123; panic(err) &#125; // 新建一个grpc服务器 grpcServer := grpc.NewServer() // 向grpc服务器注册SayHelloServer pb.RegisterHelloWorldServiceServer(grpcServer, &amp;SayHelloServer&#123;&#125;) // 启动服务 grpcServer.Serve(lis)&#125; 从上面的代码，我们可以看到，简单的4步即可启动一个服务。 监听一个服务端口，供客户端调用； 创建一个grpc服务器，当然这里可以设置授权认证,这个在下一篇中我们将详细介绍； 注册服务，其实是调用生存的.pb.go中的RegisterHelloWorldServiceServer方法，将我们这里实现的SayHelloServer加入到该服务中。 启动服务，等待客户端连接。 我们 go run server.go,无任何报错，这样一个简单的grpc服务的服务端就准备就绪了。接下来我们看看客户端。 创建客户端例如： 1234567891011121314151617181920212223242526func main() &#123; // 创建一个 gRPC channel 和服务器交互 conn, err := grpc.Dial(&quot;localhost:8080&quot;, grpc.WithInsecure()) if err != nil &#123; log.Fatalf(&quot;Dial failed:%v&quot;, err) &#125; defer conn.Close() // 创建客户端 client := pb.NewHelloWorldServiceClient(conn) // 直接调用 resp1, err := client.SayHelloWorld(context.Background(), &amp;pb.HelloWorldRequest&#123; Greeting: &quot;Hello Server 1 !!&quot;, Infos: map[string]string&#123;&quot;hello&quot;: &quot;world&quot;&#125;, &#125;) log.Printf(&quot;Resp1:%+v&quot;, resp1) resp2, err := client.SayHelloWorld(context.Background(), &amp;pb.HelloWorldRequest&#123; Greeting: &quot;Hello Server 2 !!&quot;, &#125;) log.Printf(&quot;Resp2:%+v&quot;, resp2)&#125; 客户端的实现比服务端更简洁，三步即可。 创建一个 gRPC channel 和服务器交互。这里也是可以设置授权认证的； 创建一个客户端去执行RPC。用到的也是.pb.go内的NewHelloWorldServiceClient方法； 像函数调用一样去调用RPC服务。 我直接RUN起来，如下，我们可以看到客户端发送到服务的消息以及服务端对不同消息的不同回复。 那么到这里，我们简单的实现了一个gRPC通讯。但很多时候，我们可能希望客户端与服务器能更安全的通信，或者客户端与服务器不再是一种固定的结构的传输，需要流式的去处理一些问题等等。针对这些问题，在下一篇博客中，我将结合实例详细说明。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://github.com/timmy6/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://github.com/timmy6/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"gRPC在Go中的使用（一）Protocol Buffers语法与相关使用","slug":"grpc1","date":"2018-09-20T06:07:50.000Z","updated":"2022-05-11T07:30:48.680Z","comments":true,"path":"2018/09/20/grpc1/","link":"","permalink":"https://github.com/timmy6/2018/09/20/grpc1/","excerpt":"Desc:protobuf语法介绍，怎么写proto文件，grpc的使用入门 在gRPC官网用了一句话来介绍:“一个高性能、开源的通用RPC框架”，同时介绍了其四大特点： 定义简单 支持多种编程语言多种平台 快速启动和缩放 双向流媒体和集成身份验证","text":"Desc:protobuf语法介绍，怎么写proto文件，grpc的使用入门 在gRPC官网用了一句话来介绍:“一个高性能、开源的通用RPC框架”，同时介绍了其四大特点： 定义简单 支持多种编程语言多种平台 快速启动和缩放 双向流媒体和集成身份验证 在gRPC在go中使用系列中，关于其简介与性能我就不多介绍，相信在社区也有很多关于这些的讨论。这里我主要从三个层次来总结我以往在Go中使用gRPC的一些经验，主要分为： Protocol Buffers语法与相关使用 gRPC实现简单通讯 gRPC服务认证与双向流通讯 *注:下面Protocol Buffers简写protobuf. 这篇我们先介绍protobuf的相关语法、怎么书写.proto文件以及go代码生成。 简介要熟练的使用GRPC，protobuf的熟练使用必不可少。 gRPC使用protobuf来定义服务。protobuf是由Google开发的一种数据序列化协议，可以把它想象成是XML或JSON格式，但更小，更快更简洁。而且一次定义，可生成多种语言的代码。 定义首先我们需要编写一些.proto文件，定义我们在程序中需要处理的结构化数据。我们直接从一个实例开始讲起，下面是一个proto文件： 123456789101112131415161718192021syntax = &quot;proto3&quot;;option go_package = &quot;github.com/razeencheng/demo-go/grpc/demo1/helloworld&quot;;package helloworld;import &quot;github.com/golang/protobuf/ptypes/any/any.proto&quot;;message HelloWorldRequest &#123; string greeting = 1; map&lt;string, string&gt; infos = 2;&#125;message HelloWorldResponse &#123; string reply = 1; repeated google.protobuf.Any details = 2;&#125;service HelloWorldService &#123; rpc SayHelloWorld(HelloWorldRequest) returns (HelloWorldResponse)&#123;&#125;&#125; 版本文件的开头syntax=&quot;proto3&quot;也就指明版本，主要有proto2与proto3,他们在语法上有一定的差异，我这里主要使用的是后者。 包名第二行，指定生成go文件的包名，可选项，默认使用第三行包名。 第三行，包名。 导包第四行，类似你写go一样，protobuf也可以导入其他的包。 消息定义后面message开头的两个结构就是我们需要传递的消息类型。所有的消息类型都是以message开始，然后定义类型名称。结构内字段的定义为字段规则 字段类型 字段名=字段编号 字段规则主要有 singular和repeated。如其中greeting和reply的字段规则为singular,允许该消息中出现0个或1个该字段(但不能超过一个)，而像details字段允许重复任意次数。其实对应到go里面也就是基本类型和切片类型。 字段类型，下表是proto内类型与go类型的对应表。 .proto Type Notes Go Type double float64 float float32 int32 使用可变长度编码。 无效编码负数 - 如果您的字段可能具有负值， 请改用sint32。 int32 int64 使用可变长度编码。 无效编码负数 - 如果您的字段可能具有负值，请改用sint64。 int64 uint32 使用可变长度编码。 uint32 uint64 使用可变长度编码。 uint64 sint32 使用可变长度编码。 带符号的int值。 这些比常规的int32更有效地编码负数。 int32 sint64 使用可变长度编码。 带符号的int值。 这些比常规的int64更有效地编码负数。 int64 fixed32 总是四个字节。 如果值通常大于228，则比uint32效率更高。 uint32 fixed64 总是八个字节。 如果值通常大于256，则会比uint64更高效。 uint64 sfixed32 总是四个字节。 int32 sfixed64 总是八个字节。 int64 bool bool string 字符串必须始终包含UTF-8编码或7位ASCII文本。 string bytes 可能包含任何字节序列。 []byte 看到这里你也许会疑惑，go里面的切片，map，接口等类型我怎么定义呢？别急，下面一一替你解答。 1.map类型，HelloWorldRequest的infos就是一个map类型，它的结构为map&lt;key_type, value_type&gt; map_field = N 但是在使用的时候你需要注意map类型不能repetead。 2.切片类型，我们直接定义其规则为repeated就可以了。就像HelloWorldResponse中的details字段一样，它就是一个切片类型。那么你会问了它是什么类型的切片？这就看下面了~ 3.接口类型在proto中没有直接实现，但在google&#x2F;protobuf&#x2F;any.proto中定义了一个google.protobuf.Any类型，然后结合protobuf&#x2F;go也算是曲线救国了~ 字段编号 最后的1，2代表的是每个字段在该消息中的唯一标签，在与消息二进制格式中标识这些字段，而且当你的消息在使用的时候该值不能改变。1到15都是用一个字节编码的，通常用于标签那些频繁发生修改的字段。16到2047用两个字节编码，最大的是2^29-1(536,870,911)，其中19000-19999为预留的，你也不可使用。 服务定义如果你要使用RPC(远程过程调用)系统的消息类型，那就需要定义RPC服务接口，protobuf编译器将会根据所选择的不同语言生成服务接口代码及存根。就如： 123service HelloWorldService &#123; rpc SayHelloWorld(HelloWorldRequest) returns (HelloWorldResponse)&#123;&#125;&#125; protobuf编译器将产生一个抽象接口HelloWorldService以及一个相应的存根实现。存根将所有的调用指向RpcChannel(SayHelloWorld)，它是一个抽象接口，必须在RPC系统中对该接口进行实现。具体如何使用，将在下一篇博客中详细介绍。 生成Go代码安装protoc首先要安装protoc,可直接到这里下载二进制安装到 $PATH里面，也可以直接下载源码编译。除此之外，你还需要安装go的proto插件protoc-gen-go。 12345// mac terminalgo get -u github.com/golang/protobuf/&#123;proto,protoc-gen-go&#125;// win powershellgo get -u github.com/golang/protobuf/protogo get -u github.com/golang/protobuf/protoc-gen-go 生成go代码接下来，使用protoc命令即可生成。 1234### mac terminalprotoc -I $&#123;GOPATH&#125;/src --go_out=plugins=grpc:$&#123;GOPATH&#125;/src $&#123;GOPATH&#125;/src/github.com/razeencheng/demo-go/grpc/demo1/helloworld/hello_world.proto### win powershellprotoc -I $env:GOPATH\\src --go_out=plugins=grpc:$env:GOPATH\\src $env:GOPATH\\src\\github.com\\razeencheng\\demo-go\\grpc\\demo1\\helloworld\\hello_world.proto 如上所示 -I指定搜索proto文件的目录,--go_out=plugins=grpc:指定生成go代码的文件夹，后面就是需要生成的proto文件路径。 注意： 如果你使用到了其他包的结构，-I需要将该资源包括在内。 例如我导入了github.com/golang/protobuf/ptypes/any/any.proto 我首先需要 go get -u github.com/golang/protobuf获取该包，然后在使用时资源路径(-I)直接为GOPATH\\src。 最后生成的hello-world.pb.go文件。内容大概如下图所示 图中我们可以看到两个message对应生成了两个结构体，同时会生成一些序列化的方法等。 而定义的service则是生成了对应的client与server接口，那么这到底有什么用？怎么去用呢？将为你详细讲解~ 看到这，我们简单的了解一下protobuf语法，如果你想了解更多，点这里看官方文档。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://github.com/timmy6/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://github.com/timmy6/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"怎么写Go基准测试（性能测试)","slug":"benchmark","date":"2018-09-15T03:07:50.000Z","updated":"2022-05-11T07:26:03.950Z","comments":true,"path":"2018/09/15/benchmark/","link":"","permalink":"https://github.com/timmy6/2018/09/15/benchmark/","excerpt":"或许你经常会思考这样的问题，我用不同的方法实现了同样的效果，哪个会更快？哪个内存消耗更小？这时候你一个简单的基准测试就能解决你的疑惑。","text":"或许你经常会思考这样的问题，我用不同的方法实现了同样的效果，哪个会更快？哪个内存消耗更小？这时候你一个简单的基准测试就能解决你的疑惑。 Go向来是以工具丰富而著称的，在学习Go的过程中，你会发现无论是写一个单元测试，还是做一些竞争检测都能很快的上手，而且用的很痛快。当然，接下来要说的基准测试也一样。 基准测试工具就在Go的测试包中，下面就用一个例子来介绍。 举个栗子由于一些场景需要，我需要将[]byte输出16进制字符。 有时候我会这么写: 1fmt.Sprintf(&quot;%x&quot;, b) 但有时候我会这么写： 1hex.EncodeToString(b) 但到底哪种写法更好呢？今天我就来比较一下。 直接写了个main.go 1234567func EncodeA(b []byte) string &#123; return fmt.Sprintf(&quot;%x&quot;, b)&#125;func EncodeB(b []byte) string &#123; return hex.EncodeToString(b)&#125; 再写个测试main_test.go 12345678910111213var buf = []byte(&quot;skdjadialsdgasadasdhsakdjsahlskdjagloqweiqwo&quot;)func BenchmarkEncodeA(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; EncodeA(buf) &#125;&#125;func BenchmarkEncodeB(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; EncodeB(buf) &#125;&#125; 就这么简单，我们的基本测试就写完了。从我的写法中你也许就知道： 和单元测试一样，都写在_test.go文件中； 需要以Benchmark为函数名开头； 和单元测试类似，必须接受一个*testing.B参数； 被测试代码放在一个循环中。 我们直接跑一下。当然我们也是用go test来执行测试，简单的测试只要带上-bench=.就可以了。 12345678$ go test -bench=.goos: darwingoarch: amd64pkg: github.com/razeencheng/demo-go/benchmarkBenchmarkEncodeA-8 5000000 265 ns/opBenchmarkEncodeB-8 10000000 161 ns/opPASSok github.com/razeencheng/demo-go/benchmark 3.397s 前两行是平台信息，第三行包名。第四、五行就是测试的结果了。 BenchmarkEncodeA-8 ,BenchmarkEncodeB-8 基准测试函数名-GOMAXPROCS 5000000,10000000 被测试的函数执行次数，也就是EncodeA()被执行了5000000次，EncodeB()被执行了10000000次，也就是b.N的值了。 265 ns/op,161 ns/op表示每次调用被测试函数花费的时间。 从花费的时间上来看，我们知道EncodeB()要快一点。 更多你以为就这么简单的结束了么？NONONO。 -bench 可接收一个有效的正则表达式来执行符合条件的测试函数。当你的函数很多时，可以用它来过滤. 1234567$ go test -bench=BenchmarkEncodeAgoos: darwingoarch: amd64pkg: github.com/razeencheng/demo-go/benchmarkBenchmarkEncodeA-8 5000000 256 ns/opPASSok github.com/razeencheng/demo-go/benchmark 1.575s -benchmem可以查看内存分配 12345678$ go test -bench=. -benchmemgoos: darwingoarch: amd64pkg: github.com/razeencheng/demo-go/benchmarkBenchmarkEncodeA-8 5000000 261 ns/op 128 B/op 2 allocs/opBenchmarkEncodeB-8 10000000 162 ns/op 192 B/op 2 allocs/opPASSok github.com/razeencheng/demo-go/benchmark 3.408s 其中B/op 表示每次执行会分配多少内存，allocs/op表示每次执行会发生多少次内存分配。 -benchtime指定每个测试执行的时间。默认1s,当你的函数比较耗时你可以设置更长一点。因为b.N是与这个时间有关的。 当你的运行时间没达到-benchtime制定的时间前，b.N将以1，2，5，10，20，50…增加，然后重新运行测试代码。 12345678$ go test -bench=. -benchmem -benchtime=5sgoos: darwingoarch: amd64pkg: github.com/razeencheng/demo-go/benchmarkBenchmarkEncodeA-8 30000000 254 ns/op 128 B/op 2 allocs/opBenchmarkEncodeB-8 50000000 160 ns/op 192 B/op 2 allocs/opPASSok github.com/razeencheng/demo-go/benchmark 16.113s -count指定每个测试执行的次数。 123456789101112$ go test -bench=. -benchmem -count=3goos: darwingoarch: amd64pkg: github.com/razeencheng/demo-go/benchmarkBenchmarkEncodeA-8 5000000 256 ns/op 128 B/op 2 allocs/opBenchmarkEncodeA-8 5000000 255 ns/op 128 B/op 2 allocs/opBenchmarkEncodeA-8 5000000 253 ns/op 128 B/op 2 allocs/opBenchmarkEncodeB-8 10000000 163 ns/op 192 B/op 2 allocs/opBenchmarkEncodeB-8 10000000 160 ns/op 192 B/op 2 allocs/opBenchmarkEncodeB-8 10000000 160 ns/op 192 B/op 2 allocs/opPASSok github.com/razeencheng/demo-go/benchmark 9.984s 我常用的也就这些了。 但对于testing.B来说，它拥有了testing.T的全部接口，所以Fail,Skip,Error这些都可以用，而且还增加了 SetBytes( i uint64) 统计内存消耗。 SetParallelism(p int) 制定并行数目。 StartTimer / StopTimer / ResertTimer 操作计时器。 你可以按需使用。 注意b.N为一个自增字段，谨慎用它做函数参数。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://github.com/timmy6/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://github.com/timmy6/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"你好，Go语言","slug":"hello-wrold","date":"2018-09-11T03:07:50.000Z","updated":"2022-05-11T03:22:40.468Z","comments":true,"path":"2018/09/11/hello-wrold/","link":"","permalink":"https://github.com/timmy6/2018/09/11/hello-wrold/","excerpt":"","text":"你好，Go语言 Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。 因工作需要，准备入坑，先从环境安装开始，输出一个 Hello World。 环境安装目标 安装完成并运行 Hello World 成功！ 本机系统：macOS High Sierra 10.13.4 Go 版本：1.12 方式一： 通过 brew 安装 1brew install go 根据提示进行安装吧，我使用的 方式二 进行安装的。 方式二： 通过安装包安装 地址：https://dl.google.com/go/go1.12.darwin-amd64.pkg 下载之后直接点击安装，一步步继续即可。 配置环境变量 123456vi ~/.bashrc//新增export GOROOT=/usr/local/goexport GOPATH=/Users/username/go/code //代码目录，自定义即可export PATH=$PATH:$GOPATH/bin 及时生效，请执行命令：source ~&#x2F;.bashrc 如果命令行使用的是zsh，请修改 .zshrc 文件。 123456vi ~/.zshrc//新增export GOROOT=/usr/local/goexport GOPATH=/Users/username/go/code //自定义代码目录export PATH=$PATH:$GOPATH/bin 及时生效，请执行命令：source ~&#x2F;.zshrc 验证是否安装成功，命令行下执行： 目录结构bin 存放编译后可执行的文件。 pkg 存放编译后的应用包。 src 存放应用源代码。 例如： 123456├─ code -- 代码根目录│ ├─ bin│ ├─ pkg│ ├─ src│ ├── hello│ ├── hello.go Hello World 代码 1234567891011//在 hello 目录下创建 hello.gopackage mainimport ( &quot;fmt&quot;)func main() &#123; fmt.Println(&quot;Hello World!&quot;)&#125; 命令行执行： 命令查看完整的命令： go build hello 在src目录或hello目录下执行 go build hello，只在对应当前目录下生成文件。 go install hello 在src目录或hello目录下执行 go install hello，会把编译好的结果移动到 $GOPATH&#x2F;bin。 go run hello 在src目录或hello目录下执行 go run hello，不生成任何文件只运行程序。 go fmt hello 在src目录或hello目录下执行 go run hello，格式化代码，将代码修改成标准格式。 其他命令，需要的时候再进行研究吧。 开发工具GoLand GoLand 是 JetBrains 公司推出的 Go 语言集成开发环境，与我们用的 WebStorm、PhpStorm、PyCharm 是一家，同样支持 Windows、Linux、macOS 等操作系统。 下载地址：https://www.jetbrains.com/go/ 软件是付费的，不过想想办法，软件可以永久激活的。 学习网址 Go语言：https://golang.org/ Go语言中文网：https://studygolang.com/ Go语言包管理：https://gopm.io/","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://github.com/timmy6/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://github.com/timmy6/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]},{"title":"变量声明","slug":"var_dec","date":"2018-05-11T03:11:38.000Z","updated":"2022-05-11T03:17:32.142Z","comments":true,"path":"2018/05/11/var_dec/","link":"","permalink":"https://github.com/timmy6/2018/05/11/var_dec/","excerpt":"","text":"概述在声明变量之前，咱们先了解下变量的数据类型，这篇文章主要涉及 字符串、布尔、数字，其他类型后面开篇再说。 数据类型字符串string 只能用一对双引号（””）或反引号（&#96;&#96;）括起来定义，不能用单引号（’’）定义！ 布尔bool 只有 true 和 false，默认为 false。 数字整型 int8 uint8 int16 uint16 int32 uint32 int64 uint64 int uint，具体长度取决于 CPU 位数。 浮点型 float32 float64 常量声明常量，在程序编译阶段就确定下来的值，而程序在运行时无法改变该值。 单个常量声明 第一种：const 变量名称 数据类型 &#x3D; 变量值 如果不赋值，使用的是该数据类型的默认值。 第二种：const 变量名称 &#x3D; 变量值 根据变量值，自行判断数据类型。 多个常量声明 第一种：const 变量名称,变量名称 … ,数据类型 &#x3D; 变量值,变量值 … 第二种：const 变量名称,变量名称 … &#x3D; 变量值,变量值 … 测试代码 1234567891011121314151617181920//demo_1.gopackage mainimport ( &quot;fmt&quot;)func main() &#123; const name string = &quot;Tom&quot; fmt.Println(name) const age = 30 fmt.Println(age) const name_1, name_2 string = &quot;Tom&quot;, &quot;Jay&quot; fmt.Println(name_1, name_2) const name_3, age_1 = &quot;Tom&quot;, 30 fmt.Println(name_3, age_1)&#125; 运行结果： 变量声明单个变量声明 第一种：var 变量名称 数据类型 &#x3D; 变量值 如果不赋值，使用的是该数据类型的默认值。 第二种：var 变量名称 &#x3D; 变量值 根据变量值，自行判断数据类型。 第三种：变量名称 :&#x3D; 变量值 省略了 var 和数据类型，变量名称一定要是未声明过的。 多个变量声明 第一种：var 变量名称,变量名称 … ,数据类型 &#x3D; 变量值,变量值 … 第二种：var 变量名称,变量名称 … &#x3D; 变量值,变量值 … 第三种：变量名称,变量名称 … :&#x3D; 变量值,变量值 … 测试代码 12345678910111213141516171819202122//demo_2.gopackage mainimport ( &quot;fmt&quot;)func main() &#123; var age_1 uint8 = 31 var age_2 = 32 age_3 := 33 fmt.Println(age_1, age_2, age_3) var age_4, age_5, age_6 int = 31, 32, 33 fmt.Println(age_4, age_5, age_6) var name_1, age_7 = &quot;Tom&quot;, 30 fmt.Println(name_1, age_7) name_2, is_boy, height := &quot;Jay&quot;, true, 180.66 fmt.Println(name_2, is_boy, height)&#125; 运行结果： 输出方法fmt.Print：输出到控制台（仅只是输出） fmt.Println：输出到控制台并换行 fmt.Printf：仅输出格式化的字符串和字符串变量（整型和整型变量不可以） fmt.Sprintf：格式化并返回一个字符串，不输出。 测试代码 1234567891011121314//demo_3.gopackage mainimport ( &quot;fmt&quot;)func main() &#123; fmt.Print(&quot;输出到控制台不换行&quot;) fmt.Println(&quot;---&quot;) fmt.Println(&quot;输出到控制台并换行&quot;) fmt.Printf(&quot;name=%s,age=%d\\n&quot;, &quot;Tom&quot;, 30) fmt.Printf(&quot;name=%s,age=%d,height=%v\\n&quot;, &quot;Tom&quot;, 30, fmt.Sprintf(&quot;%.2f&quot;, 180.567))&#125; 运行结果：","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://github.com/timmy6/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[]}],"categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://github.com/timmy6/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"程序员","slug":"程序员","permalink":"https://github.com/timmy6/tags/%E7%A8%8B%E5%BA%8F%E5%91%98/"}]}