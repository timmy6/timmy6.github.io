{"meta":{"title":"Hexo","subtitle":"","description":"","author":"John Doe","url":"https://timmy6.github.io","root":"/"},"pages":[{"title":"Repositories","date":"2022-05-11T02:54:02.124Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"repository/index.html","permalink":"https://timmy6.github.io/repository/index.html","excerpt":"","text":""},{"title":"分类","date":"2022-05-11T03:33:53.548Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"categories/index.html","permalink":"https://timmy6.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2022-05-13T09:50:02.369Z","updated":"2022-03-21T07:18:46.000Z","comments":true,"path":"links/index.html","permalink":"https://timmy6.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2022-05-13T09:49:24.041Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"tags/index.html","permalink":"https://timmy6.github.io/tags/index.html","excerpt":"","text":""},{"title":"书单","date":"2022-05-13T09:49:57.974Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"books/index.html","permalink":"https://timmy6.github.io/books/index.html","excerpt":"","text":""},{"title":"关于","date":"2022-05-13T09:50:04.693Z","updated":"2022-03-21T07:18:46.000Z","comments":false,"path":"about/index.html","permalink":"https://timmy6.github.io/about/index.html","excerpt":"","text":"个人详细介绍"}],"posts":[{"title":"路由中间件 - 捕获异常","slug":"catch-error","date":"2019-03-25T13:25:20.000Z","updated":"2022-05-13T09:46:42.880Z","comments":true,"path":"2019/03/25/catch-error/","link":"","permalink":"https://timmy6.github.io/2019/03/25/catch-error/","excerpt":"","text":"概述首先同步下项目概况： 上篇文章分享了，路由中间件 - 日志记录，这篇文章咱们分享：路由中间件 - 捕获异常。当系统发生异常时，提示 “系统异常，请联系管理员！”，同时并发送 panic 告警邮件。 什么是异常？在 Go 中异常就是 panic，它是在程序运行的时候抛出的，当 panic 抛出之后，如果在程序里没有添加任何保护措施的话，控制台就会在打印出 panic 的详细情况，然后终止运行。 我们可以将 panic 分为两种： 一种是有意抛出的，比如， 1panic(&quot;自定义的 panic 信息&quot;) 输出： 1232019/09/10 20:25:27 http: panic serving [::1]:61547: 自定义的 panic 信息goroutine 8 [running]:... 一种是无意抛出的，写程序马虎造成，比如， 123var slice = [] int &#123;1, 2, 3, 4, 5&#125;slice[6] = 6 输出： 1232019/09/10 15:27:05 http: panic serving [::1]:61616: runtime error: index out of rangegoroutine 6 [running]:... 想象一下，如果在线上环境出现了 panic，命令行输出的，因为咱们无法捕获就无法定位问题呀，想想都可怕，那么问题来了，怎么捕获异常？ 怎么捕获异常？当程序发生 panic 后，在 defer(延迟函数) 内部可以调用 recover 进行捕获。 不多说，直接上代码： 12345defer func() &#123; if err := recover(); err != nil &#123; fmt.Println(err) &#125;&#125;() 在运行一下 “无意抛出的 panic ”，输出： 1runtime error: index out of range OK，错误捕获到了，这时我们可以进行做文章了。 做啥文章，大家应该都知道了吧： 获取运行时的调用栈（debug.Stack()） 获取当时的 Request 数据 组装数据，进行发邮件 那么，Go 怎么发邮件呀，有没有开源包呀？ 当然有，请往下看。 封装发邮件方法使用包：gopkg.in/gomail.v2 直接上代码： 1234567891011121314151617181920212223242526272829func SendMail(mailTo string, subject string, body string) error &#123; if config.ErrorNotifyOpen != 1 &#123; return nil &#125; m := gomail.NewMessage() //设置发件人 m.SetHeader(&quot;From&quot;, config.SystemEmailUser) //设置发送给多个用户 mailArrTo := strings.Split(mailTo, &quot;,&quot;) m.SetHeader(&quot;To&quot;, mailArrTo...) //设置邮件主题 m.SetHeader(&quot;Subject&quot;, subject) //设置邮件正文 m.SetBody(&quot;text/html&quot;, body) d := gomail.NewDialer(config.SystemEmailHost, config.SystemEmailPort, config.SystemEmailUser, config.SystemEmailPass) err := d.DialAndSend(m) if err != nil &#123; fmt.Println(err) &#125; return err&#125; 在这块我加了一个开关，想开想关，您随意。 现在会发送邮件了，再整个邮件模板就完美了。 自定义邮件模板如图： 这就是告警邮件的模板，还不错吧，大家还想记录什么，可以自定义去修改。 封装一个中间件最后，封装一下。 直接上代码： 1234567891011121314151617181920212223242526272829func SetUp() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; defer func() &#123; if err := recover(); err != nil &#123; DebugStack := &quot;&quot; for _, v := range strings.Split(string(debug.Stack()), &quot;\\n&quot;) &#123; DebugStack += v + &quot;&lt;br&gt;&quot; &#125; subject := fmt.Sprintf(&quot;【重要错误】%s 项目出错了！&quot;, config.AppName) body := strings.ReplaceAll(MailTemplate, &quot;&#123;ErrorMsg&#125;&quot;, fmt.Sprintf(&quot;%s&quot;, err)) body = strings.ReplaceAll(body, &quot;&#123;RequestTime&#125;&quot;, util.GetCurrentDate()) body = strings.ReplaceAll(body, &quot;&#123;RequestURL&#125;&quot;, c.Request.Method + &quot; &quot; + c.Request.Host + c.Request.RequestURI) body = strings.ReplaceAll(body, &quot;&#123;RequestUA&#125;&quot;, c.Request.UserAgent()) body = strings.ReplaceAll(body, &quot;&#123;RequestIP&#125;&quot;, c.ClientIP()) body = strings.ReplaceAll(body, &quot;&#123;DebugStack&#125;&quot;, DebugStack) _ = util.SendMail(config.ErrorNotifyUser, subject, body) utilGin := util.Gin&#123;Ctx: c&#125; utilGin.Response(500, &quot;系统异常，请联系管理员！&quot;, nil) &#125; &#125;() c.Next() &#125;&#125; 当发生 panic 异常时，输出： 12345&#123; &quot;code&quot;: 500, &quot;msg&quot;: &quot;系统异常，请联系管理员！&quot;, &quot;data&quot;: null&#125; 同时，还会收到一封 panic 告警邮件。 便于截图，DebugStack 删减了一些信息。 到这，就结束了。 备注 发邮件的地方，可以调整为异步发送。 文章中仅贴了部分代码，相关代码请查阅 github。 测试发邮件时，一定要配置邮箱信息。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"gin框架","slug":"gin框架","permalink":"https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"}]},{"title":"路由中间件 - 日志记录","slug":"gin-log-1","date":"2019-03-10T11:22:20.000Z","updated":"2022-05-13T09:40:47.454Z","comments":true,"path":"2019/03/10/gin-log-1/","link":"","permalink":"https://timmy6.github.io/2019/03/10/gin-log-1/","excerpt":"","text":"首先同步下项目概况： 上篇文章分享了，规划项目目录和参数验证，其中参数验证使用的是 validator.v8 版本，现已更新到 validator.v9 版本，最新代码查看 github 即可。 这篇文章咱们分享：路由中间件 - 日志记录。 日志是特别重要的一个东西，方便我们对问题进行排查，这篇文章我们实现将日志记录到文本文件中。 这是我规划的，需要记录的参数： 1234567891011121314151617- request 请求数据 - request_time - request_method - request_uri - request_proto - request_ua - request_referer - request_post_data - request_client_ip - response 返回数据 - response_time - response_code - response_msg - response_data - cost_time 花费时间 Gin 框架中自带 Logger 中间件，我们了解下框架中自带的 Logger 中间件是否满足我们的需求？ gin.Logger()我们先使用 gin.Logger() 看看效果。 在 route.go SetupRouter 方法中增加代码： 1engine.Use(gin.Logger()) 运行后多请求几次，日志输出在命令行中： 123[GIN] 2019/08/30 - 21:24:16 | 200 | 178.072µs | ::1 | GET /ping[GIN] 2019/08/30 - 21:24:27 | 200 | 367.997µs | ::1 | POST /product[GIN] 2019/08/30 - 21:24:28 | 200 | 2.521592ms | ::1 | POST /product 先解决第一个问题，怎么将日志输出到文本中？ 在 route.go SetupRouter 方法中增加代码： 123f, _ := os.Create(config.AppAccessLogName)gin.DefaultWriter = io.MultiWriter(f)engine.Use(gin.Logger()) 运行后多请求几次，日志输出在文件中： 123[GIN] 2019/08/30 - 21:36:07 | 200 | 369.023µs | ::1 | GET /ping[GIN] 2019/08/30 - 21:36:08 | 200 | 27.585µs | ::1 | GET /ping[GIN] 2019/08/30 - 21:36:10 | 200 | 14.302µs | ::1 | POST /product 虽然记录到文件成功了，但是记录的参数不是我们想要的样子。 怎么办呢？ 我们需要自定义一个日志中间件，按照我们需要的参数进行记录。 自定义 Logger()middleware&#x2F;logger&#x2F;logger.go 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788package loggerimport ( &quot;bytes&quot; &quot;encoding/json&quot; &quot;fmt&quot; &quot;github.com/gin-gonic/gin&quot; &quot;go-gin-api/app/config&quot; &quot;go-gin-api/app/util&quot; &quot;log&quot; &quot;os&quot;)type bodyLogWriter struct &#123; gin.ResponseWriter body *bytes.Buffer&#125;func (w bodyLogWriter) Write(b []byte) (int, error) &#123; w.body.Write(b) return w.ResponseWriter.Write(b)&#125;func (w bodyLogWriter) WriteString(s string) (int, error) &#123; w.body.WriteString(s) return w.ResponseWriter.WriteString(s)&#125;func SetUp() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; bodyLogWriter := &amp;bodyLogWriter&#123;body: bytes.NewBufferString(&quot;&quot;), ResponseWriter: c.Writer&#125; c.Writer = bodyLogWriter //开始时间 startTime := util.GetCurrentMilliTime() //处理请求 c.Next() responseBody := bodyLogWriter.body.String() var responseCode int var responseMsg string var responseData interface&#123;&#125; if responseBody != &quot;&quot; &#123; response := util.Response&#123;&#125; err := json.Unmarshal([]byte(responseBody), &amp;response) if err == nil &#123; responseCode = response.Code responseMsg = response.Message responseData = response.Data &#125; &#125; //结束时间 endTime := util.GetCurrentMilliTime() if c.Request.Method == &quot;POST&quot; &#123; c.Request.ParseForm() &#125; //日志格式 accessLogMap := make(map[string]interface&#123;&#125;) accessLogMap[&quot;request_time&quot;] = startTime accessLogMap[&quot;request_method&quot;] = c.Request.Method accessLogMap[&quot;request_uri&quot;] = c.Request.RequestURI accessLogMap[&quot;request_proto&quot;] = c.Request.Proto accessLogMap[&quot;request_ua&quot;] = c.Request.UserAgent() accessLogMap[&quot;request_referer&quot;] = c.Request.Referer() accessLogMap[&quot;request_post_data&quot;] = c.Request.PostForm.Encode() accessLogMap[&quot;request_client_ip&quot;] = c.ClientIP() accessLogMap[&quot;response_time&quot;] = endTime accessLogMap[&quot;response_code&quot;] = responseCode accessLogMap[&quot;response_msg&quot;] = responseMsg accessLogMap[&quot;response_data&quot;] = responseData accessLogMap[&quot;cost_time&quot;] = fmt.Sprintf(&quot;%vms&quot;, endTime - startTime) accessLogJson, _ := util.JsonEncode(accessLogMap) if f, err := os.OpenFile(config.AppAccessLogName, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0666); err != nil &#123; log.Println(err) &#125; else &#123; f.WriteString(accessLogJson + &quot;\\n&quot;) &#125; &#125;&#125; 运行后多请求几次，日志输出在文件中： 123&#123;&quot;cost_time&quot;:&quot;0ms&quot;,&quot;request_client_ip&quot;:&quot;::1&quot;,&quot;request_method&quot;:&quot;GET&quot;,&quot;request_post_data&quot;:&quot;&quot;,&quot;request_proto&quot;:&quot;HTTP/1.1&quot;,&quot;request_referer&quot;:&quot;&quot;,&quot;request_time&quot;:1567172568233,&quot;request_ua&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36&quot;,&quot;request_uri&quot;:&quot;/ping&quot;,&quot;response_code&quot;:1,&quot;response_data&quot;:null,&quot;response_msg&quot;:&quot;pong&quot;,&quot;response_time&quot;:1567172568233&#125;&#123;&quot;cost_time&quot;:&quot;0ms&quot;,&quot;request_client_ip&quot;:&quot;::1&quot;,&quot;request_method&quot;:&quot;GET&quot;,&quot;request_post_data&quot;:&quot;&quot;,&quot;request_proto&quot;:&quot;HTTP/1.1&quot;,&quot;request_referer&quot;:&quot;&quot;,&quot;request_time&quot;:1567172569158,&quot;request_ua&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36&quot;,&quot;request_uri&quot;:&quot;/ping&quot;,&quot;response_code&quot;:1,&quot;response_data&quot;:null,&quot;response_msg&quot;:&quot;pong&quot;,&quot;response_time&quot;:1567172569158&#125;&#123;&quot;cost_time&quot;:&quot;0ms&quot;,&quot;request_client_ip&quot;:&quot;::1&quot;,&quot;request_method&quot;:&quot;POST&quot;,&quot;request_post_data&quot;:&quot;name=admin&quot;,&quot;request_proto&quot;:&quot;HTTP/1.1&quot;,&quot;request_referer&quot;:&quot;&quot;,&quot;request_time&quot;:1567172629565,&quot;request_ua&quot;:&quot;PostmanRuntime/7.6.0&quot;,&quot;request_uri&quot;:&quot;/product&quot;,&quot;response_code&quot;:-1,&quot;response_data&quot;:null,&quot;response_msg&quot;:&quot;Key: &#x27;ProductAdd.Name&#x27; Error:Field validation for &#x27;Name&#x27; failed on the &#x27;NameValid&#x27; tag&quot;,&quot;response_time&quot;:1567172629565&#125; OK，咱们想要的所有参数全都记录了！ 抛出几个问题吧： 1、有没有开源的日志记录工具？ 当然有，其中 logrus 是用的最多的，这个工具功能强大。 2、为什么将日志记录到文本中？ 因为，日志平台可以使用的是 ELK。 使用 Logstash 进行收集文本文件，使用 Elasticsearch 引擎进行搜索分析，最终在 Kibana 平台展示出来。 3、当大量请求过来时，写入文件会不会出问题？ 可能会，这块可以使用异步，咱们可以用下 go 的 chan。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"gin框架","slug":"gin框架","permalink":"https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"}]},{"title":"规划项目目录和参数验证","slug":"gin-modules2","date":"2019-02-25T11:22:20.000Z","updated":"2022-05-13T07:48:43.346Z","comments":true,"path":"2019/02/25/gin-modules2/","link":"","permalink":"https://timmy6.github.io/2019/02/25/gin-modules2/","excerpt":"","text":"概述首先同步下项目概况： 上篇文章分享了，使用 go modules 初始化项目，这篇文章咱们分享： 规划目录结构 模型绑定和验证 自定义验证器 制定 API 返回结构 废话不多说，咱们开始吧。 规划目录结构12345678910111213141516171819202122232425├─ go-gin-api│ ├─ app│ ├─ config //配置文件│ ├─ config.go│ ├─ controller //控制器层│ ├─ param_bind│ ├─ param_verify│ ├─ ...│ ├─ model //数据库ORM│ ├─ proto│ ├─ ...│ ├─ repository //数据库操作层│ ├─ ...│ ├─ route //路由│ ├─ middleware│ ├─ route.go│ ├─ service //业务层│ ├─ ...│ ├─ util //工具包│ ├─ ...│ ├─ vendor //依赖包│ ├─ ...│ ├─ go.mod│ ├─ go.sum│ ├─ main.go //入口文件 上面的目录结构是我自定义的，大家也可以根据自己的习惯去定义。 controller 控制器层主要对提交过来的数据进行验证，然后将验证完成的数据传递给 service 处理。 在 gin 框架中，参数验证有两种： 1、模型绑定和验证。 2、自定义验证器。 其中目录 param_bind，存储的是参数绑定的数据，目录param_verify 存储的是自定义验证器。 接下来，让咱们进行简单实现。 模型绑定和验证比如，有一个创建商品的接口，商品名称不能为空。 配置路由(route.go)： 1234567891011121314ProductRouter := engine.Group(&quot;&quot;)&#123; // 新增产品 ProductRouter.POST(&quot;/product&quot;, product.Add) // 更新产品 ProductRouter.PUT(&quot;/product/:id&quot;, product.Edit) // 删除产品 ProductRouter.DELETE(&quot;/product/:id&quot;, product.Delete) // 获取产品详情 ProductRouter.GET(&quot;/product/:id&quot;, product.Detail)&#125; 参数绑定(param_bind&#x2F;product.go)： 123type ProductAdd struct &#123; Name string `form:&quot;name&quot; json:&quot;name&quot; binding:&quot;required&quot;`&#125; 控制器调用(controller&#x2F;product.go)： 1234if err := c.ShouldBind(&amp;param_bind.ProductAdd&#123;&#125;); err != nil &#123; utilGin.Response(-1, err.Error(), nil) return&#125; 咱们用 Postman 模拟 post 请求时，name 参数不传或传递为空，会出现： Key: ‘ProductAdd.Name’ Error:Field validation for ‘Name’ failed on the ‘required’ tag 这就使用到了参数设置的 binding:&quot;required&quot;。 那么还能使用 binding 哪些参数，有文档吗？ 有。Gin 使用 go-playground&#x2F;validator.v8 进行验证，相关文档： https://godoc.org/gopkg.in/go-playground/validator.v8 接下来，咱们实现一下自定义验证器。 自定义验证器比如，有一个创建商品的接口，商品名称不能为空并且参数名称不能等于 admin。 类似于这种业务需求，无法 binding 现成的方法，需要我们自己写验证方法，才能实现。 自定义验证方法(param_verify&#x2F;product.go) 1234567891011func NameValid ( v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value, field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string,) bool &#123; if s, ok := field.Interface().(string); ok &#123; if s == &quot;admin&quot; &#123; return false &#125; &#125; return true&#125; 参数绑定(param_bind&#x2F;product.go)： 123type ProductAdd struct &#123; Name string `form:&quot;name&quot; json:&quot;name&quot; binding:&quot;required,NameValid&quot;`&#125; 同时还要绑定验证器: 1234// 绑定验证器if v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123; v.RegisterValidation(&quot;NameValid&quot;, param_verify.NameValid)&#125; 咱们用 Postman 模拟 post 请求时，name 参数不传或传递为空，会出现： Key: ‘ProductAdd.Name’ Error:Field validation for ‘Name’ failed on the ‘required’ tag name&#x3D;admin 时： Key: ‘ProductAdd.Name’ Error:Field validation for ‘Name’ failed on the ‘NameValid’ tag OK，上面两个验证都生效了！ 上面的输出都是在控制台，能不能返回一个 Json 结构的数据呀？ 能。接下来咱们制定 API 返回结构。 制定 API 返回结构12345&#123; &quot;code&quot;: 1, &quot;msg&quot;: &quot;&quot;, &quot;data&quot;: null&#125; API 接口的返回的结构基本都是这三个字段。 比如 code&#x3D;1 表示成功，code&#x3D;-1 表示失败。 msg 表示提示信息。 data 表示要返回的数据。 那么，我们怎么在 gin 框架中实现它，其实很简单 基于 c.JSON() 方法进行封装即可，直接看代码。 12345678910111213141516171819202122package utilimport &quot;github.com/gin-gonic/gin&quot;type Gin struct &#123; Ctx *gin.Context&#125;type response struct &#123; Code int `json:&quot;code&quot;` Message string `json:&quot;msg&quot;` Data interface&#123;&#125; `json:&quot;data&quot;`&#125;func (g *Gin)Response(code int, msg string, data interface&#123;&#125;) &#123; g.Ctx.JSON(200, response&#123; Code : code, Message : msg, Data : data, &#125;) return&#125; 控制器调用(controller&#x2F;product.go)： 12345utilGin := util.Gin&#123;Ctx:c&#125;if err := c.ShouldBind(&amp;param_bind.ProductAdd&#123;&#125;); err != nil &#123; utilGin.Response(-1, err.Error(), nil) return&#125; 咱们用 Postman 模拟 post 请求时，name 参数不传或传递为空，会出现： 12345&#123; &quot;code&quot;: -1, &quot;msg&quot;: &quot;Key: &#x27;ProductAdd.Name&#x27; Error:Field validation for &#x27;Name&#x27; failed on the &#x27;required&#x27; tag&quot;, &quot;data&quot;: null&#125; name&#x3D;admin 时： 12345&#123; &quot;code&quot;: -1, &quot;msg&quot;: &quot;Key: &#x27;ProductAdd.Name&#x27; Error:Field validation for &#x27;Name&#x27; failed on the &#x27;NameValid&#x27; tag&quot;, &quot;data&quot;: null&#125; OK，上面两个验证都生效了！ 源码地址https://github.com/xinliangnote/go-gin-api go-gin-api 系列文章 1. 使用 go modules 初始化项目 备注Gin 模型验证 Validator 升级：validator.v8 升级为 validator.v9，已提交到 github !!!","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"gin框架","slug":"gin框架","permalink":"https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"}]},{"title":"使用 go modules 初始化项目","slug":"gin-modules","date":"2019-02-15T13:12:50.000Z","updated":"2022-05-13T07:42:06.370Z","comments":true,"path":"2019/02/15/gin-modules/","link":"","permalink":"https://timmy6.github.io/2019/02/15/gin-modules/","excerpt":"","text":"概述我想实现一个开箱即用的 API 框架的轮子，这个轮子是基于 Gin 基础上开发的。 为什么是开箱即用，它会集成哪些功能？ 以上功能点，都是常用的，后期可能还会增加。 废话不多说，咱们开始吧。 创建一个项目，咱们首先要考虑一个依赖包的管理工具。 常见的包管理有，dep、go vendor、glide、go modules 等。 最开始，使用过 dep，当时被朋友 diss 了，推荐我使用 go modules 。 现在来说一下 go modules ，这个是随着 Go 1.11 的发布和我们见面的，这是官方提倡的新的包管理。 说一个环境变量：GO111MODULE，默认值为 auto 。 当项目中有 go.mod 时，使用 go modules 管理，反之使用 旧的 GOPATH 和 vendor机制。 如果就想使用 go modules ，可以将 GO111MODULE 设置为 on 。 直接上手吧。 初始化咱们在 GOPATH 之外的地方，新建一个空文件夹 go-gin-api 。 1cd go-gin-api &amp;&amp; go mod init go-gin-api 输出： go: creating new go.mod: module go-gin-api 这时目录中多一个 go.mod 文件，内容如下： 123module go-gin-apigo 1.12 到这，go mod 初始化就完成，接下来添加依赖包 - gin。 添加依赖包在目录中创建一个 main.go 的文件，放上如下代码： 12345678910111213package mainimport &quot;github.com/gin-gonic/gin&quot;func main() &#123; r := gin.Default() r.GET(&quot;/ping&quot;, func(c *gin.Context) &#123; c.JSON(200, gin.H&#123; &quot;message&quot;: &quot;pong&quot;, &#125;) &#125;) r.Run() // listen and serve on 0.0.0.0:8080&#125; 这代码没什么特别的，就是官方的入门Demo。 接下来，开始下载依赖包。 1go mod tidy 执行完成后，看一下 go.mod 文件： 12345module go-gin-apigo 1.12require github.com/gin-gonic/gin v1.4.0 这时，看到新增一个 gin v1.4.0 的包。 还生成了一个 go.sum 的文件，这个文件可以暂时先不管。 这时发现了 2 个问题。 1、目录中没发现 gin 包，包下载到哪了？ 下载到了 GOPATH&#x2F;pkg&#x2F;mod 目录中。 2、GoLand 编辑器中关于 Gin 的引用变红了？ 在这里编辑器需要设置一下，如图： 点击 Apply 和 OK 即可。 如果这招不灵，还可以执行： 1go mod vendor 这个命令是将项目依赖的包，放到项目的 vendor 目录中，这肯定就可以了。 go mod 命令go mod tidy 拉取缺少的模块，移除不用的模块。 我常用这个命令。 go mod vendor 将依赖复制到vendor下。 我常用这个命令。 go mod download 下载依赖包。 go mod verify 检验依赖。 go mod graph 打印模块依赖图。 其他命令，可以执行 go mod ，查看即可。 小结这篇文章，分享了 go modules 的使用。 使用 go modules 从零搭建一个项目。 GoLand 编辑器使用 go modules。 今天就到这了，下一篇文章开始搭建 API 项目了，写参数验证。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"gin框架","slug":"gin框架","permalink":"https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"}]},{"title":"gRPC 工具","slug":"grpc-tools","date":"2019-02-10T14:22:50.000Z","updated":"2022-05-13T07:37:45.866Z","comments":true,"path":"2019/02/10/grpc-tools/","link":"","permalink":"https://timmy6.github.io/2019/02/10/grpc-tools/","excerpt":"","text":"概述当我们在写 HTTP 接口的时候，使用的是 Postman 进行接口调试，那么在写 gRPC 接口的时候，有没有类似于 Postman 的调试工具呢？ 这是有的。 咱们一起看下 grpcui，源码地址： https://github.com/fullstorydev/grpcui 看下官方描述： grpcui is a command-line tool that lets you interact with gRPC servers via a browser. It’s sort of like Postman, but for gRPC APIs instead of REST. 写一个 gRPC API端口：9901 .proto 文件： 123456789101112131415161718192021syntax = &quot;proto3&quot;; // 指定 proto 版本package listen; // 指定包名// 定义服务service Listen &#123; // 定义方法 rpc ListenData(Request) returns (Response) &#123;&#125;&#125;// Request 请求结构message Request &#123; string name = 1;&#125;// Response 响应结构message Response &#123; string message = 1;&#125; 很简单，这个大家一看就知道了。 Service name 为 listen.Listen Method name 为 ListenData 再看下 ListenData 方法： 123func (l *ListenController) ListenData(ctx context.Context, in *listen.Request) (*listen.Response, error) &#123; return &amp;listen.Response&#123;Message : fmt.Sprintf(&quot;[%s]&quot;, in.Name)&#125;, nil&#125; 这表示，将 Name 直接返回。 启动服务1cd listen &amp;&amp; go run main.go 服务启动成功后，等待使用。 grpcui 使用安装根据官方 README.md 文档安装即可。 12go get github.com/fullstorydev/grpcuigo install github.com/fullstorydev/grpcui/cmd/grpcui 这时，在 $GOPATH/bin 目录下，生成一个 grpcui 可执行文件。 执行个命令，验证下： 1grpcui -help 输出： 1234Usage: grpcui [flags] [address] ...... 表示安装成功了。 运行123grpcui -plaintext 127.0.0.1:9901Failed to compute set of methods to expose: server does not support the reflection API 这种情况下，加个反射就可以了，在 listen 的 main.go 新增如下代码即可： 1reflection.Register(s) 在运行一次试试： 12grpcui -plaintext 127.0.0.1:9901gRPC Web UI available at http://127.0.0.1:63027/ 在浏览器中访问：http://127.0.0.1:63027/ 到这，我们看到 Service name、Method name 都出来了，传输参数直接在页面上进行操作即可。 当发起 Request “Tom”，也能获得 Response “Tom”。 当然，如果这个服务下面有多个 Service name，多个 Method name 也都会显示出来的，去试试吧。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"gRPC","slug":"gRPC","permalink":"https://timmy6.github.io/tags/gRPC/"}]},{"title":"gRPC Hello World","slug":"grpc-hello","date":"2019-01-25T13:22:50.000Z","updated":"2022-05-13T07:26:13.715Z","comments":true,"path":"2019/01/25/grpc-hello/","link":"","permalink":"https://timmy6.github.io/2019/01/25/grpc-hello/","excerpt":"","text":"概述开始 gRPC 了，这篇文章学习使用 gRPC，输出一个 Hello World。 用 Go 实现 gRPC 的服务端。 用 Go 实现 gRPC 的客户端。 gRPC 支持 4 类服务方法，咱们这次实现 单项 RPC 和 服务端流式 RPC。 四类服务方法单项 RPC 服务端发送一个请求给服务端，从服务端获取一个应答，就像一次普通的函数调用。 1rpc SayHello(HelloRequest) returns (HelloResponse)&#123;&#125; 服务端流式 RPC 客户端发送一个请求给服务端，可获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止。 1rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse)&#123;&#125; 客户端流式 RPC 客户端用提供的一个数据流写入并发送一系列消息给服务端。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答。 1rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse) &#123;&#125; 双向流式 RPC 两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务端能按其希望的任意顺序读写，例如：服务端可以在写应答前等待所有的客户端消息，或者它可以先读一个消息再写一个消息，或者是读写相结合的其他方式。每个数据流里消息的顺序会被保持。 1rpc BidiHello(stream HelloRequest) returns (stream HelloResponse)&#123;&#125; 安装安装 protobuf 编译器 1brew install protobuf 验证： 123protoc --version//输出：libprotoc 3.7.1 安装 Go protobuf 插件 123go get -u github.com/golang/protobuf/protogo get -u github.com/golang/protobuf/protoc-gen-go 安装 grpc-go 1go get -u google.golang.org/grpc 写个 Hello World 服务 编写服务端 .proto 文件 生成服务端 .pb.go 文件并同步给客户端 编写服务端提供接口的代码 编写客户端调用接口的代码 目录结构 123456789101112131415├─ hello -- 代码根目录│ ├─ go_client│ ├── main.go│ ├── proto│ ├── hello│ ├── hello.pb.go│ ├─ go_server│ ├── main.go│ ├── controller│ ├── hello_controller│ ├── hello_server.go│ ├── proto│ ├── hello│ ├── hello.pb.go│ ├── hello.proto 这样创建目录是为了 go_client 和 go_server 后期可以拆成两个项目。 编写服务端 hello.proto 文件 123456789101112131415161718192021222324syntax = &quot;proto3&quot;; // 指定 proto 版本package hello; // 指定包名// 定义 Hello 服务service Hello &#123; // 定义 SayHello 方法 rpc SayHello(HelloRequest) returns (HelloResponse) &#123;&#125; // 定义 LotsOfReplies 方法 rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse)&#123;&#125;&#125;// HelloRequest 请求结构message HelloRequest &#123; string name = 1;&#125;// HelloResponse 响应结构message HelloResponse &#123; string message = 1;&#125; 了解更多 Protobuf 语法，请查看： https://developers.google.com/protocol-buffers/ 生成服务端 .pb.go 1protoc -I . --go_out=plugins=grpc:. ./hello.proto 同时将生成的 hello.pb.go 复制到客户端一份。 查看更多命令参数，执行 protoc，查看 OPTION 。 编写服务端提供接口的代码 123456789101112131415161718192021// hello_server.gopackage hello_controllerimport ( &quot;fmt&quot; &quot;golang.org/x/net/context&quot; &quot;hello/go_server/proto/hello&quot;)type HelloController struct&#123;&#125;func (h *HelloController) SayHello(ctx context.Context, in *hello.HelloRequest) (*hello.HelloResponse, error) &#123; return &amp;hello.HelloResponse&#123;Message : fmt.Sprintf(&quot;%s&quot;, in.Name)&#125;, nil&#125;func (h *HelloController) LotsOfReplies(in *hello.HelloRequest, stream hello.Hello_LotsOfRepliesServer) error &#123; for i := 0; i &lt; 10; i++ &#123; stream.Send(&amp;hello.HelloResponse&#123;Message : fmt.Sprintf(&quot;%s %s %d&quot;, in.Name, &quot;Reply&quot;, i)&#125;) &#125; return nil&#125; 1234567891011121314151617181920212223242526272829303132// main.gopackage mainimport ( &quot;log&quot; &quot;net&quot; &quot;hello/go_server/proto/hello&quot; &quot;hello/go_server/controller/hello_controller&quot; &quot;google.golang.org/grpc&quot;)const ( Address = &quot;0.0.0.0:9090&quot;)func main() &#123; listen, err := net.Listen(&quot;tcp&quot;, Address) if err != nil &#123; log.Fatalf(&quot;Failed to listen: %v&quot;, err) &#125; s := grpc.NewServer() // 服务注册 hello.RegisterHelloServer(s, &amp;hello_controller.HelloController&#123;&#125;) log.Println(&quot;Listen on &quot; + Address) if err := s.Serve(listen); err != nil &#123; log.Fatalf(&quot;Failed to serve: %v&quot;, err) &#125;&#125; 运行： 123go run main.go2019/07/28 17:51:20 Listen on 0.0.0.0:9090 编写客户端请求接口的代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package mainimport ( &quot;hello/go_client/proto/hello&quot; &quot;io&quot; &quot;log&quot; &quot;golang.org/x/net/context&quot; &quot;google.golang.org/grpc&quot;)const ( // gRPC 服务地址 Address = &quot;0.0.0.0:9090&quot;)func main() &#123; conn, err := grpc.Dial(Address, grpc.WithInsecure()) if err != nil &#123; log.Fatalln(err) &#125; defer conn.Close() // 初始化客户端 c := hello.NewHelloClient(conn) // 调用 SayHello 方法 res, err := c.SayHello(context.Background(), &amp;hello.HelloRequest&#123;Name: &quot;Hello World&quot;&#125;) if err != nil &#123; log.Fatalln(err) &#125; log.Println(res.Message) // 调用 LotsOfReplies 方法 stream, err := c.LotsOfReplies(context.Background(),&amp;hello.HelloRequest&#123;Name: &quot;Hello World&quot;&#125;) if err != nil &#123; log.Fatalln(err) &#125; for &#123; res, err := stream.Recv() if err == io.EOF &#123; break &#125; if err != nil &#123; log.Printf(&quot;stream.Recv: %v&quot;, err) &#125; log.Printf(&quot;%s&quot;, res.Message) &#125;&#125; 运行： 12345678910111213go run main.go2019/07/28 17:58:13 Hello World2019/07/28 17:58:13 Hello World Reply 02019/07/28 17:58:13 Hello World Reply 12019/07/28 17:58:13 Hello World Reply 22019/07/28 17:58:13 Hello World Reply 32019/07/28 17:58:13 Hello World Reply 42019/07/28 17:58:13 Hello World Reply 52019/07/28 17:58:13 Hello World Reply 62019/07/28 17:58:13 Hello World Reply 72019/07/28 17:58:13 Hello World Reply 82019/07/28 17:58:13 Hello World Reply 9","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"gRPC","slug":"gRPC","permalink":"https://timmy6.github.io/tags/gRPC/"}]},{"title":"统一定义API错误码","slug":"error-code","date":"2019-01-15T13:22:50.000Z","updated":"2022-05-13T07:22:22.732Z","comments":true,"path":"2019/01/15/error-code/","link":"","permalink":"https://timmy6.github.io/2019/01/15/error-code/","excerpt":"","text":"改之前在使用 gin 开发接口的时候，返回接口数据是这样写的。 123456789101112type response struct &#123; Code int `json:&quot;code&quot;` Msg string `json:&quot;msg&quot;` Data interface&#123;&#125; `json:&quot;data&quot;`&#125;// always return http.StatusOKc.JSON(http.StatusOK, response&#123; Code: 20101, Msg: &quot;用户手机号不合法&quot;, Data: nil,&#125;) 这种写法 code、msg 都是在哪需要返回在哪定义，没有进行统一管理。 改之后12345// 比如，返回“用户手机号不合法”错误c.JSON(http.StatusOK, errno.ErrUserPhone.WithID(c.GetString(&quot;trace-id&quot;)))// 正确返回c.JSON(http.StatusOK, errno.OK.WithData(data).WithID(c.GetString(&quot;trace-id&quot;))) errno.ErrUserPhone、errno.OK 表示自定义的错误码，下面会看到定义的地方。 .WithID() 设置当前请求的唯一ID，也可以理解为链路ID，忽略也可以。 .WithData() 设置成功时返回的数据。 下面分享下编写的 errno 包源码，非常简单，希望大家不要介意。 errno 包源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// errno/errno.gopackage errnoimport ( &quot;encoding/json&quot;)var _ Error = (*err)(nil)type Error interface &#123; // i 为了避免被其他包实现 i() // WithData 设置成功时返回的数据 WithData(data interface&#123;&#125;) Error // WithID 设置当前请求的唯一ID WithID(id string) Error // ToString 返回 JSON 格式的错误详情 ToString() string&#125;type err struct &#123; Code int `json:&quot;code&quot;` // 业务编码 Msg string `json:&quot;msg&quot;` // 错误描述 Data interface&#123;&#125; `json:&quot;data&quot;` // 成功时返回的数据 ID string `json:&quot;id,omitempty&quot;` // 当前请求的唯一ID，便于问题定位，忽略也可以&#125;func NewError(code int, msg string) Error &#123; return &amp;err&#123; Code: code, Msg: msg, Data: nil, &#125;&#125;func (e *err) i() &#123;&#125;func (e *err) WithData(data interface&#123;&#125;) Error &#123; e.Data = data return e&#125;func (e *err) WithID(id string) Error &#123; e.ID = id return e&#125;// ToString 返回 JSON 格式的错误详情func (e *err) ToString() string &#123; err := &amp;struct &#123; Code int `json:&quot;code&quot;` Msg string `json:&quot;msg&quot;` Data interface&#123;&#125; `json:&quot;data&quot;` ID string `json:&quot;id,omitempty&quot;` &#125;&#123; Code: e.Code, Msg: e.Msg, Data: e.Data, ID: e.ID, &#125; raw, _ := json.Marshal(err) return string(raw)&#125; 12345678910111213141516171819// errno/code.gopackage errnovar ( // OK OK = NewError(0, &quot;OK&quot;) // 服务级错误码 ErrServer = NewError(10001, &quot;服务异常，请联系管理员&quot;) ErrParam = NewError(10002, &quot;参数有误&quot;) ErrSignParam = NewError(10003, &quot;签名参数有误&quot;) // 模块级错误码 - 用户模块 ErrUserPhone = NewError(20101, &quot;用户手机号不合法&quot;) ErrUserCaptcha = NewError(20102, &quot;用户验证码有误&quot;) // ...) 错误码规则 错误码需在 code.go 文件中定义。 错误码需为 &gt; 0 的数，反之表示正确。 错误码为 5 位数 1 01 01 服务级错误码 模块级错误码 具体错误码 服务级别错误码：1 位数进行表示，比如 1 为系统级错误；2 为普通错误，通常是由用户非法操作引起。 模块级错误码：2 位数进行表示，比如 01 为用户模块；02 为订单模块。 具体错误码：2 位数进行表示，比如 01 为手机号不合法；02 为验证码输入错误。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"gin框架","slug":"gin框架","permalink":"https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"}]},{"title":"自定义错误处理","slug":"custom-err","date":"2019-01-10T13:22:50.000Z","updated":"2022-05-13T07:16:06.972Z","comments":true,"path":"2019/01/10/custom-err/","link":"","permalink":"https://timmy6.github.io/2019/01/10/custom-err/","excerpt":"","text":"概述开始今天的文章，为什么要自定义错误处理？默认的错误处理方式是什么？ 那好，咱们就先说下默认的错误处理。 默认的错误处理是 errors.New(&quot;错误信息&quot;)，这个信息通过 error 类型的返回值进行返回。 举个简单的例子： 12345678func hello(name string) (str string, err error) &#123; if name == &quot;&quot; &#123; err = errors.New(&quot;name 不能为空&quot;) return &#125; str = fmt.Sprintf(&quot;hello: %s&quot;, name) return&#125; 当调用这个方法时： 123456var name = &quot;&quot;str, err := hello(name)if err != nil &#123; fmt.Println(err.Error()) return&#125; 这就是默认的错误处理，下面还会用这个例子进行说。 这个默认的错误处理，只是得到了一个错误信息的字符串。 然而… 我还想得到发生错误时的 时间、文件名、方法名、行号 等信息。 我还想得到错误时进行告警，比如 短信告警、邮件告警、微信告警 等。 我还想调用的时候，不那么复杂，就和默认错误处理类似，比如： 12alarm.WeChat(&quot;错误信息&quot;)return 这样，我们就得到了我们想要的信息（时间、文件名、方法名、行号），并通过 微信 的方式进行告警通知我们。 同理，alarm.Email(&quot;错误信息&quot;)、alarm.Sms(&quot;错误信息&quot;) 我们得到的信息是一样的，只是告警方式不同而已。 还要保证，我们业务逻辑中，获取错误的时候，只获取错误信息即可。 上面这些想出来的，就是今天要实现的，自定义错误处理，我们就实现之前，先说下 Go 的错误处理。 错误处理12345678910111213141516171819202122232425262728package mainimport ( &quot;errors&quot; &quot;fmt&quot;)func hello(name string) (str string, err error) &#123; if name == &quot;&quot; &#123; err = errors.New(&quot;name 不能为空&quot;) return &#125; str = fmt.Sprintf(&quot;hello: %s&quot;, name) return&#125;func main() &#123; var name = &quot;&quot; fmt.Println(&quot;param:&quot;, name) str, err := hello(name) if err != nil &#123; fmt.Println(err.Error()) return &#125; fmt.Println(str)&#125; 输出： 12param: Tomhello: Tom 当 name &#x3D; “” 时，输出： 12param:name 不能为空 建议每个函数都要有错误处理，error 应该为最后一个返回值。 咱们一起看下官方 errors.go 1234567891011121314151617181920// Copyright 2011 The Go Authors. All rights reserved.// Use of this source code is governed by a BSD-style// license that can be found in the LICENSE file.// Package errors implements functions to manipulate errors.package errors// New returns an error that formats as the given text.func New(text string) error &#123; return &amp;errorString&#123;text&#125;&#125;// errorString is a trivial implementation of error.type errorString struct &#123; s string&#125;func (e *errorString) Error() string &#123; return e.s&#125; 上面的代码，并不复杂，参照上面的，咱们进行写一个自定义错误处理。 自定义错误处理咱们定义一个 alarm.go，用于处理告警。 废话不多说，直接看代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798package alarmimport ( &quot;encoding/json&quot; &quot;fmt&quot; &quot;ginDemo/common/function&quot; &quot;path/filepath&quot; &quot;runtime&quot; &quot;strings&quot;)type errorString struct &#123; s string&#125;type errorInfo struct &#123; Time string `json:&quot;time&quot;` Alarm string `json:&quot;alarm&quot;` Message string `json:&quot;message&quot;` Filename string `json:&quot;filename&quot;` Line int `json:&quot;line&quot;` Funcname string `json:&quot;funcname&quot;`&#125;func (e *errorString) Error() string &#123; return e.s&#125;func New (text string) error &#123; alarm(&quot;INFO&quot;, text) return &amp;errorString&#123;text&#125;&#125;// 发邮件func Email (text string) error &#123; alarm(&quot;EMAIL&quot;, text) return &amp;errorString&#123;text&#125;&#125;// 发短信func Sms (text string) error &#123; alarm(&quot;SMS&quot;, text) return &amp;errorString&#123;text&#125;&#125;// 发微信func WeChat (text string) error &#123; alarm(&quot;WX&quot;, text) return &amp;errorString&#123;text&#125;&#125;// 告警方法func alarm(level string, str string) &#123; // 当前时间 currentTime := function.GetTimeStr() // 定义 文件名、行号、方法名 fileName, line, functionName := &quot;?&quot;, 0 , &quot;?&quot; pc, fileName, line, ok := runtime.Caller(2) if ok &#123; functionName = runtime.FuncForPC(pc).Name() functionName = filepath.Ext(functionName) functionName = strings.TrimPrefix(functionName, &quot;.&quot;) &#125; var msg = errorInfo &#123; Time : currentTime, Alarm : level, Message : str, Filename : fileName, Line : line, Funcname : functionName, &#125; jsons, errs := json.Marshal(msg) if errs != nil &#123; fmt.Println(&quot;json marshal error:&quot;, errs) &#125; errorJsonInfo := string(jsons) fmt.Println(errorJsonInfo) if level == &quot;EMAIL&quot; &#123; // 执行发邮件 &#125; else if level == &quot;SMS&quot; &#123; // 执行发短信 &#125; else if level == &quot;WX&quot; &#123; // 执行发微信 &#125; else if level == &quot;INFO&quot; &#123; // 执行记日志 &#125;&#125; 看下如何调用： 1234567891011121314151617181920212223242526272829303132333435363738package v1import ( &quot;fmt&quot; &quot;ginDemo/common/alarm&quot; &quot;ginDemo/entity&quot; &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)func AddProduct(c *gin.Context) &#123; // 获取 Get 参数 name := c.Query(&quot;name&quot;) var res = entity.Result&#123;&#125; str, err := hello(name) if err != nil &#123; res.SetCode(entity.CODE_ERROR) res.SetMessage(err.Error()) c.JSON(http.StatusOK, res) c.Abort() return &#125; res.SetCode(entity.CODE_SUCCESS) res.SetMessage(str) c.JSON(http.StatusOK, res)&#125;func hello(name string) (str string, err error) &#123; if name == &quot;&quot; &#123; err = alarm.WeChat(&quot;name 不能为空&quot;) return &#125; str = fmt.Sprintf(&quot;hello: %s&quot;, name) return&#125; 访问：http://localhost:8080/v1/product/add?name=a 12345&#123; &quot;code&quot;: 1, &quot;msg&quot;: &quot;hello: a&quot;, &quot;data&quot;: null&#125; 未抛出错误，不会输出信息。 访问：http://localhost:8080/v1/product/add 12345&#123; &quot;code&quot;: -1, &quot;msg&quot;: &quot;name 不能为空&quot;, &quot;data&quot;: null&#125; 抛出了错误，输出信息如下： 1&#123;&quot;time&quot;:&quot;2019-07-23 22:19:17&quot;,&quot;alarm&quot;:&quot;WX&quot;,&quot;message&quot;:&quot;name 不能为空&quot;,&quot;filename&quot;:&quot;绝对路径/ginDemo/router/v1/product.go&quot;,&quot;line&quot;:33,&quot;funcname&quot;:&quot;hello&quot;&#125; 这只是个例子，大家可以在一些复杂的业务逻辑判断场景中使用自定义错误处理”。 到这里，报错时我们收到了 时间、错误信息、文件名、行号、方法名 了。 调用起来，也比较简单。 虽然标记了告警方式，还是没有进行告警通知呀。 我想说，在这里存储数据到队列中，再执行异步任务具体去消耗，这块就不实现了，大家可以去完善。 读取 文件名、方法名、行号 使用的是 runtime.Caller()。 我们还知道，Go 有 panic 和 recover，它们是干什么的呢，接下来咱们就说说。 panic 和 recover当程序不能继续运行的时候，才应该使用 panic 抛出错误。 当程序发生 panic 后，在 defer(延迟函数) 内部可以调用 recover 进行控制，不过有个前提条件，只有在相同的 Go 协程中才可以。 panic 分两个，一种是有意抛出的，一种是无意的写程序马虎造成的，咱们一个个说。 有意抛出的 panic： 12345678910111213141516171819package mainimport ( &quot;fmt&quot;)func main() &#123; fmt.Println(&quot;-- 1 --&quot;) defer func() &#123; if r := recover(); r != nil &#123; fmt.Printf(&quot;panic: %s\\n&quot;, r) &#125; fmt.Println(&quot;-- 2 --&quot;) &#125;() panic(&quot;i am panic&quot;)&#125; 输出： 123-- 1 --panic: i am panic-- 2 -- 无意抛出的 panic： 12345678910111213141516171819202122package mainimport ( &quot;fmt&quot;)func main() &#123; fmt.Println(&quot;-- 1 --&quot;) defer func() &#123; if r := recover(); r != nil &#123; fmt.Printf(&quot;panic: %s\\n&quot;, r) &#125; fmt.Println(&quot;-- 2 --&quot;) &#125;() var slice = [] int &#123;1, 2, 3, 4, 5&#125; slice[6] = 6&#125; 输出： 123-- 1 --panic: runtime error: index out of range-- 2 -- 上面的两个我们都通过 recover 捕获到了，那我们如何在 Gin 框架中使用呢？如果收到 panic 时，也想进行告警怎么实现呢？ 既然想实现告警，先在 ararm.go 中定义一个 Panic() 方法，当项目发生 panic 异常时，调用这个方法，这样就实现告警了。 12345// Panic 异常func Panic (text string) error &#123; alarm(&quot;PANIC&quot;, text) return &amp;errorString&#123;text&#125;&#125; 那我们怎么捕获到呢？ 使用中间件进行捕获，写一个 recover 中间件。 123456789101112131415161718package recoverimport ( &quot;fmt&quot; &quot;ginDemo/common/alarm&quot; &quot;github.com/gin-gonic/gin&quot;)func Recover() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; defer func() &#123; if r := recover(); r != nil &#123; alarm.Panic(fmt.Sprintf(&quot;%s&quot;, r)) &#125; &#125;() c.Next() &#125;&#125; 路由调用中间件： 123r.Use(logger.LoggerToFile(), recover.Recover())//Use 可以传递多个中间件。 验证下吧，咱们先抛出两个异常，看看能否捕获到？ 还是修改 product.go 这个文件吧。 有意抛出 panic： 1234567891011121314151617181920212223242526272829303132333435363738package v1import ( &quot;fmt&quot; &quot;ginDemo/entity&quot; &quot;github.com/gin-gonic/gin&quot; &quot;net/http&quot;)func AddProduct(c *gin.Context) &#123; // 获取 Get 参数 name := c.Query(&quot;name&quot;) var res = entity.Result&#123;&#125; str, err := hello(name) if err != nil &#123; res.SetCode(entity.CODE_ERROR) res.SetMessage(err.Error()) c.JSON(http.StatusOK, res) c.Abort() return &#125; res.SetCode(entity.CODE_SUCCESS) res.SetMessage(str) c.JSON(http.StatusOK, res)&#125;func hello(name string) (str string, err error) &#123; if name == &quot;&quot; &#123; // 有意抛出 panic panic(&quot;i am panic&quot;) return &#125; str = fmt.Sprintf(&quot;hello: %s&quot;, name) return&#125; 访问：http://localhost:8080/v1/product/add 界面是空白的。 抛出了异常，输出信息如下： 1&#123;&quot;time&quot;:&quot;2019-07-23 22:42:37&quot;,&quot;alarm&quot;:&quot;PANIC&quot;,&quot;message&quot;:&quot;i am panic&quot;,&quot;filename&quot;:&quot;绝对路径/ginDemo/middleware/recover/recover.go&quot;,&quot;line&quot;:13,&quot;funcname&quot;:&quot;1&quot;&#125; 很显然，定位的文件名、方法名、行号不是我们想要的。 需要调整 runtime.Caller(2)，这个代码在 alarm.go 的 alarm 方法中。 将 2 调整成 4 ，看下输出信息： 1&#123;&quot;time&quot;:&quot;2019-07-23 22:45:24&quot;,&quot;alarm&quot;:&quot;PANIC&quot;,&quot;message&quot;:&quot;i am panic&quot;,&quot;filename&quot;:&quot;绝对路径/ginDemo/router/v1/product.go&quot;,&quot;line&quot;:33,&quot;funcname&quot;:&quot;hello&quot;&#125; 这就对了。 无意抛出 panic： 123456789101112// 上面代码不变func hello(name string) (str string, err error) &#123; if name == &quot;&quot; &#123; // 无意抛出 panic var slice = [] int &#123;1, 2, 3, 4, 5&#125; slice[6] = 6 return &#125; str = fmt.Sprintf(&quot;hello: %s&quot;, name) return&#125; 访问：http://localhost:8080/v1/product/add 界面是空白的。 抛出了异常，输出信息如下： 1&#123;&quot;time&quot;:&quot;2019-07-23 22:50:06&quot;,&quot;alarm&quot;:&quot;PANIC&quot;,&quot;message&quot;:&quot;runtime error: index out of range&quot;,&quot;filename&quot;:&quot;绝对路径/runtime/panic.go&quot;,&quot;line&quot;:44,&quot;funcname&quot;:&quot;panicindex&quot;&#125; 很显然，定位的文件名、方法名、行号也不是我们想要的。 将 4 调整成 5 ，看下输出信息： 1&#123;&quot;time&quot;:&quot;2019-07-23 22:55:27&quot;,&quot;alarm&quot;:&quot;PANIC&quot;,&quot;message&quot;:&quot;runtime error: index out of range&quot;,&quot;filename&quot;:&quot;绝对路径/ginDemo/router/v1/product.go&quot;,&quot;line&quot;:34,&quot;funcname&quot;:&quot;hello&quot;&#125; 这就对了。 奇怪了，这是为什么？ 在这里，有必要说下 runtime.Caller(skip) 了。 skip 指的调用的深度。 为 0 时，打印当前调用文件及行数。 为 1 时，打印上级调用的文件及行数。 依次类推… 在这块，调用的时候需要注意下，我现在还没有好的解决方案。 我是将 skip（调用深度），当一个参数传递进去。 比如： 1234567891011// 发微信func WeChat (text string) error &#123; alarm(&quot;WX&quot;, text, 2) return &amp;errorString&#123;text&#125;&#125;// Panic 异常func Panic (text string) error &#123; alarm(&quot;PANIC&quot;, text, 5) return &amp;errorString&#123;text&#125;&#125; 具体的代码就不贴了。 但是，有意抛出 Panic 和 无意抛出 Panic 的调用深度又不同，怎么办？ 1、尽量将有意抛出的 Panic 改成抛出错误的方式。 2、想其他办法搞定它。 就到这吧。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"gin框架","slug":"gin框架","permalink":"https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"}]},{"title":"gin日志记录","slug":"gin-log","date":"2019-01-05T13:22:50.000Z","updated":"2022-05-11T09:47:16.798Z","comments":true,"path":"2019/01/05/gin-log/","link":"","permalink":"https://timmy6.github.io/2019/01/05/gin-log/","excerpt":"","text":"概述上篇文章分享了 Gin 框架的路由配置，这篇文章分享日志记录。 查了很多资料，Go 的日志记录用的最多的还是 github.com/sirupsen/logrus。 Logrus is a structured logger for Go (golang), completely API compatible with the standard library logger. Gin 框架的日志默认只会在控制台输出，咱们利用 Logrus 封装一个中间件，将日志记录到文件中。 这篇文章就是学习和使用 Logrus 。 日志格式比如，我们约定日志格式为 Text，包含字段如下： 请求时间、日志级别、状态码、执行时间、请求IP、请求方式、请求路由。 接下来，咱们利用 Logrus 实现它。 Logrus 使用用 dep 方式进行安装。 在 Gopkg.toml 文件新增： 123[[constraint]] name = &quot;github.com/sirupsen/logrus&quot; version = &quot;1.4.2&quot; 在项目中导入： 1import &quot;github.com/sirupsen/logrus&quot; 在项目命令行执行： 1dep ensure 这时，在 vendor/github.com/ 目录中就会看到 sirupsen 目录。 准备上手用了，上手之前咱们先规划一下，将这个功能设置成一个中间件，比如：logger.go。 日志可以记录到 File 中，定义一个 LoggerToFile 方法。 日志可以记录到 MongoDB 中，定义一个 LoggerToMongo 方法。 日志可以记录到 ES 中，定义一个 LoggerToES 方法。 日志可以记录到 MQ 中，定义一个 LoggerToMQ 方法。 … 这次咱们先实现记录到文件， 实现 LoggerToFile 方法，其他的可以根据自己的需求进行实现。 这个 logger 中间件，创建好了，可以任意在其他项目中进行迁移使用。 废话不多说，直接看代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495package middlewareimport ( &quot;fmt&quot; &quot;ginDemo/config&quot; &quot;github.com/gin-gonic/gin&quot; &quot;github.com/sirupsen/logrus&quot; &quot;os&quot; &quot;path&quot; &quot;time&quot;)// 日志记录到文件func LoggerToFile() gin.HandlerFunc &#123; logFilePath := config.Log_FILE_PATH logFileName := config.LOG_FILE_NAME //日志文件 fileName := path.Join(logFilePath, logFileName) //写入文件 src, err := os.OpenFile(fileName, os.O_APPEND|os.O_WRONLY, os.ModeAppend) if err != nil &#123; fmt.Println(&quot;err&quot;, err) &#125; //实例化 logger := logrus.New() //设置输出 logger.Out = src //设置日志级别 logger.SetLevel(logrus.DebugLevel) //设置日志格式 logger.SetFormatter(&amp;logrus.TextFormatter&#123;&#125;) return func(c *gin.Context) &#123; // 开始时间 startTime := time.Now() // 处理请求 c.Next() // 结束时间 endTime := time.Now() // 执行时间 latencyTime := endTime.Sub(startTime) // 请求方式 reqMethod := c.Request.Method // 请求路由 reqUri := c.Request.RequestURI // 状态码 statusCode := c.Writer.Status() // 请求IP clientIP := c.ClientIP() // 日志格式 logger.Infof(&quot;| %3d | %13v | %15s | %s | %s |&quot;, statusCode, latencyTime, clientIP, reqMethod, reqUri, ) &#125;&#125;// 日志记录到 MongoDBfunc LoggerToMongo() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; &#125;&#125;// 日志记录到 ESfunc LoggerToES() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; &#125;&#125;// 日志记录到 MQfunc LoggerToMQ() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; &#125;&#125; 日志中间件写好了，怎么调用呢？ 只需在 main.go 中新增： 12engine := gin.Default() //在这行后新增engine.Use(middleware.LoggerToFile()) 运行一下，看看日志： 12time=&quot;2019-07-17T22:10:45+08:00&quot; level=info msg=&quot;| 200 | 27.698µs | ::1 | GET | /v1/product/add?name=a&amp;price=10 |&quot;time=&quot;2019-07-17T22:10:46+08:00&quot; level=info msg=&quot;| 200 | 27.239µs | ::1 | GET | /v1/product/add?name=a&amp;price=10 |&quot; 这个 time=&quot;2019-07-17T22:10:45+08:00&quot; ，这个时间格式不是咱们想要的，怎么办？ 时间需要格式化一下，修改 logger.SetFormatter 1234//设置日志格式logger.SetFormatter(&amp;logrus.TextFormatter&#123; TimestampFormat:&quot;2006-01-02 15:04:05&quot;,&#125;) 执行以下，再看日志： 12time=&quot;2019-07-17 22:15:57&quot; level=info msg=&quot;| 200 | 185.027µs | ::1 | GET | /v1/product/add?name=a&amp;price=10 |&quot;time=&quot;2019-07-17 22:15:58&quot; level=info msg=&quot;| 200 | 56.989µs | ::1 | GET | /v1/product/add?name=a&amp;price=10 |&quot; 时间变得正常了。 我不喜欢文本格式，喜欢 JSON 格式，怎么办？ 1234//设置日志格式logger.SetFormatter(&amp;logrus.JSONFormatter&#123; TimestampFormat:&quot;2006-01-02 15:04:05&quot;,&#125;) 执行以下，再看日志： 12&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;| 200 | 24.78µs | ::1 | GET | /v1/product/add?name=a\\u0026price=10 |&quot;,&quot;time&quot;:&quot;2019-07-17 22:23:55&quot;&#125;&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;| 200 | 26.946µs | ::1 | GET | /v1/product/add?name=a\\u0026price=10 |&quot;,&quot;time&quot;:&quot;2019-07-17 22:23:56&quot;&#125; msg 信息太多，不方便看，怎么办？ 12345678// 日志格式logger.WithFields(logrus.Fields&#123; &quot;status_code&quot; : statusCode, &quot;latency_time&quot; : latencyTime, &quot;client_ip&quot; : clientIP, &quot;req_method&quot; : reqMethod, &quot;req_uri&quot; : reqUri,&#125;).Info() 执行以下，再看日志： 12&#123;&quot;client_ip&quot;:&quot;::1&quot;,&quot;latency_time&quot;:26681,&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;&quot;,&quot;req_method&quot;:&quot;GET&quot;,&quot;req_uri&quot;:&quot;/v1/product/add?name=a\\u0026price=10&quot;,&quot;status_code&quot;:200,&quot;time&quot;:&quot;2019-07-17 22:37:54&quot;&#125;&#123;&quot;client_ip&quot;:&quot;::1&quot;,&quot;latency_time&quot;:24315,&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;&quot;,&quot;req_method&quot;:&quot;GET&quot;,&quot;req_uri&quot;:&quot;/v1/product/add?name=a\\u0026price=10&quot;,&quot;status_code&quot;:200,&quot;time&quot;:&quot;2019-07-17 22:37:55&quot;&#125; 说明一下：time、msg、level 这些参数是 logrus 自动加上的。 logrus 支持输出文件名和行号吗？ 不支持，作者的回复是太耗性能。 不过网上也有人通过 Hook 的方式实现了，选择在生产环境使用的时候，记得做性能测试。 logrus 支持日志分割吗？ 不支持，但有办法实现它。 1、可以利用 Linux logrotate，统一由运维进行处理。 2、可以利用 file-rotatelogs 实现。 需要导入包： github.com/lestrrat-go/file-rotatelogs github.com/rifflock/lfshook 奉上完整代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125package middlewareimport ( &quot;fmt&quot; &quot;ginDemo/config&quot; &quot;github.com/gin-gonic/gin&quot; rotatelogs &quot;github.com/lestrrat-go/file-rotatelogs&quot; &quot;github.com/rifflock/lfshook&quot; &quot;github.com/sirupsen/logrus&quot; &quot;os&quot; &quot;path&quot; &quot;time&quot;)// 日志记录到文件func LoggerToFile() gin.HandlerFunc &#123; logFilePath := config.Log_FILE_PATH logFileName := config.LOG_FILE_NAME // 日志文件 fileName := path.Join(logFilePath, logFileName) // 写入文件 src, err := os.OpenFile(fileName, os.O_APPEND|os.O_WRONLY, os.ModeAppend) if err != nil &#123; fmt.Println(&quot;err&quot;, err) &#125; // 实例化 logger := logrus.New() // 设置输出 logger.Out = src // 设置日志级别 logger.SetLevel(logrus.DebugLevel) // 设置 rotatelogs logWriter, err := rotatelogs.New( // 分割后的文件名称 fileName + &quot;.%Y%m%d.log&quot;, // 生成软链，指向最新日志文件 rotatelogs.WithLinkName(fileName), // 设置最大保存时间(7天) rotatelogs.WithMaxAge(7*24*time.Hour), // 设置日志切割时间间隔(1天) rotatelogs.WithRotationTime(24*time.Hour), ) writeMap := lfshook.WriterMap&#123; logrus.InfoLevel: logWriter, logrus.FatalLevel: logWriter, logrus.DebugLevel: logWriter, logrus.WarnLevel: logWriter, logrus.ErrorLevel: logWriter, logrus.PanicLevel: logWriter, &#125; lfHook := lfshook.NewHook(writeMap, &amp;logrus.JSONFormatter&#123; TimestampFormat:&quot;2006-01-02 15:04:05&quot;, &#125;) // 新增 Hook logger.AddHook(lfHook) return func(c *gin.Context) &#123; // 开始时间 startTime := time.Now() // 处理请求 c.Next() // 结束时间 endTime := time.Now() // 执行时间 latencyTime := endTime.Sub(startTime) // 请求方式 reqMethod := c.Request.Method // 请求路由 reqUri := c.Request.RequestURI // 状态码 statusCode := c.Writer.Status() // 请求IP clientIP := c.ClientIP() // 日志格式 logger.WithFields(logrus.Fields&#123; &quot;status_code&quot; : statusCode, &quot;latency_time&quot; : latencyTime, &quot;client_ip&quot; : clientIP, &quot;req_method&quot; : reqMethod, &quot;req_uri&quot; : reqUri, &#125;).Info() &#125;&#125;// 日志记录到 MongoDBfunc LoggerToMongo() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; &#125;&#125;// 日志记录到 ESfunc LoggerToES() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; &#125;&#125;// 日志记录到 MQfunc LoggerToMQ() gin.HandlerFunc &#123; return func(c *gin.Context) &#123; &#125;&#125; 这时会新生成一个文件 system.log.20190717.log，日志内容与上面的格式一致。 最后，logrus 可扩展的 Hook 很多，大家可以去网上查找。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"}]},{"title":"路由配置","slug":"gin-router","date":"2018-12-20T12:22:50.000Z","updated":"2022-05-11T09:47:11.000Z","comments":true,"path":"2018/12/20/gin-router/","link":"","permalink":"https://timmy6.github.io/2018/12/20/gin-router/","excerpt":"","text":"概述这篇文章分享 Gin 的路由配置，主要包含的功能点如下： 实现了，路由分组 v1版本、v2版本。 实现了，生成签名和验证验证。 实现了，在配置文件中读取配置。 路由配置比如我们的接口地址是这样的： /v1/product/add /v1/member/add /v2/product/add /v2/member/add 假设需求是这样的，接口支持多种请求方式，v1 不需签名验证，v2 需要签名验证，路由文件应该这样写： 123456789101112131415161718192021222324252627282930313233343536373839404142package routerimport ( &quot;ginDemo/common&quot; &quot;ginDemo/controller/v1&quot; &quot;ginDemo/controller/v2&quot; &quot;github.com/gin-gonic/gin&quot; &quot;net/url&quot; &quot;strconv&quot;)func InitRouter(r *gin.Engine) &#123; r.GET(&quot;/sn&quot;, SignDemo) // v1 版本 GroupV1 := r.Group(&quot;/v1&quot;) &#123; GroupV1.Any(&quot;/product/add&quot;, v1.AddProduct) GroupV1.Any(&quot;/member/add&quot;, v1.AddMember) &#125; // v2 版本 GroupV2 := r.Group(&quot;/v2&quot;, common.VerifySign) &#123; GroupV2.Any(&quot;/product/add&quot;, v2.AddProduct) GroupV2.Any(&quot;/member/add&quot;, v2.AddMember) &#125;&#125;func SignDemo(c *gin.Context) &#123; ts := strconv.FormatInt(common.GetTimeUnix(), 10) res := map[string]interface&#123;&#125;&#123;&#125; params := url.Values&#123; &quot;name&quot; : []string&#123;&quot;a&quot;&#125;, &quot;price&quot; : []string&#123;&quot;10&quot;&#125;, &quot;ts&quot; : []string&#123;ts&#125;, &#125; res[&quot;sn&quot;] = common.CreateSign(params) res[&quot;ts&quot;] = ts common.RetJson(&quot;200&quot;, &quot;&quot;, res, c)&#125; .Any 表示支持多种请求方式。 controller/v1 表示 v1 版本的文件。 controller/v2 表示 v2 版本的文件。 SignDemo 表示生成签名的Demo。 接下来，给出一些代码片段： 验证签名方法： 1234567891011121314151617181920212223242526272829303132333435// 验证签名func VerifySign(c *gin.Context) &#123; var method = c.Request.Method var ts int64 var sn string var req url.Values if method == &quot;GET&quot; &#123; req = c.Request.URL.Query() sn = c.Query(&quot;sn&quot;) ts, _ = strconv.ParseInt(c.Query(&quot;ts&quot;), 10, 64) &#125; else if method == &quot;POST&quot; &#123; req = c.Request.PostForm sn = c.PostForm(&quot;sn&quot;) ts, _ = strconv.ParseInt(c.PostForm(&quot;ts&quot;), 10, 64) &#125; else &#123; RetJson(&quot;500&quot;, &quot;Illegal requests&quot;, &quot;&quot;, c) return &#125; exp, _ := strconv.ParseInt(config.API_EXPIRY, 10, 64) // 验证过期时间 if ts &gt; GetTimeUnix() || GetTimeUnix() - ts &gt;= exp &#123; RetJson(&quot;500&quot;, &quot;Ts Error&quot;, &quot;&quot;, c) return &#125; // 验证签名 if sn == &quot;&quot; || sn != CreateSign(req) &#123; RetJson(&quot;500&quot;, &quot;Sn Error&quot;, &quot;&quot;, c) return &#125;&#125; 生成签名的方法： 123456789101112131415161718192021// 生成签名func CreateSign(params url.Values) string &#123; var key []string var str = &quot;&quot; for k := range params &#123; if k != &quot;sn&quot; &#123; key = append(key, k) &#125; &#125; sort.Strings(key) for i := 0; i &lt; len(key); i++ &#123; if i == 0 &#123; str = fmt.Sprintf(&quot;%v=%v&quot;, key[i], params.Get(key[i])) &#125; else &#123; str = str + fmt.Sprintf(&quot;&amp;%v=%v&quot;, key[i], params.Get(key[i])) &#125; &#125; // 自定义签名算法 sign := MD5(MD5(str) + MD5(config.APP_NAME + config.APP_SECRET)) return sign&#125; 获取参数的方法： 12345678910111213// 获取 Get 参数name := c.Query(&quot;name&quot;)price := c.DefaultQuery(&quot;price&quot;, &quot;100&quot;)// 获取 Post 参数name := c.PostForm(&quot;name&quot;)price := c.DefaultPostForm(&quot;price&quot;, &quot;100&quot;)// 获取 Get 所有参数ReqGet = c.Request.URL.Query()//获取 Post 所有参数ReqPost = c.Request.PostForm v1 业务代码： 123456789101112131415package v1import &quot;github.com/gin-gonic/gin&quot;func AddProduct(c *gin.Context) &#123; // 获取 Get 参数 name := c.Query(&quot;name&quot;) price := c.DefaultQuery(&quot;price&quot;, &quot;100&quot;) c.JSON(200, gin.H&#123; &quot;v1&quot; : &quot;AddProduct&quot;, &quot;name&quot; : name, &quot;price&quot; : price, &#125;)&#125; v2 业务代码： 123456789101112131415161718package v2import ( &quot;github.com/gin-gonic/gin&quot;)func AddProduct(c *gin.Context) &#123; // 获取 Get 参数 name := c.Query(&quot;name&quot;) price := c.DefaultQuery(&quot;price&quot;, &quot;100&quot;) c.JSON(200, gin.H&#123; &quot;v1&quot; : &quot;AddProduct&quot;, &quot;name&quot; : name, &quot;price&quot; : price, &#125;)&#125; 接下来，直接看效果吧。 访问 v1 接口： 访问后，直接返回数据，不走签名验证。 访问 v2 接口： 进入了这段验证： 12345// 验证过期时间if ts &gt; GetTimeUnix() || GetTimeUnix() - ts &gt;= exp &#123; RetJson(&quot;500&quot;, &quot;Ts Error&quot;, &quot;&quot;, c) return&#125; 修改为合法的时间戳后： 进入了这段验证： 12345// 验证签名if sn == &quot;&quot; || sn != CreateSign(req) &#123; RetJson(&quot;500&quot;, &quot;Sn Error&quot;, &quot;&quot;, c) return&#125; 修改为合法的签名后： 至此，简单的路由配置已经实现了。 对了，还有一个点没说，就是如何读取配置文件中的配置，我是这样做的： 12345678package configconst ( PORT = &quot;:8080&quot; APP_NAME = &quot;ginDemo&quot; APP_SECRET = &quot;6YJSuc50uJ18zj45&quot; API_EXPIRY = &quot;120&quot;) 引入 config 包，直接 config.xx 即可。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"}]},{"title":"使用 sync.WaitGroup 来实现并发操作","slug":"sync-WaitGroup","date":"2018-12-15T12:22:50.000Z","updated":"2022-05-11T09:47:04.981Z","comments":true,"path":"2018/12/15/sync-WaitGroup/","link":"","permalink":"https://timmy6.github.io/2018/12/15/sync-WaitGroup/","excerpt":"","text":"前言如果你有一个任务可以分解成多个子任务进行处理，同时每个子任务没有先后执行顺序的限制，等到全部子任务执行完毕后，再进行下一步处理。这时每个子任务的执行可以并发处理，这种情景下适合使用 sync.WaitGroup。 虽然 sync.WaitGroup 使用起来比较简单，但是一不留神很有可能踩到坑里。 sync.WaitGroup 正确使用比如，有一个任务需要执行 3 个子任务，那么可以这样写： 12345678910111213141516171819202122232425262728func main() &#123; var wg sync.WaitGroup wg.Add(3) go handlerTask1(&amp;wg) go handlerTask2(&amp;wg) go handlerTask3(&amp;wg) wg.Wait() fmt.Println(&quot;全部任务执行完毕.&quot;)&#125;func handlerTask1(wg *sync.WaitGroup) &#123; defer wg.Done() fmt.Println(&quot;执行任务 1&quot;)&#125;func handlerTask2(wg *sync.WaitGroup) &#123; defer wg.Done() fmt.Println(&quot;执行任务 2&quot;)&#125;func handlerTask3(wg *sync.WaitGroup) &#123; defer wg.Done() fmt.Println(&quot;执行任务 3&quot;)&#125; 执行输出： 1234执行任务 3执行任务 1执行任务 2全部任务执行完毕. sync.WaitGroup 闭坑指南0112345// 正确go handlerTask1(&amp;wg)// 错误go handlerTask1(wg) 执行子任务时，使用的 sync.WaitGroup 一定要是 wg 的引用类型！ 02注意不要将 wg.Add() 放在 go handlerTask1(&amp;wg) 中！ 例如： 1234567891011121314// 错误var wg sync.WaitGroupgo handlerTask1(&amp;wg)wg.Wait()...func handlerTask1(wg *sync.WaitGroup) &#123; wg.Add(1) defer wg.Done() fmt.Println(&quot;执行任务 1&quot;)&#125; 注意 wg.Add() 一定要在 wg.Wait() 执行前执行！ 03注意 wg.Add() 和 wg.Done() 的计数器保持一致！其实 wg.Done() 就是执行的 wg.Add(-1) 。 小结sync.WaitGroup 使用起来比较简单，一定要注意不要踩到坑里。 其实 sync.WaitGroup 使用场景比较局限，仅适用于等待全部子任务执行完毕后，再进行下一步处理，如果需求是当第一个子任务执行失败时，通知其他子任务停止运行，这时 sync.WaitGroup 是无法满足的，需要使用到通知机制（channel）。 以上，希望对你能够有所帮助。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"}]},{"title":"使用sync.Map来解决map的并发操作问题","slug":"sync-map","date":"2018-12-12T12:22:50.000Z","updated":"2022-05-11T09:46:56.245Z","comments":true,"path":"2018/12/12/sync-map/","link":"","permalink":"https://timmy6.github.io/2018/12/12/sync-map/","excerpt":"","text":"前言在 Golang 中 map 不是并发安全的，自 1.9 才引入了 sync.Map ，sync.Map 的引入确实解决了 map 的并发安全问题，不过 sync.Map 却没有实现 len() 函数，如果想要计算 sync.Map 的长度，稍微有点麻烦，需要使用 Range 函数。 map 并发操作出现问题1234567891011121314151617func main() &#123; demo := make(map[int]int) go func() &#123; for j := 0; j &lt; 1000; j++ &#123; demo[j] = j &#125; &#125;() go func() &#123; for j := 0; j &lt; 1000; j++ &#123; fmt.Println(demo[j]) &#125; &#125;() time.Sleep(time.Second * 1)&#125; 执行输出： 1fatal error: concurrent map read and map write sync.Map 解决并发操作问题1234567891011121314151617func main() &#123; demo := sync.Map&#123;&#125; go func() &#123; for j := 0; j &lt; 1000; j++ &#123; demo.Store(j, j) &#125; &#125;() go func() &#123; for j := 0; j &lt; 1000; j++ &#123; fmt.Println(demo.Load(j)) &#125; &#125;() time.Sleep(time.Second * 1)&#125; 执行输出： 123456&lt;nil&gt; false1 true...999 true 计算 map 长度123456789func main() &#123; demo := make(map[int]int) for j := 0; j &lt; 1000; j++ &#123; demo[j] = j &#125; fmt.Println(&quot;len of demo:&quot;, len(demo))&#125; 执行输出： 1len of demo: 1000 计算 sync.Map 长度123456789101112131415func main() &#123; demo := sync.Map&#123;&#125; for j := 0; j &lt; 1000; j++ &#123; demo.Store(j, j) &#125; lens := 0 demo.Range(func(key, value interface&#123;&#125;) bool &#123; lens++ return true &#125;) fmt.Println(&quot;len of demo:&quot;, lens)&#125; 执行输出： 1len of demo: 1000 小结 Load 加载 key 数据 Store 更新或新增 key 数据 Delete 删除 key 数据 Range 遍历数据 LoadOrStore 如果存在 key 数据则返回，反之则设置 LoadAndDelete 如果存在 key 数据则删除 以上，希望对你能够有所帮助。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"}]},{"title":"基于逃逸分析来提升程序性能","slug":"escape","date":"2018-12-10T11:17:50.000Z","updated":"2022-05-11T09:46:49.518Z","comments":true,"path":"2018/12/10/escape/","link":"","permalink":"https://timmy6.github.io/2018/12/10/escape/","excerpt":"","text":"前言为什么需要了解逃逸分析？ 因为我们想要提升程序性能，通过逃逸分析我们能够知道变量是分配到堆上还是栈上，如果分配到栈上，内存的分配和释放都是由编译器进行管理，分配和释放的速度非常快，如果分配到堆上，堆不像栈那样可以自动清理，它会引起频繁地进行垃圾回收（GC），而垃圾回收会占用比较大的系统开销。 什么是逃逸分析？ 在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法，简单来说就是分析在程序的哪些地方可以访问到该指针。 简单的说，它是在对变量放到堆上还是栈上进行分析，该分析在编译阶段完成。如果一个变量超过了函数调用的生命周期，也就是这个变量在函数外部存在引用，编译器会把这个变量分配到堆上，这时我们就说这个变量发生逃逸了。 如何确定是否逃逸？1go run -gcflags &#x27;-m -l&#x27; main.go 可能出现逃逸的场景011234567891011package maintype Student struct &#123; Name interface&#123;&#125;&#125;func main() &#123; stu := new(Student) stu.Name = &quot;tom&quot;&#125; 分析结果： 1234go run -gcflags &#x27;-m -l&#x27; 01.go# command-line-arguments./01.go:8:12: new(Student) does not escape./01.go:9:11: &quot;tom&quot; escapes to heap interface&#123;&#125; 赋值，会发生逃逸，优化方案是将类型设置为固定类型，例如：string 1234567891011package maintype Student struct &#123; Name string&#125;func main() &#123; stu := new(Student) stu.Name = &quot;tom&quot;&#125; 分析结果： 123go run -gcflags &#x27;-m -l&#x27; 01.go# command-line-arguments./01.go:8:12: new(Student) does not escape 0212345678910111213141516package maintype Student struct &#123; Name string&#125;func GetStudent() *Student &#123; stu := new(Student) stu.Name = &quot;tom&quot; return stu&#125;func main() &#123; GetStudent()&#125; 分析结果： 123go run -gcflags &#x27;-m -l&#x27; 02.go# command-line-arguments./02.go:8:12: new(Student) escapes to heap 返回指针类型，会发生逃逸，优化方案视情况而定。 函数传递指针和传值哪个效率高吗？我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加 GC 的负担，所以传递指针不一定是高效的。 不要盲目使用变量指针作为参数，虽然减少了复制，但变量逃逸的开销可能更大。 03123456789package mainfunc main() &#123; nums := make([]int, 10000, 10000) for i := range nums &#123; nums[i] = i &#125;&#125; 分析结果： 123go run -gcflags &#x27;-m -l&#x27; 03.go# command-line-arguments./03.go:4:14: make([]int, 10000, 10000) escapes to heap 栈空间不足，会发生逃逸，优化方案尽量设置容量，如果容量实在过大那就没办法了。 小结 逃逸分析是编译器在静态编译时完成的。 逃逸分析后可以确定哪些变量可以分配在栈上，栈的性能好。 以上，希望对你能够有所帮助。 推荐阅读 Go - 使用 sync.Pool 来减少 GC 压力 Go - 使用 options 设计模式 Go - json.Unmarshal 遇到的小坑 Go - 两个在开发中需注意的小点 Go - time.RFC3339 时间格式化","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"}]},{"title":"不要使用 + 和 fmt.Sprintf 操作字符串","slug":"string-append","date":"2018-12-05T10:17:50.000Z","updated":"2022-05-11T09:46:44.447Z","comments":true,"path":"2018/12/05/string-append/","link":"","permalink":"https://timmy6.github.io/2018/12/05/string-append/","excerpt":"","text":"不要使用 + 和 fmt.Sprintf 操作字符串不要使用 + 和 fmt.Sprintf 操作字符串，虽然很方便，但是真的很慢！ 我们要使用 bytes.NewBufferString 进行处理。 基准测试如下： +123456789101112131415161718func BenchmarkStringOperation1(b *testing.B) &#123; b.ResetTimer() str := &quot;&quot; for i := 0; i &lt; b.N; i++ &#123; str += &quot;golang&quot; &#125;&#125;// 输出goos: darwingoarch: amd64pkg: demo/stringoperationcpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHzBenchmarkStringOperation1BenchmarkStringOperation1-12 353318 114135 ns/opPASSProcess finished with the exit code 0 fmt.Sprintf123456789101112131415161718func BenchmarkStringOperation2(b *testing.B) &#123; b.ResetTimer() str := &quot;&quot; for i := 0; i &lt; b.N; i++ &#123; str = fmt.Sprintf(&quot;%s%s&quot;, str, &quot;golang&quot;) &#125;&#125;// 输出goos: darwingoarch: amd64pkg: demo/stringoperationcpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHzBenchmarkStringOperation2BenchmarkStringOperation2-12 280140 214098 ns/opPASSProcess finished with the exit code 0 bytes.NewBufferString123456789101112131415161718func BenchmarkStringOperation3(b *testing.B) &#123; b.ResetTimer() strBuf := bytes.NewBufferString(&quot;&quot;) for i := 0; i &lt; b.N; i++ &#123; strBuf.WriteString(&quot;golang&quot;) &#125;&#125;// 输出goos: darwingoarch: amd64pkg: demo/stringoperationcpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHzBenchmarkStringOperation3BenchmarkStringOperation3-12 161292136 8.582 ns/opPASSProcess finished with the exit code 0 对于固定字段的键值对，不要使用 map[string]interface{}对于固定字段的键值对，不要使用 map[string]interface&#123;&#125;! 我们要使用临时 Struct。 基准测试如下： map[string]interface{}12345678910111213141516171819func BenchmarkStructOperation1(b *testing.B) &#123; b.ResetTimer() for i := 0; i &lt; b.N; i++ &#123; var demo = map[string]interface&#123;&#125;&#123;&#125; demo[&quot;Name&quot;] = &quot;Tom&quot; demo[&quot;Age&quot;] = 30 &#125;&#125;// 输出goos: darwingoarch: amd64pkg: demo/structoperationcpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHzBenchmarkStructOperation1BenchmarkStructOperation1-12 43300134 27.97 ns/opPASSProcess finished with the exit code 0 临时 Struct12345678910111213141516171819202122func BenchmarkStructOperation2(b *testing.B) &#123; b.ResetTimer() for i := 0; i &lt; b.N; i++ &#123; var demo struct &#123; Name string Age int &#125; demo.Name = &quot;Tom&quot; demo.Age = 30 &#125;&#125;// 输出oos: darwingoarch: amd64pkg: demo/structoperationcpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHzBenchmarkStructOperation2BenchmarkStructOperation2-12 1000000000 0.2388 ns/opPASSProcess finished with the exit code 0 小结你有类似这样的注意点吗，欢迎留言~ 下面推荐阅读的这几篇文章也是关于开发中需要知道的小技术点，更多技术细节和代码讨论，可以加入到我的星球。 推荐阅读 函数的不定参数你是这样用吗？ 优雅地处理错误真是一门学问啊！ 如何设计 API 接口，实现统一格式返回？","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"}]},{"title":"json.Unmarshal遇到的小坑","slug":"json-unmarshal","date":"2018-11-25T10:17:50.000Z","updated":"2022-05-11T09:46:39.159Z","comments":true,"path":"2018/11/25/json-unmarshal/","link":"","permalink":"https://timmy6.github.io/2018/11/25/json-unmarshal/","excerpt":"","text":"1.问题现象描述使用 json.Unmarshal()，反序列化时，出现了科学计数法，参考代码如下： 12345678910jsonStr := `&#123;&quot;number&quot;:1234567&#125;`result := make(map[string]interface&#123;&#125;)err := json.Unmarshal([]byte(jsonStr), &amp;result)if err != nil &#123; fmt.Println(err)&#125;fmt.Println(result)// 输出// map[number:1.234567e+06] 这个问题不是必现，只有当数字的位数大于 6 位时，才会变成了科学计数法。 2.问题影响描述当数据结构未知，使用 map[string]interface&#123;&#125; 来接收反序列化结果时，如果数字的位数大于 6 位，都会变成科学计数法，用到的地方都会受到影响。 3.引起问题的原因从 encoding/json 可以找到答案，看一下这段注释： 123456789// To unmarshal JSON into an interface value,// Unmarshal stores one of these in the interface value://// bool, for JSON booleans// float64, for JSON numbers// string, for JSON strings// []interface&#123;&#125;, for JSON arrays// map[string]interface&#123;&#125;, for JSON objects// nil for JSON null 是因为当 JSON 中存在一个比较大的数字时，它会被解析成 float64 类型，就有可能会出现科学计数法的形式。 4.问题的解决方案方案一 强制类型转换，参考代码如下： 12345678910jsonStr := `&#123;&quot;number&quot;:1234567&#125;`result := make(map[string]interface&#123;&#125;)err := json.Unmarshal([]byte(jsonStr), &amp;result)if err != nil &#123; fmt.Println(err)&#125;fmt.Println(int(result[&quot;number&quot;].(float64)))// 输出// 1234567 方案二 尽量避免使用 interface，对 json 字符串结构定义结构体，快捷方法可使用在线工具：https://mholt.github.io/json-to-go/。 1234567891011121314type Num struct &#123; Number int `json:&quot;number&quot;`&#125;jsonStr := `&#123;&quot;number&quot;:1234567&#125;`var result Numerr := json.Unmarshal([]byte(jsonStr), &amp;result)if err != nil &#123; fmt.Println(err)&#125;fmt.Println(result)// 输出// &#123;1234567&#125; 方案三 使用 UseNumber() 方法。 123456789101112jsonStr := `&#123;&quot;number&quot;:1234567&#125;`result := make(map[string]interface&#123;&#125;)d := json.NewDecoder(bytes.NewReader([]byte(jsonStr)))d.UseNumber()err := d.Decode(&amp;result)if err != nil &#123; fmt.Println(err)&#125;fmt.Println(result)// 输出// map[number:1234567] 这时一定要注意 result[&quot;number&quot;] 的数据类型！ 1234fmt.Println(fmt.Sprintf(&quot;type: %v&quot;, reflect.TypeOf(result[&quot;number&quot;])))// 输出// type: json.Number 通过代码可以看出 json.Number 其实就是字符串类型： 12// A Number represents a JSON number literal.type Number string 如果转换其他类型，参考如下代码： 12345678910111213// 转成 int64numInt, _ := result[&quot;number&quot;].(json.Number).Int64()fmt.Println(fmt.Sprintf(&quot;value: %v, type: %v&quot;, numInt, reflect.TypeOf(numInt)))// 输出// value: 1234567, type: int64// 转成 stringnumStr := result[&quot;number&quot;].(json.Number).String()fmt.Println(fmt.Sprintf(&quot;value: %v, type: %v&quot;, numStr, reflect.TypeOf(numStr)))// 输出// value: 1234567, type: string","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"}]},{"title":"defer 函数","slug":"defer","date":"2018-11-15T11:17:50.000Z","updated":"2022-05-11T09:46:33.357Z","comments":true,"path":"2018/11/15/defer/","link":"","permalink":"https://timmy6.github.io/2018/11/15/defer/","excerpt":"","text":"概述defer 函数大家肯定都用过，它在声明时不会立刻去执行，而是在函数 return 后去执行的。 它的主要应用场景有异常处理、记录日志、清理数据、释放资源 等等。 这篇文章不是分享 defer 的应用场景，而是分享使用 defer 需要注意的点。 咱们先从一道题开始，一起来感受下 … 1234567891011121314func calc(index string, a, b int) int &#123; ret := a + b fmt.Println(index, a, b, ret) return ret&#125;func main() &#123; x := 1 y := 2 defer calc(&quot;A&quot;, x, calc(&quot;B&quot;, x, y)) x = 3 defer calc(&quot;C&quot;, x, calc(&quot;D&quot;, x, y)) y = 4&#125; 输出什么？ … 接下来，先容我分享几个小例子，再进行作答。 执行顺序12345678func main() &#123; defer fmt.Println(&quot;1&quot;) defer fmt.Println(&quot;2&quot;) defer fmt.Println(&quot;3&quot;) fmt.Println(&quot;main&quot;)&#125; 输出： 1234main321 结论：defer 函数定义的顺序 与 实际执的行顺序是相反的，也就是最先声明的最后才执行。 闭包1234567891011func main() &#123; var a = 1 var b = 2 defer fmt.Println(a + b) a = 2 fmt.Println(&quot;main&quot;)&#125; 输出： 12main3 稍微修改一下，再看看： 123456789101112func main() &#123; var a = 1 var b = 2 defer func() &#123; fmt.Println(a + b) &#125;() a = 2 fmt.Println(&quot;main&quot;)&#125; 输出： 12main4 结论：闭包获取变量相当于引用传递，而非值传递。 稍微再修改一下，再看看： 123456789101112func main() &#123; var a = 1 var b = 2 defer func(a int, b int) &#123; fmt.Println(a + b) &#125;(a, b) a = 2 fmt.Println(&quot;main&quot;)&#125; 输出： 12main3 结论：传参是值复制。 还可以理解为：defer 调用的函数，参数的值在 defer 定义时就确定了，看下代码 defer fmt.Println(a + b)，在这时，参数的值已经确定了。 而 defer 函数内部所使用的变量的值需要在这个函数运行时才确定，看下代码 defer func() &#123; fmt.Println(a + b) &#125;()，a 和 b 的值在函数运行时，才能确定。 Return一1234567func t1() int &#123; a := 1 defer func() &#123; a++ &#125;() return a&#125; 输出：1 二123456func t2() (a int) &#123; defer func() &#123; a++ &#125;() return 1&#125; 输出：2 三1234567func t3() (b int) &#123; a := 1 defer func() &#123; a++ &#125;() return 1&#125; 输出：1 四123456func t4() (a int) &#123; defer func(a int) &#123; a++ &#125;(a) return 1&#125; 输出：1 结论：return 不是原子操作。 os.Exit12345func main() &#123; defer fmt.Println(&quot;1&quot;) fmt.Println(&quot;main&quot;) os.Exit(0)&#125; 输出：main 结论：当os.Exit()方法退出程序时，defer不会被执行。 不同协程12345678910111213141516171819func main() &#123; GoA() time.Sleep(1 * time.Second) fmt.Println(&quot;main&quot;)&#125;func GoA() &#123; defer (func()&#123; if err := recover(); err != nil &#123; fmt.Println(&quot;panic:&quot; + fmt.Sprintf(&quot;%s&quot;, err)) &#125; &#125;)() go GoB()&#125;func GoB() &#123; panic(&quot;error&quot;)&#125; GoB() panic 捕获不到。 结论：defer 只对当前协程有效。 这个问题怎么解？咱们下回再说。 接下来，咱们分析下文章开头的问题吧。 答案解析先列出答案： 1234B 1 2 3D 3 2 5C 3 5 8A 1 3 4 其实上面那道题，可以拆解为： 12345678910111213141516func calc(index string, a, b int) int &#123; ret := a + b fmt.Println(index, a, b, ret) return ret&#125;func main() &#123; x := 1 y := 2 tmp1 := calc(&quot;B&quot;, x, y) defer calc(&quot;A&quot;, x, tmp1) x = 3 tmp2 := calc(&quot;D&quot;, x, y) defer calc(&quot;C&quot;, x, tmp2) y = 4&#125; 所以顺序就是：B D C A。 执行到 tmp1 时，输出：B 1 2 3。 执行到 tmp2 时，输出：D 3 2 5。 根据 defer 执行顺序原则，先声明的后执行，所以下一个该执行 C 了。 又因为传参是值赋值，所以在 A 的时候，无法用到 x = 3 和 y = 4，在 C 的时候，无法用到 y = 4。 执行到 C 时，输出：C 3 5 8 执行到 A 时，输出：A 1 3 4 到这，基本上 defer 就清楚了，大家可以根据自己的理解去记忆。 go-gin-api 系列文章 7. 路由中间件 - 签名验证 6. 路由中间件 - Jaeger 链路追踪（实战篇） 5. 路由中间件 - Jaeger 链路追踪（理论篇） 4. 路由中间件 - 捕获异常 3. 路由中间件 - 日志记录 2. 规划项目目录和参数验证 1. 使用 go modules 初始化项目","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"}]},{"title":"chan通道","slug":"chan","date":"2018-11-05T11:17:50.000Z","updated":"2022-05-11T09:46:27.420Z","comments":true,"path":"2018/11/05/chan/","link":"","permalink":"https://timmy6.github.io/2018/11/05/chan/","excerpt":"","text":"概述chan 可以理解为队列，遵循先进先出的规则。 在说 chan 之前，咱们先说一下 go 关键字。 在 go 关键字后面加一个函数，就可以创建一个线程，函数可以为已经写好的函数，也可以是匿名函数。 举个例子： 123456789func main() &#123; fmt.Println(&quot;main start&quot;) go func() &#123; fmt.Println(&quot;goroutine&quot;) &#125;() fmt.Println(&quot;main end&quot;)&#125; 输出： 12main startmain end 为什么没有输出 goroutine ？ 首先，我们清楚 Go 语言的线程是并发机制，不是并行机制。 那么，什么是并发，什么是并行？ 并发是不同的代码块交替执行，也就是交替可以做不同的事情。 并行是不同的代码块同时执行，也就是同时可以做不同的事情。 举个生活化场景的例子： 你正在家看书，忽然电话来了，然后你接电话，通话完成后继续看书，这就是并发，看书和接电话交替做。 如果电话来了，你一边看书一遍接电话，这就是并行，看书和接电话一起做。 说回上面的例子，为什么没有输出 goroutine ？ main 函数是一个主线程，是因为主线程执行太快了，子线程还没来得及执行，所以看不到输出。 现在让主线程休眠 1 秒钟，再试试。 1234567891011func main() &#123; fmt.Println(&quot;main start&quot;) go func() &#123; fmt.Println(&quot;goroutine&quot;) &#125;() time.Sleep(1 * time.Second) fmt.Println(&quot;main end&quot;)&#125; 输出： 123main startgoroutinemain end 这就对了。 接下来，看看如何使用 chan 。 声明 chan1234567891011// 声明不带缓冲的通道ch1 := make(chan string)// 声明带10个缓冲的通道ch2 := make(chan string, 10)// 声明只读通道ch3 := make(&lt;-chan string)// 声明只写通道ch4 := make(chan&lt;- string) 注意： 不带缓冲的通道，进和出都会阻塞。 带缓冲的通道，进一次长度 +1，出一次长度 -1，如果长度等于缓冲长度时，再进就会阻塞。 写入 chan123ch1 := make(chan string, 10)ch1 &lt;- &quot;a&quot; 读取 chan123val, ok := &lt;- ch1// 或val := &lt;- ch1 关闭 chan1close(chan) 注意： close 以后不能再写入，写入会出现 panic 重复 close 会出现 panic 只读的 chan 不能 close close 以后还可以读取数据 示例12345678910func main() &#123; fmt.Println(&quot;main start&quot;) ch := make(chan string) ch &lt;- &quot;a&quot; // 入 chan go func() &#123; val := &lt;- ch // 出 chan fmt.Println(val) &#125;() fmt.Println(&quot;main end&quot;)&#125; 输出： 12main startfatal error: all goroutines are asleep - deadlock! What ? 这是为啥，刚开始就出师不利呀？ 因为，定义的是一个无缓冲的 chan，赋值后就陷入了阻塞。 怎么解决它？ 声明一个有缓冲的 chan。 12345678910func main() &#123; fmt.Println(&quot;main start&quot;) ch := make(chan string, 1) ch &lt;- &quot;a&quot; // 入 chan go func() &#123; val := &lt;- ch // 出 chan fmt.Println(val) &#125;() fmt.Println(&quot;main end&quot;)&#125; 输出： 12main startmain end 为啥没有输出 a , 和前面一样，主线程执行太快了，加个休眠 1 秒钟，再试试。 1234567891011func main() &#123; fmt.Println(&quot;main start&quot;) ch := make(chan string, 1) ch &lt;- &quot;a&quot; // 入 chan go func() &#123; val := &lt;- ch // 出 chan fmt.Println(val) &#125;() time.Sleep(1 * time.Second) fmt.Println(&quot;main end&quot;)&#125; 输出： 123main startamain end 这就对了。 再看一个例子： 12345678910111213func main() &#123; fmt.Println(&quot;main start&quot;) ch := make(chan string) go func() &#123; ch &lt;- &quot;a&quot; // 入 chan &#125;() go func() &#123; val := &lt;- ch // 出 chan fmt.Println(val) &#125;() time.Sleep(1 * time.Second) fmt.Println(&quot;main end&quot;)&#125; 输出： 123main startamain end 再看一个例子： 1234567891011121314151617func producer(ch chan string) &#123; fmt.Println(&quot;producer start&quot;) ch &lt;- &quot;a&quot; ch &lt;- &quot;b&quot; ch &lt;- &quot;c&quot; ch &lt;- &quot;d&quot; fmt.Println(&quot;producer end&quot;)&#125;func main() &#123; fmt.Println(&quot;main start&quot;) ch := make(chan string, 3) go producer(ch) time.Sleep(1 * time.Second) fmt.Println(&quot;main end&quot;)&#125; 输出： 123main startproducer startmain end 带缓冲的通道，如果长度等于缓冲长度时，再进就会阻塞。 再看一个例子： 12345678910111213141516171819202122232425func producer(ch chan string) &#123; fmt.Println(&quot;producer start&quot;) ch &lt;- &quot;a&quot; ch &lt;- &quot;b&quot; ch &lt;- &quot;c&quot; ch &lt;- &quot;d&quot; fmt.Println(&quot;producer end&quot;)&#125;func customer(ch chan string) &#123; for &#123; msg := &lt;- ch fmt.Println(msg) &#125;&#125;func main() &#123; fmt.Println(&quot;main start&quot;) ch := make(chan string, 3) go producer(ch) go customer(ch) time.Sleep(1 * time.Second) fmt.Println(&quot;main end&quot;)&#125; 输出： 12345678main startproducer startproducer endabcdmain end 就到这吧。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"}]},{"title":"老项目迁移 go module 大型灾难记录","slug":"gomod","date":"2018-10-26T08:17:50.000Z","updated":"2022-05-11T09:46:21.557Z","comments":true,"path":"2018/10/26/gomod/","link":"","permalink":"https://timmy6.github.io/2018/10/26/gomod/","excerpt":"最近在改造一个比较早期的一个项目，其中就涉及到用将原来 Vendor 管理依赖换成 Go Modules 来管理。 然而过程真是一波三折，在这里总结一下此次 Go Modules 改造中遇到的问题，以及解决方法。","text":"最近在改造一个比较早期的一个项目，其中就涉及到用将原来 Vendor 管理依赖换成 Go Modules 来管理。 然而过程真是一波三折，在这里总结一下此次 Go Modules 改造中遇到的问题，以及解决方法。 背景 go version： 12$ go versiongo version go1.16.5 darwin/amd64 简化的 demo 如下, 很 “简单” 我们只要把 hello world 输出即可。 123456789101112131415161718192021222324252627package mainimport ( &quot;github.com/coreos/etcd/pkg/transport&quot; &quot;github.com/google/certificate-transparency-go/tls&quot; &quot;github.com/qiniu/api.v7/auth/qbox&quot; &quot;go.etcd.io/etcd/clientv3&quot; &quot;google.golang.org/grpc&quot; &quot;qiniupkg.com/x/log.v7&quot;)func main() &#123; _ = transport.TLSInfo&#123;&#125; _ = clientv3.WatchResponse&#123;&#125; _, _ = clientv3.New(clientv3.Config&#123;&#125;) _ = qbox.NewMac(&quot;&quot;, &quot;&quot;) _ = tls.DigitallySigned&#123;&#125; _ = grpc.ClientConn&#123;&#125; log.Info(&quot;hello world&quot;)&#125; 实战直接初始化，并 tidy 一下。 123456789101112131415161718192021222324$ go mod init demo-go/gomodgo: creating new go.mod: module demo-go/gomodgo: to add module requirements and sums: go mod tidy $ go mod tidygo: finding module for ...demo-go/gomod imports qiniupkg.com/x/log.v7: module qiniupkg.com/x@latest found (v1.11.5), but does not contain package qiniupkg.com/x/log.v7demo-go/gomod imports github.com/qiniu/api.v7/auth/qbox imports github.com/qiniu/x/bytes.v7/seekable: module github.com/qiniu/x@latest found (v1.11.5), but does not contain package github.com/qiniu/x/bytes.v7/seekabledemo-go/gomod imports go.etcd.io/etcd/clientv3 imports github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context: package github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context provided by github.com/coreos/etcd at latest version v2.3.8+incompatible but not at required version v3.3.10+incompatibledemo-go/gomod imports go.etcd.io/etcd/clientv3 imports github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc: package github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc provided by github.com/coreos/etcd at latest version v2.3.8+incompatible but not at required version v3.3.10+incompatibledemo-go/gomod imports go.etcd.io/etcd/clientv3 imports github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/credentials: package github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/credentials provided by github.com/coreos/etcd at latest version v2.3.8+incompatible but not at required version v3.3.10+incompatibledemo-go/gomod imports go.etcd.io/etcd/clientv3 imports github.com/coreos/etcd/storage/storagepb: package github.com/coreos/etcd/storage/storagepb provided by github.com/coreos/etcd at latest version v2.3.8+incompatible but not at required version v3.3.10+incompatible 好家伙，报错了。我们先看到前两行 qiniupkg.com/x@latest 中没有 qiniupkg.com/x/log.v7； github.com/qiniu/x@latest 中没有 github.com/qiniu/x/bytes.v7/seekable； 这看起来应该是一个问题， qiniupkg.com/x 和github.com/qiniu/x 应该是同一个包，不同镜像。于是我到 Github 看一下 @lastet 版本的代码，确实没有bytes.v7 包了。人肉查找，最后在 v1.7.8 版本，我们找到了 bytes.v7 包。 于是，我们可以指定一下版本。 12go mod edit -replace qiniupkg.com/x=qiniupkg.com/x@v1.7.8go mod edit -replace github.com/qiniu/x=github.com/qiniu/x@v1.7.8 继续往下看，接下来的几个问题是一类的，都是etcd导致的。 意思是 go.etcd.io/etcd/clientv3 导入了 github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context, 同时 github.com/coreos/etcd@v2.3.8 中 提供了 github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context 。 但是，我们这里需要 github.com/coreos/etcd@v3.3.10, 而该版本并不提供 github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context 。 我们直接更新 etcd 到的 v3.3.10 试试。 1go mod edit -replace go.etcd.io/etcd=go.etcd.io/etcd@v3.3.20+incompatible 我们再 go mod tidy 下。 123456789$ go mod tidygo: demo-go/gomod imports go.etcd.io/etcd/clientv3 tested by go.etcd.io/etcd/clientv3.test imports github.com/coreos/etcd/auth imports github.com/coreos/etcd/mvcc/backend imports github.com/coreos/bbolt: github.com/coreos/bbolt@v1.3.6: parsing go.mod: module declares its path as: go.etcd.io/bbolt but was required as: github.com/coreos/bbolt 这个错误和鸟窝这篇 Etcd使用go module的灾难一致，go.etcd.io/bbolt 和 github.com/coreos/bbolt 包名不一致，我们替换一下。 1go mod edit -replace github.com/coreos/bbolt@v1.3.6=go.etcd.io/bbolt@v1.3.6 继续，go mod tidy 一下。 1234567891011121314151617181920$ go mod tidy...demo-go/gomod imports go.etcd.io/etcd/clientv3 imports github.com/coreos/etcd/clientv3/balancer: module github.com/coreos/etcd@latest found (v2.3.8+incompatible), but does not contain package github.com/coreos/etcd/clientv3/balancerdemo-go/gomod imports go.etcd.io/etcd/clientv3 imports github.com/coreos/etcd/clientv3/balancer/picker: module github.com/coreos/etcd@latest found (v2.3.8+incompatible), but does not contain package github.com/coreos/etcd/clientv3/balancer/pickerdemo-go/gomod imports go.etcd.io/etcd/clientv3 imports github.com/coreos/etcd/clientv3/balancer/resolver/endpoint: module github.com/coreos/etcd@latest found (v2.3.8+incompatible), but does not contain package github.com/coreos/etcd/clientv3/balancer/resolver/endpointdemo-go/gomod imports go.etcd.io/etcd/clientv3 imports github.com/coreos/etcd/clientv3/credentials: module github.com/coreos/etcd@latest found (v2.3.8+incompatible), but does not contain package github.com/coreos/etcd/clientv3/credentialsdemo-go/gomod imports go.etcd.io/etcd/clientv3 tested by go.etcd.io/etcd/clientv3.test imports github.com/coreos/etcd/integration imports github.com/coreos/etcd/proxy/grpcproxy imports google.golang.org/grpc/naming: module google.golang.org/grpc@latest found (v1.39.0), but does not contain package google.golang.org/grpc/naming 好家伙，又是etcd。 仔细一看，我们导入了github.com/coreos/etcd 和 go.etcd.io/etcd 两个版本etcd, 我们前面只替换了一个。现在我们把另外一个也替换了。 1go mod edit -replace github.com/coreos/etcd=github.com/coreos/etcd@v3.3.20+incompatible 再go mod tidy下，这个错误没有了，但还有个grpc的错误，继续找原因。原来是 google.golang.org/grpc v1.39.0 版本没有 google.golang.org/grpc/naming 包。 上 Github 仓库， 找了一下历史版本，v1.29.1上是有这个包的，我们继续替换。 1go mod edit -replace google.golang.org/grpc=google.golang.org/grpc@v1.29.1 这下，终于，go mod tidy通过了，可以开心的输出hello world 了。 然而， 1234567$ go run main.go# github.com/coreos/etcd/clientv3/balancer/resolver/endpoint../../../go/pkg/mod/github.com/coreos/etcd@v3.3.20+incompatible/clientv3/balancer/resolver/endpoint/endpoint.go:114:78: undefined: resolver.BuildOption../../../go/pkg/mod/github.com/coreos/etcd@v3.3.20+incompatible/clientv3/balancer/resolver/endpoint/endpoint.go:182:31: undefined: resolver.ResolveNowOption# github.com/coreos/etcd/clientv3/balancer/picker../../../go/pkg/mod/github.com/coreos/etcd@v3.3.20+incompatible/clientv3/balancer/picker/err.go:37:44: undefined: balancer.PickOptions../../../go/pkg/mod/github.com/coreos/etcd@v3.3.20+incompatible/clientv3/balancer/picker/roundrobin_balanced.go:55:54: undefined: balancer.PickOptions 意不意外，惊不惊喜！! 原来etcd包依赖了grpc的resolver包，但我导入的v1.29.1版本的grpc是没有这个包的。到 grpc仓库 挨个版本看了一下，确实只有v1.26.0版本才声明了type BuildOption 。于是，我们再次使用替换大法。 1go mod edit -replace google.golang.org/grpc=google.golang.org/grpc@v1.26.0 再次tidy, 运行！ 终于，看到了久违的hello world! 12$ go run main.go2021/07/20 12:27:09.642431 [INFO] /Users/razeen/wspace/github/demo-go/gomod/main.go:26: hello world 总结项目规范现在我们回过头看下这个 demo 项目，其实很有问题。 123456&quot;github.com/coreos/etcd/pkg/transport&quot;&quot;github.com/google/certificate-transparency-go/tls&quot;&quot;github.com/qiniu/api.v7/auth/qbox&quot;&quot;go.etcd.io/etcd/clientv3&quot;&quot;google.golang.org/grpc&quot;&quot;qiniupkg.com/x/log.v7&quot; etcd 和 qiniupkg的包完全可以统一，只导入一种！而且，后来我们发现log.v7这包也是意外导入的…. 这也是在改造我们一些老的项目时遇到的问题，以前用vendor go get 没有注意到这些问题，这是需要提前规范的。 看懂 go.mod我们来简单看一下，经历各种坎坷后，得出的go.mod 文件。 12345678910111213141516171819202122232425262728293031module demo-go/gomodgo 1.16replace qiniupkg.com/x =&gt; qiniupkg.com/x v1.7.8replace github.com/qiniu/x =&gt; github.com/qiniu/x v1.7.8replace go.etcd.io/etcd =&gt; go.etcd.io/etcd v3.3.20+incompatiblereplace github.com/coreos/bbolt v1.3.6 =&gt; go.etcd.io/bbolt v1.3.6replace github.com/coreos/etcd =&gt; github.com/coreos/etcd v3.3.20+incompatiblereplace google.golang.org/grpc =&gt; google.golang.org/grpc v1.26.0require ( github.com/coreos/bbolt v1.3.6 // indirect github.com/coreos/etcd v3.3.10+incompatible github.com/dgrijalva/jwt-go v3.2.0+incompatible // indirect github.com/google/certificate-transparency-go v1.1.1 github.com/grpc-ecosystem/go-grpc-prometheus v1.2.0 // indirect github.com/qiniu/api.v7 v7.2.5+incompatible github.com/qiniu/x v0.0.0-00010101000000-000000000000 // indirect github.com/soheilhy/cmux v0.1.5 // indirect github.com/xiang90/probing v0.0.0-20190116061207-43a291ad63a2 // indirect go.etcd.io/etcd v0.0.0-20200513171258-e048e166ab9c google.golang.org/grpc v1.29.1 qiniupkg.com/x v0.0.0-00010101000000-000000000000 sigs.k8s.io/yaml v1.2.0 // indirect) 我们先看一个常见的这几个指令， module 定义主模块的路径； go 编写该mod文件时的go版本； require 声明给定模块依赖项的最低要求版本; replace 手动指定的依赖模块 (可以替换全部的版本、指定的版本、本地的版本等等 )； 还有就是 v3.3.20+incompatible 后面的 +incompatible , 这是指兼容的版本，指依赖库的版本是v2 或以上，但go.mod和 依赖库路径 没有按照官方指定的方式命名，会加上这个。 v0.0.0-00010101000000-000000000000 这是一个伪版本，在和 不兼容 module 或 标记的版本不可用的时候，回打上这个伪版本。 // indirect 这指明这些不是我们直接引用的依赖。 除此之外，以下指令也可了解一下。 1234567891011121314# 查看当前模块以及所有的依赖模块go list -m all# 查看某个模块的以及打标签的版本go list -m -versions go.etcd.io/etcd# 升级特定的包go get xx@version 升级特定的包# 了解为什么需要模块go mod why -m all # 为什么需要指定（google.golang.org/grpc）的模块go mod why -m google.golang.org/grpc 更多可以细读官方文档，感谢阅读。 参考 Using Go Modules Minimal Version Selection 跳出Go module的泥潭 Etcd使用go module的灾难 浅谈Go Modules原理","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"}]},{"title":"Golang中的RESTful API最佳实践","slug":"restful","date":"2018-10-22T08:17:50.000Z","updated":"2022-05-11T09:46:15.199Z","comments":true,"path":"2018/10/22/restful/","link":"","permalink":"https://timmy6.github.io/2018/10/22/restful/","excerpt":"RESRful API已经流行很多年了，我也一直在使用它。最佳实践也看过不少，但当一个项目完成，再次回顾&#x2F;梳理项目时，会发现很多API和规范还是多少有些出入。在这篇文章中，我们结合Go Web再次梳理一下RESTful API的相关最佳实践。","text":"RESRful API已经流行很多年了，我也一直在使用它。最佳实践也看过不少，但当一个项目完成，再次回顾&#x2F;梳理项目时，会发现很多API和规范还是多少有些出入。在这篇文章中，我们结合Go Web再次梳理一下RESTful API的相关最佳实践。 关于RESTful API关于什么是RESTful API，不再累述。推荐几个相关链接。 理解RESTful架构 REST API Tutorial 1.使用JSON不管是接收还是返回数据都推荐使用JSON。 通常返回数据的格式有JSON和XML，但XML过于冗长，可读性差，而且各种语言的解析上也不如JSON，使用JSON的好处，显而易见。 而接收数据，我们这里也推荐使用JSON，对于后端开发而言，入参直接与模型绑定，省去冗长的参数解析能简化不少代码，而且JSON能更简单的传递一些更复杂的结构等。 正如示例代码中的这一段，我们以gin框架为例。 12345678910111213141516// HandleLogin docfunc HandleLogin(c *gin.Context) &#123; param := &amp;LoginParams&#123;&#125; if err := c.BindJSON(param); err != nil &#123; c.JSON(http.StatusBadRequest, &amp;Resp&#123;Error: &quot;parameters error&quot;&#125;) return &#125; // 做一些校验 // ... session := sessions.Default(c) session.Set(sessionsKey, param.UserID) session.Save() c.JSON(http.StatusOK, &amp;Resp&#123;Data: &quot;login succeed&quot;&#125;)&#125; 通过c.BindJSON,轻松的将入参于模型LoginParams绑定；通过c.JSON轻松的将数据JSON序列化返回。 但所有接口都必须用JSON么？那也未必。比如文件上传，这时我们使用FormData比把文件base64之类的放到JSON里面更高效。 2.路径中不包含动词我们的HTTP请求方法中已经有GET,POST等这些动作了，完全没有必要再路径中加上动词。 我们常用HTTP请求方法包括GET,POST,PUT和DELETE, 这也对应了我们经常需要做的数据库操作。GET查找&#x2F;获取资源，POST新增资源，PUT修改资源，DELETE删除资源。 如下，这些路径中没有任何动词，简洁明了。 12345678// 获取文章列表v1.GET(&quot;/articles&quot;, HandleGetArticles)// 发布文章v1.POST(&quot;/articles&quot;, HandlePostArticles)// 修改文章v1.PUT(&quot;/articles&quot;, HandleUpdateArticles)// 删除文章v1.DELETE(&quot;/articles/:id&quot;, HandleDeleteArticles) 3.路径中对应资源用复数就像我们上面这段代码，articles对于的是我们的文章资源，背后就是一张数据库表articles, 所以操作这个资源的应该都用复数形式。 4.次要资源可分层展示一个博客系统中，最主要的应该是文章了，而评论应该是其子资源，我们可以评论嵌套在它的父资源后面，如： 12345678// 获取评论列表v1.GET(&quot;/articles/:articles_id/comments&quot;, HandleGetComments)// 添加评论v1.POST(&quot;/articles/:articles_id/comments&quot;, HandleAddComments)// 修改评论v1.PUT(&quot;/articles/:articles_id/comments/:id&quot;, HandleUpdateComments)// 删除评论v1.DELETE(&quot;/articles/:articles_id/comments/:id&quot;, HandleDeleteComments) 那么，我们需要获取所有文章的评论怎么办？可以这么写： 1v1.GET(&quot;/articles/-/comments&quot;, HandleGetComments) 但这也不是决对的，资源虽然有层级关系，但这种层级关系不宜太深，个人感觉两层最多了，如果超过，可以直接拿出来放在一级。 5.分页、排序、过滤获取列表时，会使用到分页、排序过滤。一般： 123?page=1&amp;page_size=10 # 指定页面page与分页大小page_size?sort=-create_at,+author # 按照创建时间create_at降序，作者author升序排序?title=helloworld # 按字段title搜索 6.统一数据格式不管是路径的格式，还是参数的格式，还是返回值的格式建议统一形式。 一般常用的格式有蛇形,大驼峰和小驼峰，个人比较喜欢蛇形。Anyway, 不管哪种，只要统一即可。 除了参数的命名统一外，返回的数据格式，最好统一，方便前端对接。 如下，我们定义Resp为通用返回数据结构，Data中存放返回的数据，如果出错，将错误信息放在Error中。 123456789101112131415// Resp doctype Resp struct &#123; Data interface&#123;&#125; `json:&quot;data&quot;` Error string `json:&quot;error&quot;`&#125;// 登陆成功返回 c.JSON(http.StatusOK, &amp;Resp&#123;Data: &quot;login succeed&quot;&#125;)// 查询列表 c.JSON(http.StatusOK, &amp;Resp&#123;Data: map[string]interface&#123;&#125;&#123; &quot;result&quot;: tempStorage, &quot;total&quot;: len(tempStorage), &#125;&#125;)// 参数错误 c.JSON(http.StatusBadRequest, &amp;Resp&#123;Error: &quot;parameters error&quot;&#125;) 7.善用HTTP状态码HTTP状态码有很多，我们没有必要也不可能全部用上，常用如下： 200 StatusOK - 只有成功请求都返回200。 400 StatusBadRequest - 当出现参数不对，用户参数校验不通过时，给出该状态，并返回Error 401 StatusUnauthorized - 没有登陆&#x2F;经过认证 403 Forbidden - 服务端拒绝授权(如密码错误)，不允许访问 404 Not Found - 路径不存在 500 Internal Server Error - 所请求的服务器遇到意外的情况并阻止其执行请求 502 Bad Gateway - 网关或代理从上游接收到了无效的响应 503 Service Unavailable - 服务器尚未处于可以接受请求的状态 其中502,503，我们写程序时并不会明确去抛出。所以我们平常用6个状态码已经能很好的展示服务端状态了。 同时，我们将状态与返回值对应起来，200状态下，返回Data数据；其他状态返回Error。 8.API版本化正如Demo中所示，我们将路由分组到了/api/v1路径下面，版本化API。如果后续的服务端升级，但可能仍有很大部分客户端请求未升级，依然请求老版本的API，那么我们只需要增加/api/v2，然后在该路径下为已升级的客户端提供服务。这样，我们就做到了API的版本控制，可以平滑的从一个版本切换到另外一个版本。 123456v1 := r.Group(&quot;/api/v1&quot;)&#123; v1.POST(&quot;/login&quot;, HandleLogin) v1.GET(&quot;/articles&quot;, HandleGetArticles) v1.GET(&quot;/articles/:id/comments&quot;, HandleGetComments) // .... 9. 统一 ‘&#x2F;‘ 开头所以路由中，路径都以’&#x2F;‘开头，虽然框架会为我们做这件事，但还是建议统一加上。 10. 增加&#x2F;更新操作 返回资源对于POST,PUT操作，建议操作后，返回更新后的资源。 11. 使用HTTPS对于暴露出去的接口&#x2F;OpenAPI，一定使用HTTPS。一般时候，我们可以直接在服务前面架设一个WebServer，在WebServer内部署证书即可。当然，如果是直接由后端暴露出的接口，有必要直接在后端开启HTTPS！ 12. 规范的API文档对于我们这种前后端分离的架构，API文档是很重要。在Go中，我们很容易的能用swag结合代码注释自动生成API文档。 总结API写的好不好，重要的还是看是否遵循WEB标准和保持一致性，最终目的也是让这些API更清晰，易懂，安全，希望这些建议对你有所帮助。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"}]},{"title":"gin文件上传与下载","slug":"gin-file","date":"2018-10-12T08:17:50.000Z","updated":"2022-05-11T09:46:09.526Z","comments":true,"path":"2018/10/12/gin-file/","link":"","permalink":"https://timmy6.github.io/2018/10/12/gin-file/","excerpt":"","text":"Gin是用Go编写的web框架。性能还不错，而且使用比较简单，还支持RESTful API。 日常的使用中我们可能要处理一些文件的上传与下载，我这里简单总结一下。 单文件上传我们使用multipart/form-data格式上传文件，利用c.Request.FormFile解析文件。 123456789101112131415161718// HandleUploadFile 上传单个文件func HandleUploadFile(c *gin.Context) &#123; file, header, err := c.Request.FormFile(&quot;file&quot;) if err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;msg&quot;: &quot;文件上传失败&quot;&#125;) return &#125; content, err := ioutil.ReadAll(file) if err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;msg&quot;: &quot;文件读取失败&quot;&#125;) return &#125; fmt.Println(header.Filename) fmt.Println(string(content)) c.JSON(http.StatusOK, gin.H&#123;&quot;msg&quot;: &quot;上传成功&quot;&#125;)&#125; 我们上传文件可以看到。 我们已经看到文件上传成功，已经文件名字与内容。 多文件上传多文件的上传利用c.Request.MultipartForm解析。 12345678910111213141516171819202122232425262728293031// HandleUploadMutiFile 上传多个文件func HandleUploadMutiFile(c *gin.Context) &#123; // 限制放入内存的文件大小 err := c.Request.ParseMultipartForm(4 &lt;&lt; 20) if err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;msg&quot;: &quot;文件太大&quot;&#125;) return &#125; formdata := c.Request.MultipartForm files := formdata.File[&quot;file&quot;] for _, v := range files &#123; file, err := v.Open() if err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;msg&quot;: &quot;文件读取失败&quot;&#125;) return &#125; defer file.Close() content, err := ioutil.ReadAll(file) if err != nil &#123; c.JSON(http.StatusBadRequest, gin.H&#123;&quot;msg&quot;: &quot;文件读取失败&quot;&#125;) return &#125; fmt.Println(v.Filename) fmt.Println(string(content)) &#125; c.JSON(http.StatusOK, gin.H&#123;&quot;msg&quot;: &quot;上传成功&quot;&#125;)&#125; 多个文件，遍历文件内容即可读取。 利用c.Request.ParseMultipartForm()可设置上传文件的大小，这里限制了4MB。 c.Request.ParseMultipartForm()并不能限制上传文件的大小，只是限制了上传的文件读取到内存部分的大小，如果超过了就存入了系统的临时文件中。如果需要限制文件大小，需要使用github.com/gin-contrib/size中间件，如demo中使用r.Use(limits.RequestSizeLimiter(4 &lt;&lt; 20))限制最大4Mb。 我们看到 两个文件已经上传成功。 文件下载文件的下载主要是注意设置文件名，文件类型等。 123456789101112// HandleDownloadFile 下载文件func HandleDownloadFile(c *gin.Context) &#123; content := c.Query(&quot;content&quot;) content = &quot;hello world, 我是一个文件，&quot; + content c.Writer.WriteHeader(http.StatusOK) c.Header(&quot;Content-Disposition&quot;, &quot;attachment; filename=hello.txt&quot;) c.Header(&quot;Content-Type&quot;, &quot;application/text/plain&quot;) c.Header(&quot;Accept-Length&quot;, fmt.Sprintf(&quot;%d&quot;, len(content))) c.Writer.Write([]byte(content))&#125; 通过 Content-Disposition设置文件名字； Content-Type设置文件类型，可以到这里查阅； Accept-Length这个设置文件长度； c.Writer.Write写出文件。 成功下载可以看到：","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"}]},{"title":"gRPC在Go中的使用（三）gRPC实现TLS加密通信与流通信","slug":"grpc3","date":"2018-10-02T08:17:50.000Z","updated":"2022-05-11T09:46:03.455Z","comments":true,"path":"2018/10/02/grpc3/","link":"","permalink":"https://timmy6.github.io/2018/10/02/grpc3/","excerpt":"在前面的两篇博客中，我们已经知道了如何利用gRPC建立简单RPC通信。但这样简单的实现有时候满足不了我们的业务需求。在一些场景中我们需要防止数据被劫持，或是一些场景中我们希望客户端与服务器不是简单的一问一答，而是建立起一个流式的RPC通信，那么该怎么做到呢？","text":"在前面的两篇博客中，我们已经知道了如何利用gRPC建立简单RPC通信。但这样简单的实现有时候满足不了我们的业务需求。在一些场景中我们需要防止数据被劫持，或是一些场景中我们希望客户端与服务器不是简单的一问一答，而是建立起一个流式的RPC通信，那么该怎么做到呢？ TLS加密通信TLS加密无非就是认证客户端与服务器，如果对SSL&#x2F;TLS加密通信有所了解的童鞋都知道我们首先需要两张证书。 所以作为准备工作，我们首先要申请两张测试证书。一张客户端证书，一张服务器证书。 生成测试证书利用MySSL测试证书生成工具我们可以很简单的生成两张证书，如下所示： 如图，填入域名生成一张服务器证书，然后将私钥，证书链，根证书都下载下来，保存到文件。 同样，生成一张客户端证书并保存。 客户端与服务器TLS认证在gRPC通信中，我们完成服务器认证与客户端认证主要使用的是grpc下的credentials库。下面通过实例来看看怎么使用。 代码实例 服务端实现 1234567891011121314151617181920212223242526272829303132333435363738func main() &#123; lis, err := net.Listen(&quot;tcp&quot;, &quot;:8080&quot;) if err != nil &#123; panic(err) &#125; // 加载证书和密钥 （同时能验证证书与私钥是否匹配） cert, err := tls.LoadX509KeyPair(&quot;certs/test_server.pem&quot;, &quot;certs/test_server.key&quot;) if err != nil &#123; panic(err) &#125; // 将根证书加入证书池 // 测试证书的根如果不加入可信池，那么测试证书将视为不可惜，无法通过验证。 certPool := x509.NewCertPool() rootBuf, err := ioutil.ReadFile(&quot;certs/root.pem&quot;) if err != nil &#123; panic(err) &#125; if !certPool.AppendCertsFromPEM(rootBuf) &#123; panic(&quot;fail to append test ca&quot;) &#125; tlsConf := &amp;tls.Config&#123; ClientAuth: tls.RequireAndVerifyClientCert, Certificates: []tls.Certificate&#123;cert&#125;, ClientCAs: certPool, &#125; serverOpt := grpc.Creds(credentials.NewTLS(tlsConf)) grpcServer := grpc.NewServer(serverOpt) pb.RegisterHelloWorldServiceServer(grpcServer, &amp;SayHelloServer&#123;&#125;) log.Println(&quot;Server Start...&quot;) grpcServer.Serve(lis)&#125; 客户端实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func main() &#123; cert, err := tls.LoadX509KeyPair(&quot;certs/test_client.pem&quot;, &quot;certs/test_client.key&quot;) if err != nil &#123; panic(err) &#125; // 将根证书加入证书池 certPool := x509.NewCertPool() bs, err := ioutil.ReadFile(&quot;certs/root.pem&quot;) if err != nil &#123; panic(err) &#125; if !certPool.AppendCertsFromPEM(bs) &#123; panic(&quot;fail to append test ca&quot;) &#125; // 新建凭证 // ServerName 需要与服务器证书内的通用名称一致 transportCreds := credentials.NewTLS(&amp;tls.Config&#123; ServerName: &quot;server.razeen.me&quot;, Certificates: []tls.Certificate&#123;cert&#125;, RootCAs: certPool, &#125;) dialOpt := grpc.WithTransportCredentials(transportCreds) conn, err := grpc.Dial(&quot;localhost:8080&quot;, dialOpt) if err != nil &#123; log.Fatalf(&quot;Dial failed:%v&quot;, err) &#125; defer conn.Close() client := pb.NewHelloWorldServiceClient(conn) resp1, err := client.SayHelloWorld(context.Background(), &amp;pb.HelloWorldRequest&#123; Greeting: &quot;Hello Server 1 !!&quot;, Infos: map[string]string&#123;&quot;hello&quot;: &quot;world&quot;&#125;, &#125;) if err != nil &#123; log.Printf(&quot;%v&quot;, err) &#125; log.Printf(&quot;Resp1:%+v&quot;, resp1) resp2, err := client.SayHelloWorld(context.Background(), &amp;pb.HelloWorldRequest&#123; Greeting: &quot;Hello Server 2 !!&quot;, &#125;) if err != nil &#123; log.Printf(&quot;%v&quot;, err) &#125; log.Printf(&quot;Resp2:%+v&quot;, resp2)&#125; 从代码中，我们不难看出，主要是创建一个通信凭证(TransportCredentials)。利用credentials库的NewTLS方法从tls加载一个通信凭证用于通信。而在其中需要注意的是： 如果你使用的是自签发的证书，注意将根加入证书池。如果你使用的是可信CA签发的证书大部分不用添加，因为系统的可信CA库已经有了。如果没有成功添加, 在通信时会出现以下错误： rpc error: code &#x3D; Unavailable desc &#x3D; all SubConns are in TransientFailure, latest connection error: connection error: desc &#x3D; “transport: authentication handshake failed: x509: certificate signed by unknown authority” 或 rpc error: code &#x3D; Unavailable desc &#x3D; all SubConns are in TransientFailure, latest connection error: connection error: desc &#x3D; “transport: authentication handshake failed: remote error: tls: bad certificate” 客户端凭证内 ServerName 需要与服务器证书内的通用名称一致，如果不一致会出现如下错误： rpc error: code &#x3D; Unavailable desc &#x3D; all SubConns are in TransientFailure, latest connection error: connection error: desc &#x3D; “transport: authentication handshake failed: x509: certificate is valid for server.razeen.me, not xxxxx” 之后，我们就可安心的通信了，在私钥不泄漏的情况下，基本不再担心数据劫持问题了。 这里我想多说一句：我们经常在提交代码时会直接 git add . ，这是个不好的习惯，有时后我们会将一些不必要的文件提交上去，特别是一些证书、私钥、密码之类的文件。 流式的RPC通信流式PRC通信可以分为: 服务器端流式 RPC; 客户端发送请求到服务器，拿到一个流去读取返回的消息序列。 客户端读取返回的流，直到里面没有任何消息。如： 1rpc ListHello(HelloWorldRequest) returns (stream HelloWorldResponse) &#123;&#125; 客户端流式 RPC; 客户端写入一个消息序列并将其发送到服务器，同样也是使用流。一旦客户端完成写入消息，它等待服务器完成读取返回它的响应。如： 1rpc SayMoreHello(stream HelloWorldRequest) returns (HelloWorldResponse) &#123;&#125; 双向流式 RPC; 双方使用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务器可以以任意喜欢的顺序读写。如： 1rpc SayHelloChat(stream HelloWorldRequest) returns (stream HelloWorldRequest) &#123;&#125; 从上面的定义不难看出，用stream可以定义一个流式消息。下面我们就通过实例来演示一下流式通信的使用方法。 首先，我们将上面三个rpc server加入.proto , 并且生成新的.pb.go代码。 在生成的代码hello_world.pb.go中，我们可以看到客户端接口如下： 123456type HelloWorldServiceClient interface &#123; SayHelloWorld(ctx context.Context, in *HelloWorldRequest, opts ...grpc.CallOption) (*HelloWorldResponse, error) ListHello(ctx context.Context, in *HelloWorldRequest, opts ...grpc.CallOption) (HelloWorldService_ListHelloClient, error) SayMoreHello(ctx context.Context, opts ...grpc.CallOption) (HelloWorldService_SayMoreHelloClient, error) SayHelloChat(ctx context.Context, opts ...grpc.CallOption) (HelloWorldService_SayHelloChatClient, error)&#125; 服务端接口如下: 1234567// HelloWorldServiceServer is the server API for HelloWorldService service.type HelloWorldServiceServer interface &#123; SayHelloWorld(context.Context, *HelloWorldRequest) (*HelloWorldResponse, error) ListHello(*HelloWorldRequest, HelloWorldService_ListHelloServer) error SayMoreHello(HelloWorldService_SayMoreHelloServer) error SayHelloChat(HelloWorldService_SayHelloChatServer) error&#125; 在客户段的接口中，生成了HelloWorldService_XXXXClient接口类型。 在服务端的接口中，生成了HelloWorldService_XXXXServer接口类型。 我们再查看这些接口的定义，发现这这几个接口都是实现了以下几个方法中的数个： 1234Send(*HelloWorldRequest) errorRecv() (*HelloWorldRequest, error)CloseAndRecv() (*HelloWorldResponse, error)grpc.ClientStream 看其名字，我们不难知道，流式RPC的使用，或者说流的收发也就离不开这几个方法了。下面我们通过几个实例来验证一下。 在服务端，我们实现这三个接口。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 服务器端流式 RPC, 接收一次客户端请求，返回一个流func (s *SayHelloServer) ListHello(in *pb.HelloWorldRequest, stream pb.HelloWorldService_ListHelloServer) error &#123; log.Printf(&quot;Client Say: %v&quot;, in.Greeting) // 我们返回多条数据 stream.Send(&amp;pb.HelloWorldResponse&#123;Reply: &quot;ListHello Reply &quot; + in.Greeting + &quot; 1&quot;&#125;) time.Sleep(1 * time.Second) stream.Send(&amp;pb.HelloWorldResponse&#123;Reply: &quot;ListHello Reply &quot; + in.Greeting + &quot; 2&quot;&#125;) time.Sleep(1 * time.Second) stream.Send(&amp;pb.HelloWorldResponse&#123;Reply: &quot;ListHello Reply &quot; + in.Greeting + &quot; 3&quot;&#125;) time.Sleep(1 * time.Second) return nil&#125;// 客户端流式 RPC， 客户端流式请求，服务器可返回一次func (s *SayHelloServer) SayMoreHello(stream pb.HelloWorldService_SayMoreHelloServer) error &#123; // 接受客户端请求 for &#123; req, err := stream.Recv() if err == io.EOF &#123; break &#125; if err != nil &#123; return err &#125; log.Printf(&quot;SayMoreHello Client Say: %v&quot;, req.Greeting) &#125; // 流读取完成后，返回 return stream.SendAndClose(&amp;pb.HelloWorldResponse&#123;Reply: &quot;SayMoreHello Recv Muti Greeting&quot;&#125;)&#125;// 双向流式 RPCfunc (s *SayHelloServer) SayHelloChat(stream pb.HelloWorldService_SayHelloChatServer) error &#123; // 开一个协程去处理客户端数据 go func() &#123; for &#123; req, err := stream.Recv() if err == io.EOF &#123; break &#125; if err != nil &#123; return &#125; log.Printf(&quot;SayHelloChat Client Say: %v&quot;, req.Greeting) &#125; &#125;() // 向客户端写入多条数据 stream.Send(&amp;pb.HelloWorldRequest&#123;Greeting: &quot;SayHelloChat Server Say Hello 1&quot;&#125;) time.Sleep(1 * time.Second) stream.Send(&amp;pb.HelloWorldRequest&#123;Greeting: &quot;SayHelloChat Server Say Hello 2&quot;&#125;) time.Sleep(1 * time.Second) stream.Send(&amp;pb.HelloWorldRequest&#123;Greeting: &quot;SayHelloChat Server Say Hello 3&quot;&#125;) time.Sleep(1 * time.Second) return nil&#125; 之后我们就可以在客户端分别请求这几个rpc服务。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182 // 服务器端流式 RPC; // 我们向服务器SayHello recvListHello, err := client.ListHello(context.Background(), &amp;pb.HelloWorldRequest&#123;Greeting: &quot;Hello Server List Hello&quot;&#125;) if err != nil &#123; log.Fatalf(&quot;ListHello err: %v&quot;, err) &#125; // 服务器以流式返回 // 直到 err==io.EOF时，表示接收完毕。 for &#123; resp, err := recvListHello.Recv() if err == io.EOF &#123; break &#125; if err != nil &#123; log.Fatal(err) &#125; log.Printf(&quot;ListHello Server Resp: %v&quot;, resp.Reply) &#125;// Client Out:// 2018/08/06 01:27:55 ListHello Server Resp: ListHello Reply Hello Server List Hello 1// 2018/08/06 01:27:56 ListHello Server Resp: ListHello Reply Hello Server List Hello 2// 2018/08/06 01:27:57 ListHello Server Resp: ListHello Reply Hello Server List Hello 3// Server Out:// 2018/08/06 01:27:55 Client Say: Hello Server List Hello // 客户端流式 RPC; sayMoreClient, err := client.SayMoreHello(context.Background()) if err != nil &#123; log.Fatal(err) &#125; for i := 0; i &lt; 3; i++ &#123; sayMoreClient.Send(&amp;pb.HelloWorldRequest&#123;Greeting: fmt.Sprintf(&quot;SayMoreHello Hello Server %d&quot;, i)&#125;) &#125; sayMoreResp, err := sayMoreClient.CloseAndRecv() if err != nil &#123; log.Fatal(err) &#125; log.Printf(&quot;SayMoreHello Server Resp: %v&quot;, sayMoreResp.Reply)// Client Out:// 2018/08/06 01:31:11 SayMoreHello Server Resp: SayMoreHello Recv Muti Greeting// Server Out:// 2018/08/06 01:31:11 SayMoreHello Client Say: SayMoreHello Hello Server 0// 2018/08/06 01:31:11 SayMoreHello Client Say: SayMoreHello Hello Server 1// 2018/08/06 01:31:11 SayMoreHello Client Say: SayMoreHello Hello Server 2 // 双向流式 RPC; sayHelloChat, err := client.SayHelloChat(context.Background()) if err != nil &#123; log.Fatal(err) &#125; go func() &#123; for i := 0; i &lt; 3; i++ &#123; sayHelloChat.Send(&amp;pb.HelloWorldRequest&#123;Greeting: fmt.Sprintf(&quot;SayHelloChat Hello Server %d&quot;, i)&#125;) &#125; &#125;() for &#123; resp, err := sayHelloChat.Recv() if err == io.EOF &#123; break &#125; if err != nil &#123; log.Fatal(err) &#125; log.Printf(&quot;SayHelloChat Server Say: %v&quot;, resp.Greeting) &#125;// Client Out:// 2018/08/06 01:31:11 SayHelloChat Server Say: SayHelloChat Server Say Hello 1// 2018/08/06 01:31:12 SayHelloChat Server Say: SayHelloChat Server Say Hello 2// 2018/08/06 01:31:13 SayHelloChat Server Say: SayHelloChat Server Say Hello 3// Server Out:// 2018/08/06 01:31:11 SayHelloChat Client Say: SayHelloChat Hello Server 0// 2018/08/06 01:31:11 SayHelloChat Client Say: SayHelloChat Hello Server 1// 2018/08/06 01:31:11 SayHelloChat Client Say: SayHelloChat Hello Server 2 看了实例，是不是觉得很简单～。三种方式大同小异，只要掌握了怎么去收发流，怎么判断流的结束，基本就可以了。 好了，gRPC在Go中的使用三篇文章到这里也就结束了，如果博客中有错误或者你还有想知道的，记得留言哦。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"}]},{"title":"gRPC在Go中的使用（二）gRPC实现简单通讯","slug":"grpc2","date":"2018-09-25T07:27:50.000Z","updated":"2022-05-11T09:45:57.735Z","comments":true,"path":"2018/09/25/grpc2/","link":"","permalink":"https://timmy6.github.io/2018/09/25/grpc2/","excerpt":"Desc:gRPC实现简单通讯,Google 开源 RPC 框架 gRPC 初探 在上一篇中，我们用protobuf定义了两个消息HelloWorldRequest与HelloWorldResponse以及一个HelloWorldService服务。同时，我们还生成了相应的go代码.pb.go。 那么客户端与服务端怎么去通过这些接口去完成通讯呢？下面我们一起实现一个简单的gRPC通讯。","text":"Desc:gRPC实现简单通讯,Google 开源 RPC 框架 gRPC 初探 在上一篇中，我们用protobuf定义了两个消息HelloWorldRequest与HelloWorldResponse以及一个HelloWorldService服务。同时，我们还生成了相应的go代码.pb.go。 那么客户端与服务端怎么去通过这些接口去完成通讯呢？下面我们一起实现一个简单的gRPC通讯。 在RPC通讯中，客户端使用存根(SayHelloWorld)发送请求到服务器并且等待响应返回，整个过程就像我们平常函数调用一样。 123service HelloWorldService &#123; rpc SayHelloWorld(HelloWorldRequest) returns (HelloWorldResponse)&#123;&#125;&#125; 那么接下来，我们先创建一个服务端。 创建服务端在生成的hello_world.pb.go中，已经为我们生成了服务端的接口： 1234// HelloWorldServiceServer is the server API for HelloWorldService service.type HelloWorldServiceServer interface &#123; SayHelloWorld(context.Context, *HelloWorldRequest) (*HelloWorldResponse, error)&#125; 在服务端我们首先要做的就是实现这个接口。 12345678910111213141516171819202122type SayHelloServer struct&#123;&#125;func (s *SayHelloServer) SayHelloWorld(ctx context.Context, in *pb.HelloWorldRequest) (res *pb.HelloWorldResponse, err error) &#123; log.Printf(&quot;Client Greeting:%s&quot;, in.Greeting) log.Printf(&quot;Client Info:%v&quot;, in.Infos) var an *any.Any if in.Infos[&quot;hello&quot;] == &quot;world&quot; &#123; an, err = ptypes.MarshalAny(&amp;pb.HelloWorld&#123;Msg: &quot;Good Request&quot;&#125;) &#125; else &#123; an, err = ptypes.MarshalAny(&amp;pb.Error&#123;Msg: []string&#123;&quot;Bad Request&quot;, &quot;Wrong Info Msg&quot;&#125;&#125;) &#125; if err != nil &#123; return &#125; return &amp;pb.HelloWorldResponse&#123; Reply: &quot;Hello World !!&quot;, Details: []*any.Any&#123;an&#125;, &#125;, nil&#125; 简单如上面的几行，实现了这个接口我们只需要创建一个结构SayHelloServer,同时实现HelloWorldServiceServer的所有方法即可。 这里为了演示效果我打印了一些数据，同时利用any.Any在不同的情况下返回不同的类型数据。 当然，只是现实了接口还不够，我们还需要启动一个服务，这样客户端才能使用该服务。启动服务很简单，就像我们平常启用一个Server一样。 1234567891011121314func main() &#123; // 我们首先须监听一个tcp端口 lis, err := net.Listen(&quot;tcp&quot;, &quot;:8080&quot;) if err != nil &#123; panic(err) &#125; // 新建一个grpc服务器 grpcServer := grpc.NewServer() // 向grpc服务器注册SayHelloServer pb.RegisterHelloWorldServiceServer(grpcServer, &amp;SayHelloServer&#123;&#125;) // 启动服务 grpcServer.Serve(lis)&#125; 从上面的代码，我们可以看到，简单的4步即可启动一个服务。 监听一个服务端口，供客户端调用； 创建一个grpc服务器，当然这里可以设置授权认证,这个在下一篇中我们将详细介绍； 注册服务，其实是调用生存的.pb.go中的RegisterHelloWorldServiceServer方法，将我们这里实现的SayHelloServer加入到该服务中。 启动服务，等待客户端连接。 我们 go run server.go,无任何报错，这样一个简单的grpc服务的服务端就准备就绪了。接下来我们看看客户端。 创建客户端例如： 1234567891011121314151617181920212223242526func main() &#123; // 创建一个 gRPC channel 和服务器交互 conn, err := grpc.Dial(&quot;localhost:8080&quot;, grpc.WithInsecure()) if err != nil &#123; log.Fatalf(&quot;Dial failed:%v&quot;, err) &#125; defer conn.Close() // 创建客户端 client := pb.NewHelloWorldServiceClient(conn) // 直接调用 resp1, err := client.SayHelloWorld(context.Background(), &amp;pb.HelloWorldRequest&#123; Greeting: &quot;Hello Server 1 !!&quot;, Infos: map[string]string&#123;&quot;hello&quot;: &quot;world&quot;&#125;, &#125;) log.Printf(&quot;Resp1:%+v&quot;, resp1) resp2, err := client.SayHelloWorld(context.Background(), &amp;pb.HelloWorldRequest&#123; Greeting: &quot;Hello Server 2 !!&quot;, &#125;) log.Printf(&quot;Resp2:%+v&quot;, resp2)&#125; 客户端的实现比服务端更简洁，三步即可。 创建一个 gRPC channel 和服务器交互。这里也是可以设置授权认证的； 创建一个客户端去执行RPC。用到的也是.pb.go内的NewHelloWorldServiceClient方法； 像函数调用一样去调用RPC服务。 我直接RUN起来，如下，我们可以看到客户端发送到服务的消息以及服务端对不同消息的不同回复。 那么到这里，我们简单的实现了一个gRPC通讯。但很多时候，我们可能希望客户端与服务器能更安全的通信，或者客户端与服务器不再是一种固定的结构的传输，需要流式的去处理一些问题等等。针对这些问题，在下一篇博客中，我将结合实例详细说明。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"}]},{"title":"gRPC在Go中的使用（一）Protocol Buffers语法与相关使用","slug":"grpc1","date":"2018-09-20T06:07:50.000Z","updated":"2022-05-11T09:45:51.566Z","comments":true,"path":"2018/09/20/grpc1/","link":"","permalink":"https://timmy6.github.io/2018/09/20/grpc1/","excerpt":"Desc:protobuf语法介绍，怎么写proto文件，grpc的使用入门 在gRPC官网用了一句话来介绍:“一个高性能、开源的通用RPC框架”，同时介绍了其四大特点： 定义简单 支持多种编程语言多种平台 快速启动和缩放 双向流媒体和集成身份验证","text":"Desc:protobuf语法介绍，怎么写proto文件，grpc的使用入门 在gRPC官网用了一句话来介绍:“一个高性能、开源的通用RPC框架”，同时介绍了其四大特点： 定义简单 支持多种编程语言多种平台 快速启动和缩放 双向流媒体和集成身份验证 在gRPC在go中使用系列中，关于其简介与性能我就不多介绍，相信在社区也有很多关于这些的讨论。这里我主要从三个层次来总结我以往在Go中使用gRPC的一些经验，主要分为： Protocol Buffers语法与相关使用 gRPC实现简单通讯 gRPC服务认证与双向流通讯 *注:下面Protocol Buffers简写protobuf. 这篇我们先介绍protobuf的相关语法、怎么书写.proto文件以及go代码生成。 简介要熟练的使用GRPC，protobuf的熟练使用必不可少。 gRPC使用protobuf来定义服务。protobuf是由Google开发的一种数据序列化协议，可以把它想象成是XML或JSON格式，但更小，更快更简洁。而且一次定义，可生成多种语言的代码。 定义首先我们需要编写一些.proto文件，定义我们在程序中需要处理的结构化数据。我们直接从一个实例开始讲起，下面是一个proto文件： 123456789101112131415161718192021syntax = &quot;proto3&quot;;option go_package = &quot;github.com/razeencheng/demo-go/grpc/demo1/helloworld&quot;;package helloworld;import &quot;github.com/golang/protobuf/ptypes/any/any.proto&quot;;message HelloWorldRequest &#123; string greeting = 1; map&lt;string, string&gt; infos = 2;&#125;message HelloWorldResponse &#123; string reply = 1; repeated google.protobuf.Any details = 2;&#125;service HelloWorldService &#123; rpc SayHelloWorld(HelloWorldRequest) returns (HelloWorldResponse)&#123;&#125;&#125; 版本文件的开头syntax=&quot;proto3&quot;也就指明版本，主要有proto2与proto3,他们在语法上有一定的差异，我这里主要使用的是后者。 包名第二行，指定生成go文件的包名，可选项，默认使用第三行包名。 第三行，包名。 导包第四行，类似你写go一样，protobuf也可以导入其他的包。 消息定义后面message开头的两个结构就是我们需要传递的消息类型。所有的消息类型都是以message开始，然后定义类型名称。结构内字段的定义为字段规则 字段类型 字段名=字段编号 字段规则主要有 singular和repeated。如其中greeting和reply的字段规则为singular,允许该消息中出现0个或1个该字段(但不能超过一个)，而像details字段允许重复任意次数。其实对应到go里面也就是基本类型和切片类型。 字段类型，下表是proto内类型与go类型的对应表。 .proto Type Notes Go Type double float64 float float32 int32 使用可变长度编码。 无效编码负数 - 如果您的字段可能具有负值， 请改用sint32。 int32 int64 使用可变长度编码。 无效编码负数 - 如果您的字段可能具有负值，请改用sint64。 int64 uint32 使用可变长度编码。 uint32 uint64 使用可变长度编码。 uint64 sint32 使用可变长度编码。 带符号的int值。 这些比常规的int32更有效地编码负数。 int32 sint64 使用可变长度编码。 带符号的int值。 这些比常规的int64更有效地编码负数。 int64 fixed32 总是四个字节。 如果值通常大于228，则比uint32效率更高。 uint32 fixed64 总是八个字节。 如果值通常大于256，则会比uint64更高效。 uint64 sfixed32 总是四个字节。 int32 sfixed64 总是八个字节。 int64 bool bool string 字符串必须始终包含UTF-8编码或7位ASCII文本。 string bytes 可能包含任何字节序列。 []byte 看到这里你也许会疑惑，go里面的切片，map，接口等类型我怎么定义呢？别急，下面一一替你解答。 1.map类型，HelloWorldRequest的infos就是一个map类型，它的结构为map&lt;key_type, value_type&gt; map_field = N 但是在使用的时候你需要注意map类型不能repetead。 2.切片类型，我们直接定义其规则为repeated就可以了。就像HelloWorldResponse中的details字段一样，它就是一个切片类型。那么你会问了它是什么类型的切片？这就看下面了~ 3.接口类型在proto中没有直接实现，但在google&#x2F;protobuf&#x2F;any.proto中定义了一个google.protobuf.Any类型，然后结合protobuf&#x2F;go也算是曲线救国了~ 字段编号 最后的1，2代表的是每个字段在该消息中的唯一标签，在与消息二进制格式中标识这些字段，而且当你的消息在使用的时候该值不能改变。1到15都是用一个字节编码的，通常用于标签那些频繁发生修改的字段。16到2047用两个字节编码，最大的是2^29-1(536,870,911)，其中19000-19999为预留的，你也不可使用。 服务定义如果你要使用RPC(远程过程调用)系统的消息类型，那就需要定义RPC服务接口，protobuf编译器将会根据所选择的不同语言生成服务接口代码及存根。就如： 123service HelloWorldService &#123; rpc SayHelloWorld(HelloWorldRequest) returns (HelloWorldResponse)&#123;&#125;&#125; protobuf编译器将产生一个抽象接口HelloWorldService以及一个相应的存根实现。存根将所有的调用指向RpcChannel(SayHelloWorld)，它是一个抽象接口，必须在RPC系统中对该接口进行实现。具体如何使用，将在下一篇博客中详细介绍。 生成Go代码安装protoc首先要安装protoc,可直接到这里下载二进制安装到 $PATH里面，也可以直接下载源码编译。除此之外，你还需要安装go的proto插件protoc-gen-go。 12345// mac terminalgo get -u github.com/golang/protobuf/&#123;proto,protoc-gen-go&#125;// win powershellgo get -u github.com/golang/protobuf/protogo get -u github.com/golang/protobuf/protoc-gen-go 生成go代码接下来，使用protoc命令即可生成。 1234### mac terminalprotoc -I $&#123;GOPATH&#125;/src --go_out=plugins=grpc:$&#123;GOPATH&#125;/src $&#123;GOPATH&#125;/src/github.com/razeencheng/demo-go/grpc/demo1/helloworld/hello_world.proto### win powershellprotoc -I $env:GOPATH\\src --go_out=plugins=grpc:$env:GOPATH\\src $env:GOPATH\\src\\github.com\\razeencheng\\demo-go\\grpc\\demo1\\helloworld\\hello_world.proto 如上所示 -I指定搜索proto文件的目录,--go_out=plugins=grpc:指定生成go代码的文件夹，后面就是需要生成的proto文件路径。 注意： 如果你使用到了其他包的结构，-I需要将该资源包括在内。 例如我导入了github.com/golang/protobuf/ptypes/any/any.proto 我首先需要 go get -u github.com/golang/protobuf获取该包，然后在使用时资源路径(-I)直接为GOPATH\\src。 最后生成的hello-world.pb.go文件。内容大概如下图所示 图中我们可以看到两个message对应生成了两个结构体，同时会生成一些序列化的方法等。 而定义的service则是生成了对应的client与server接口，那么这到底有什么用？怎么去用呢？将为你详细讲解~ 看到这，我们简单的了解一下protobuf语法，如果你想了解更多，点这里看官方文档。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"}]},{"title":"怎么写Go基准测试（性能测试)","slug":"benchmark","date":"2018-09-15T03:07:50.000Z","updated":"2022-05-11T09:45:41.231Z","comments":true,"path":"2018/09/15/benchmark/","link":"","permalink":"https://timmy6.github.io/2018/09/15/benchmark/","excerpt":"或许你经常会思考这样的问题，我用不同的方法实现了同样的效果，哪个会更快？哪个内存消耗更小？这时候你一个简单的基准测试就能解决你的疑惑。","text":"或许你经常会思考这样的问题，我用不同的方法实现了同样的效果，哪个会更快？哪个内存消耗更小？这时候你一个简单的基准测试就能解决你的疑惑。 Go向来是以工具丰富而著称的，在学习Go的过程中，你会发现无论是写一个单元测试，还是做一些竞争检测都能很快的上手，而且用的很痛快。当然，接下来要说的基准测试也一样。 基准测试工具就在Go的测试包中，下面就用一个例子来介绍。 举个栗子由于一些场景需要，我需要将[]byte输出16进制字符。 有时候我会这么写: 1fmt.Sprintf(&quot;%x&quot;, b) 但有时候我会这么写： 1hex.EncodeToString(b) 但到底哪种写法更好呢？今天我就来比较一下。 直接写了个main.go 1234567func EncodeA(b []byte) string &#123; return fmt.Sprintf(&quot;%x&quot;, b)&#125;func EncodeB(b []byte) string &#123; return hex.EncodeToString(b)&#125; 再写个测试main_test.go 12345678910111213var buf = []byte(&quot;skdjadialsdgasadasdhsakdjsahlskdjagloqweiqwo&quot;)func BenchmarkEncodeA(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; EncodeA(buf) &#125;&#125;func BenchmarkEncodeB(b *testing.B) &#123; for i := 0; i &lt; b.N; i++ &#123; EncodeB(buf) &#125;&#125; 就这么简单，我们的基本测试就写完了。从我的写法中你也许就知道： 和单元测试一样，都写在_test.go文件中； 需要以Benchmark为函数名开头； 和单元测试类似，必须接受一个*testing.B参数； 被测试代码放在一个循环中。 我们直接跑一下。当然我们也是用go test来执行测试，简单的测试只要带上-bench=.就可以了。 12345678$ go test -bench=.goos: darwingoarch: amd64pkg: github.com/razeencheng/demo-go/benchmarkBenchmarkEncodeA-8 5000000 265 ns/opBenchmarkEncodeB-8 10000000 161 ns/opPASSok github.com/razeencheng/demo-go/benchmark 3.397s 前两行是平台信息，第三行包名。第四、五行就是测试的结果了。 BenchmarkEncodeA-8 ,BenchmarkEncodeB-8 基准测试函数名-GOMAXPROCS 5000000,10000000 被测试的函数执行次数，也就是EncodeA()被执行了5000000次，EncodeB()被执行了10000000次，也就是b.N的值了。 265 ns/op,161 ns/op表示每次调用被测试函数花费的时间。 从花费的时间上来看，我们知道EncodeB()要快一点。 更多你以为就这么简单的结束了么？NONONO。 -bench 可接收一个有效的正则表达式来执行符合条件的测试函数。当你的函数很多时，可以用它来过滤. 1234567$ go test -bench=BenchmarkEncodeAgoos: darwingoarch: amd64pkg: github.com/razeencheng/demo-go/benchmarkBenchmarkEncodeA-8 5000000 256 ns/opPASSok github.com/razeencheng/demo-go/benchmark 1.575s -benchmem可以查看内存分配 12345678$ go test -bench=. -benchmemgoos: darwingoarch: amd64pkg: github.com/razeencheng/demo-go/benchmarkBenchmarkEncodeA-8 5000000 261 ns/op 128 B/op 2 allocs/opBenchmarkEncodeB-8 10000000 162 ns/op 192 B/op 2 allocs/opPASSok github.com/razeencheng/demo-go/benchmark 3.408s 其中B/op 表示每次执行会分配多少内存，allocs/op表示每次执行会发生多少次内存分配。 -benchtime指定每个测试执行的时间。默认1s,当你的函数比较耗时你可以设置更长一点。因为b.N是与这个时间有关的。 当你的运行时间没达到-benchtime制定的时间前，b.N将以1，2，5，10，20，50…增加，然后重新运行测试代码。 12345678$ go test -bench=. -benchmem -benchtime=5sgoos: darwingoarch: amd64pkg: github.com/razeencheng/demo-go/benchmarkBenchmarkEncodeA-8 30000000 254 ns/op 128 B/op 2 allocs/opBenchmarkEncodeB-8 50000000 160 ns/op 192 B/op 2 allocs/opPASSok github.com/razeencheng/demo-go/benchmark 16.113s -count指定每个测试执行的次数。 123456789101112$ go test -bench=. -benchmem -count=3goos: darwingoarch: amd64pkg: github.com/razeencheng/demo-go/benchmarkBenchmarkEncodeA-8 5000000 256 ns/op 128 B/op 2 allocs/opBenchmarkEncodeA-8 5000000 255 ns/op 128 B/op 2 allocs/opBenchmarkEncodeA-8 5000000 253 ns/op 128 B/op 2 allocs/opBenchmarkEncodeB-8 10000000 163 ns/op 192 B/op 2 allocs/opBenchmarkEncodeB-8 10000000 160 ns/op 192 B/op 2 allocs/opBenchmarkEncodeB-8 10000000 160 ns/op 192 B/op 2 allocs/opPASSok github.com/razeencheng/demo-go/benchmark 9.984s 我常用的也就这些了。 但对于testing.B来说，它拥有了testing.T的全部接口，所以Fail,Skip,Error这些都可以用，而且还增加了 SetBytes( i uint64) 统计内存消耗。 SetParallelism(p int) 制定并行数目。 StartTimer / StopTimer / ResertTimer 操作计时器。 你可以按需使用。 注意b.N为一个自增字段，谨慎用它做函数参数。","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"}]},{"title":"变量声明","slug":"var_dec","date":"2018-09-12T03:07:50.000Z","updated":"2022-05-11T10:35:36.885Z","comments":true,"path":"2018/09/12/var_dec/","link":"","permalink":"https://timmy6.github.io/2018/09/12/var_dec/","excerpt":"","text":"概述在声明变量之前，咱们先了解下变量的数据类型，这篇文章主要涉及 字符串、布尔、数字，其他类型后面开篇再说。 数据类型字符串string 只能用一对双引号（””）或反引号（&#96;&#96;）括起来定义，不能用单引号（’’）定义！ 布尔bool 只有 true 和 false，默认为 false。 数字整型 int8 uint8 int16 uint16 int32 uint32 int64 uint64 int uint，具体长度取决于 CPU 位数。 浮点型 float32 float64 常量声明常量，在程序编译阶段就确定下来的值，而程序在运行时无法改变该值。 单个常量声明 第一种：const 变量名称 数据类型 &#x3D; 变量值 如果不赋值，使用的是该数据类型的默认值。 第二种：const 变量名称 &#x3D; 变量值 根据变量值，自行判断数据类型。 多个常量声明 第一种：const 变量名称,变量名称 … ,数据类型 &#x3D; 变量值,变量值 … 第二种：const 变量名称,变量名称 … &#x3D; 变量值,变量值 … 测试代码 1234567891011121314151617181920//demo_1.gopackage mainimport ( &quot;fmt&quot;)func main() &#123; const name string = &quot;Tom&quot; fmt.Println(name) const age = 30 fmt.Println(age) const name_1, name_2 string = &quot;Tom&quot;, &quot;Jay&quot; fmt.Println(name_1, name_2) const name_3, age_1 = &quot;Tom&quot;, 30 fmt.Println(name_3, age_1)&#125; 运行结果： 变量声明单个变量声明 第一种：var 变量名称 数据类型 &#x3D; 变量值 如果不赋值，使用的是该数据类型的默认值。 第二种：var 变量名称 &#x3D; 变量值 根据变量值，自行判断数据类型。 第三种：变量名称 :&#x3D; 变量值 省略了 var 和数据类型，变量名称一定要是未声明过的。 多个变量声明 第一种：var 变量名称,变量名称 … ,数据类型 &#x3D; 变量值,变量值 … 第二种：var 变量名称,变量名称 … &#x3D; 变量值,变量值 … 第三种：变量名称,变量名称 … :&#x3D; 变量值,变量值 … 测试代码 12345678910111213141516171819202122//demo_2.gopackage mainimport ( &quot;fmt&quot;)func main() &#123; var age_1 uint8 = 31 var age_2 = 32 age_3 := 33 fmt.Println(age_1, age_2, age_3) var age_4, age_5, age_6 int = 31, 32, 33 fmt.Println(age_4, age_5, age_6) var name_1, age_7 = &quot;Tom&quot;, 30 fmt.Println(name_1, age_7) name_2, is_boy, height := &quot;Jay&quot;, true, 180.66 fmt.Println(name_2, is_boy, height)&#125; 运行结果： 输出方法fmt.Print：输出到控制台（仅只是输出） fmt.Println：输出到控制台并换行 fmt.Printf：仅输出格式化的字符串和字符串变量（整型和整型变量不可以） fmt.Sprintf：格式化并返回一个字符串，不输出。 测试代码 1234567891011121314//demo_3.gopackage mainimport ( &quot;fmt&quot;)func main() &#123; fmt.Print(&quot;输出到控制台不换行&quot;) fmt.Println(&quot;---&quot;) fmt.Println(&quot;输出到控制台并换行&quot;) fmt.Printf(&quot;name=%s,age=%d\\n&quot;, &quot;Tom&quot;, 30) fmt.Printf(&quot;name=%s,age=%d,height=%v\\n&quot;, &quot;Tom&quot;, 30, fmt.Sprintf(&quot;%.2f&quot;, 180.567))&#125; 运行结果：","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"}]},{"title":"你好，Go语言","slug":"hello-wrold","date":"2018-09-11T03:07:50.000Z","updated":"2022-05-11T09:47:23.542Z","comments":true,"path":"2018/09/11/hello-wrold/","link":"","permalink":"https://timmy6.github.io/2018/09/11/hello-wrold/","excerpt":"","text":"你好，Go语言 Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。 因工作需要，准备入坑，先从环境安装开始，输出一个 Hello World。 环境安装目标 安装完成并运行 Hello World 成功！ 本机系统：macOS High Sierra 10.13.4 Go 版本：1.12 方式一： 通过 brew 安装 1brew install go 根据提示进行安装吧，我使用的 方式二 进行安装的。 方式二： 通过安装包安装 地址：https://dl.google.com/go/go1.12.darwin-amd64.pkg 下载之后直接点击安装，一步步继续即可。 配置环境变量 123456vi ~/.bashrc//新增export GOROOT=/usr/local/goexport GOPATH=/Users/username/go/code //代码目录，自定义即可export PATH=$PATH:$GOPATH/bin 及时生效，请执行命令：source ~&#x2F;.bashrc 如果命令行使用的是zsh，请修改 .zshrc 文件。 123456vi ~/.zshrc//新增export GOROOT=/usr/local/goexport GOPATH=/Users/username/go/code //自定义代码目录export PATH=$PATH:$GOPATH/bin 及时生效，请执行命令：source ~&#x2F;.zshrc 验证是否安装成功，命令行下执行： 目录结构bin 存放编译后可执行的文件。 pkg 存放编译后的应用包。 src 存放应用源代码。 例如： 123456├─ code -- 代码根目录│ ├─ bin│ ├─ pkg│ ├─ src│ ├── hello│ ├── hello.go Hello World 代码 1234567891011//在 hello 目录下创建 hello.gopackage mainimport ( &quot;fmt&quot;)func main() &#123; fmt.Println(&quot;Hello World!&quot;)&#125; 命令行执行： 命令查看完整的命令： go build hello 在src目录或hello目录下执行 go build hello，只在对应当前目录下生成文件。 go install hello 在src目录或hello目录下执行 go install hello，会把编译好的结果移动到 $GOPATH&#x2F;bin。 go run hello 在src目录或hello目录下执行 go run hello，不生成任何文件只运行程序。 go fmt hello 在src目录或hello目录下执行 go run hello，格式化代码，将代码修改成标准格式。 其他命令，需要的时候再进行研究吧。 开发工具GoLand GoLand 是 JetBrains 公司推出的 Go 语言集成开发环境，与我们用的 WebStorm、PhpStorm、PyCharm 是一家，同样支持 Windows、Linux、macOS 等操作系统。 下载地址：https://www.jetbrains.com/go/ 软件是付费的，不过想想办法，软件可以永久激活的。 学习网址 Go语言：https://golang.org/ Go语言中文网：https://studygolang.com/ Go语言包管理：https://gopm.io/","categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"Go基础","slug":"Go基础","permalink":"https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"}]}],"categories":[{"name":"Go开发","slug":"Go开发","permalink":"https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"}],"tags":[{"name":"gin框架","slug":"gin框架","permalink":"https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"},{"name":"gRPC","slug":"gRPC","permalink":"https://timmy6.github.io/tags/gRPC/"},{"name":"Go基础","slug":"Go基础","permalink":"https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"}]}