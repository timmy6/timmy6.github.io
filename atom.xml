<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://timmy6.github.io/atom.xml" rel="self"/>
  
  <link href="https://timmy6.github.io/"/>
  <updated>2022-05-17T07:03:05.181Z</updated>
  <id>https://timmy6.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>rabbitmq基本操作</title>
    <link href="https://timmy6.github.io/2020/07/05/rabbitmq%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>https://timmy6.github.io/2020/07/05/rabbitmq%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2020-07-05T14:15:10.000Z</published>
    <updated>2022-05-17T07:03:05.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.toutiao.com/i6826959307888656899/">https://www.toutiao.com/i6826959307888656899/</a></li><li><a href="https://www.cnblogs.com/Zhangcsc/p/11739754.html">https://www.cnblogs.com/Zhangcsc/p/11739754.html</a></li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="交换机exchange"><a href="#交换机exchange" class="headerlink" title="交换机exchange"></a>交换机exchange</h3><p>接收消息，并根据路由键转发消息到所绑定的队列</p><h3 id="交换机的4种类型"><a href="#交换机的4种类型" class="headerlink" title="交换机的4种类型"></a>交换机的4种类型</h3><ul><li>topic 对路由键进行模式匹配，将消息转发到匹配上的队列上，其中<code>*</code> 表示匹配任意一个单词，<code>#</code> 表示匹配任意一个或多个单词，使用<code>.</code>分割单词，例如路由键<code>quick.orange.rabbit</code>，可以匹配上绑定键<code>quick.#</code>,<code>*.orange.rabbit</code></li><li>direct 要求路由键必须与绑定key完全匹配，这样才会被转发对应的队列</li><li>fanout 不处理路由键。你只需要简单的将队列绑定到交换机上，一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上</li><li>headers 不处理路由键，而是根据消息内容中的headers属性进行匹配</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><code>basic.consume</code>持续订阅,自动接收下一条消息</li><li><code>basic.get</code>获取单条消息</li><li><code>basic.ack</code>确认收到消息,或者消费者在订阅到队列的时候就将<code>auto ack</code>设置为true</li><li><code>basic.reject</code>丢弃消息,如果将<code>reject</code>命令的<code>requeue</code>参数设置为true的话,<code>rabbitmq</code>会将消息投递给下个消费者,否则会立即从队列删除消息并且存放到死信队列</li><li><code>queue.declare</code>创建队列,如果不指定名称则随机分配一个名称,作为匿名队列<ul><li><code>exclusive</code>限制只有由一个消费者够消费</li><li><code>auto-delete</code>当最后一个消费者取消订阅时候,队列会自动移除</li><li>当重复声明一个已存在的队列,若声明参数完全匹配现存队列,rabbit什么都不会做并返回成功</li><li>设置<code>queue.declare</code>的<code>passive</code>为<code>true</code>时,如果队列已存在,<code>queue.declare</code>返回成功,如果队列不存在,<code>queue.declare</code>命令不会创建队列而会返回一个错误</li></ul></li></ul><h2 id="应该由生成者还是消费者创建队列呢"><a href="#应该由生成者还是消费者创建队列呢" class="headerlink" title="应该由生成者还是消费者创建队列呢?"></a>应该由生成者还是消费者创建队列呢?</h2><p>假设由消费者创建队列,若生成者先投递消息,此时还没有消费者,这个时候消息会怎么样?当有消费者了并且创建队列了会怎么样?<br>答: 消息会提示发送成功,但是事实上它已经丢失了,即时消费者创建队列了也不能消费之前的发布的消息,最好的做法是消费者和生成者都要尝试创建队列,并且绑定队列和交换器</p><h2 id="生产消息"><a href="#生产消息" class="headerlink" title="生产消息"></a>生产消息</h2><ul><li>AMQP_NOPARAM 无</li><li>AMQP_DURABLE 持久化exchange</li><li>AMQP_PASSIVE 声明一个已存在的交换器的，如果不存在将抛出异常，这个一般用在consume端。因为一般produce端创建,在consume端建议设置成AMQP_PASSIVE,防止consume创建exchange</li><li>AMQP_AUTODELETE 该交换器将在没有消息队列绑定时自动删除</li></ul><h2 id="为什么要用信道channel"><a href="#为什么要用信道channel" class="headerlink" title="为什么要用信道channel"></a>为什么要用信道channel</h2><p>为了减少tcp连接开销,多个通道可以共享tcp连接???</p><h2 id="什么是消息幂等性？"><a href="#什么是消息幂等性？" class="headerlink" title="什么是消息幂等性？"></a>什么是消息幂等性？</h2><p>无论一条消息被消费多少次，消费的结果都是一样的。</p><h2 id="什么是confirm消息确认机制？"><a href="#什么是confirm消息确认机制？" class="headerlink" title="什么是confirm消息确认机制？"></a>什么是confirm消息确认机制？</h2><p>生成者生成消息，Broker收到消息就会给生产者一个应答，生产者接受应答来确认broker是否收到消息。</p><h3 id="如何实现confirm确认消息？"><a href="#如何实现confirm确认消息？" class="headerlink" title="如何实现confirm确认消息？"></a>如何实现confirm确认消息？</h3><ul><li>在Channel上开启确认模式：<code>channel.confirmSelect()</code></li><li>在channel上添加监听：<code>addConfirmListener</code>，监听成功和失败的结果，具体结果对消息进行重新发送或者记录日志。</li></ul><h2 id="如何生成的消息匹配不到队列会怎么样？"><a href="#如何生成的消息匹配不到队列会怎么样？" class="headerlink" title="如何生成的消息匹配不到队列会怎么样？"></a>如何生成的消息匹配不到队列会怎么样？</h2><p>如果<code>Mandatory</code>设置为true，如果找不到队列，则broker会调用<code>basic.return</code>方法将消息返还给生产者;当<code>mandatory</code>设置为false时，出现上述情况broker会直接将消息丢弃;通俗的讲，mandatory标志告诉broker代理服务器至少将消息route到一个队列中，否则就将消息return给发送者;<br><strong>Mandatory设置为true只有在confirm模式有效</strong></p><h3 id="如何获得被return回来的消息？"><a href="#如何获得被return回来的消息？" class="headerlink" title="如何获得被return回来的消息？"></a>如何获得被return回来的消息？</h3><p>通过为channel信道设置<code>ReturnListener</code>监听器来实现</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="keyword">__DIR__</span> . <span class="string">&#x27;/vendor/autoload.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Connection</span>\<span class="title">AMQPStreamConnection</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Message</span>\<span class="title">AMQPMessage</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$connection</span> = <span class="keyword">new</span> <span class="title class_">AMQPStreamConnection</span>(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">5672</span>, <span class="string">&#x27;guest&#x27;</span>, <span class="string">&#x27;guest&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="variable">$channel</span> = <span class="variable">$connection</span>-&gt;<span class="title function_ invoke__">channel</span>();</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">set_return_listener</span>(function (<span class="variable">$i</span>,<span class="variable">$msg</span>,<span class="variable">$exchange</span>,<span class="variable">$routeKey</span>,AMQPMessage <span class="variable">$message</span>) &#123;</span><br><span class="line">   <span class="title function_ invoke__">print_r</span>(<span class="variable">$message</span>-&gt;body);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">confirm_select</span>();</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">set_ack_handler</span>(function (AMQPMessage <span class="variable">$message</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">print_r</span>(<span class="variable">$message</span>-&gt;body);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">exchange_declare</span>(<span class="string">&#x27;hyperf&#x27;</span>, <span class="string">&#x27;topic&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_declare</span>(<span class="string">&#x27;kt-test&#x27;</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_bind</span>(<span class="string">&#x27;kt-test&#x27;</span>, <span class="string">&#x27;kt-test&#x27;</span>, <span class="string">&#x27;kt-test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">2</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="keyword">new</span> <span class="title class_">AMQPMessage</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">    <span class="comment">//设置一个匹配不到队列的路由键，mandatory设置为true</span></span><br><span class="line">    <span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">basic_publish</span>(<span class="variable">$msg</span>, <span class="string">&#x27;hyperf&#x27;</span>, <span class="string">&#x27;kjfwelf&#x27;</span>,<span class="literal">true</span>); </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot; [x] Sent &#x27;Hello World!&#x27;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">wait_for_pending_acks_returns</span>(<span class="number">10</span>); <span class="comment">//等待</span></span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line"><span class="variable">$connection</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br></pre></td></tr></table></figure><h2 id="什么是消费端的限流？"><a href="#什么是消费端的限流？" class="headerlink" title="什么是消费端的限流？"></a>什么是消费端的限流？</h2><p>rabbitMQ提供了一种<code>qos</code>的功能，即非自动确认消息的前提下，如果有一定数目的消息（通过consumer或者Channel设置qos）未被确认，不进行新的消费。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">basic_qos</span>(<span class="variable">$prefetch_size</span>, <span class="variable">$prefetch_count</span>, <span class="variable">$a_global</span>);</span><br></pre></td></tr></table></figure><ul><li>prefetchSize:0 单条消息的大小限制。0就是不限制，一般都是不限制。</li><li>prefetchCount: 设置一个固定的值，一旦有N个消息还没有ack，则consumer将block掉，直到有消息ack</li><li>global：是否将上面的设置用于channel，也是就是说上面设置的限制是用于channel级别的还是consumer的级别的。</li></ul><h2 id="什么是TTL队列-x2F-消息？"><a href="#什么是TTL队列-x2F-消息？" class="headerlink" title="什么是TTL队列&#x2F;消息？"></a>什么是TTL队列&#x2F;消息？</h2><ul><li>支持消息的过期时间，在消息发送时可以指定。</li><li>支持队列过期时间，在消息入队列开始计算时间，只要超过了队列的超时时间配置，那么消息就会自动的清除。</li></ul><h2 id="什么是死信队列？"><a href="#什么是死信队列？" class="headerlink" title="什么是死信队列？"></a>什么是死信队列？</h2><p>死信队列：DLX，Dead-Letter-Exchange</p><h3 id="消息变为死信的几种情况："><a href="#消息变为死信的几种情况：" class="headerlink" title="消息变为死信的几种情况："></a>消息变为死信的几种情况：</h3><ul><li>消息被拒绝（basic.reject&#x2F;basic.nack）同时requeue&#x3D;false（不重回队列）</li><li>TTL过期</li><li>队列达到最大长度<br><a href="https://www.cnblogs.com/Zhangcsc/p/11739754.html">https://www.cnblogs.com/Zhangcsc/p/11739754.html</a><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="keyword">__DIR__</span> . <span class="string">&#x27;/vendor/autoload.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Connection</span>\<span class="title">AMQPStreamConnection</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Message</span>\<span class="title">AMQPMessage</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Wire</span>\<span class="title">AMQPTable</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$connection</span> = <span class="keyword">new</span> <span class="title class_">AMQPStreamConnection</span>(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">5672</span>, <span class="string">&#x27;guest&#x27;</span>, <span class="string">&#x27;guest&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="variable">$channel</span> = <span class="variable">$connection</span>-&gt;<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$args</span> = <span class="keyword">new</span> <span class="title class_">AMQPTable</span>();</span><br><span class="line"><span class="comment">// 消息过期方式：设置 queue.normal 队列中的消息10s之后过期</span></span><br><span class="line"><span class="variable">$args</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;x-message-ttl&#x27;</span>, <span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 设置队列最大长度方式： x-max-length</span></span><br><span class="line"><span class="comment">//$args-&gt;set(&#x27;x-max-length&#x27;, 1);</span></span><br><span class="line"><span class="variable">$args</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;x-dead-letter-exchange&#x27;</span>, <span class="string">&#x27;exchange.dlx&#x27;</span>);</span><br><span class="line"><span class="variable">$args</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;x-dead-letter-routing-key&#x27;</span>, <span class="string">&#x27;routingkey&#x27;</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">exchange_declare</span>(<span class="string">&#x27;exchange.dlx&#x27;</span>, <span class="string">&#x27;direct&#x27;</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_declare</span>(<span class="string">&#x27;queue.dlx&#x27;</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_bind</span>(<span class="string">&#x27;queue.dlx&#x27;</span>, <span class="string">&#x27;exchange.dlx&#x27;</span>, <span class="string">&#x27;routingkey&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">exchange_declare</span>(<span class="string">&#x27;hyperf&#x27;</span>, <span class="string">&#x27;topic&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_declare</span>(<span class="string">&#x27;test-ttl&#x27;</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>,<span class="literal">false</span>,<span class="variable">$args</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_bind</span>(<span class="string">&#x27;test-ttl&#x27;</span>, <span class="string">&#x27;hyperf&#x27;</span>, <span class="string">&#x27;kt-test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">2</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="keyword">new</span> <span class="title class_">AMQPMessage</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">    <span class="comment">//设置一个匹配不到队列的路由键，mandatory设置为true</span></span><br><span class="line">    <span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">basic_publish</span>(<span class="variable">$msg</span>, <span class="string">&#x27;hyperf&#x27;</span>, <span class="string">&#x27;kt-test&#x27;</span>,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot; [x] Sent &#x27;Hello World!&#x27;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line"><span class="variable">$connection</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.toutiao.com/i6826959307888656899/&quot;&gt;https://</summary>
      
    
    
    
    <category term="rabbitmq" scheme="https://timmy6.github.io/categories/rabbitmq/"/>
    
    
  </entry>
  
  <entry>
    <title>微服务</title>
    <link href="https://timmy6.github.io/2020/06/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>https://timmy6.github.io/2020/06/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-06-02T14:15:10.000Z</published>
    <updated>2022-05-17T06:52:16.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>每个子业务独立部署，不会互相影响</li><li>每个子业务可以使用不同的开发语言</li></ul><h2 id="grpc和protobuf"><a href="#grpc和protobuf" class="headerlink" title="grpc和protobuf"></a>grpc和protobuf</h2><ul><li>gRPC 是谷歌开源的轻量级 RPC 通信框架，其中的通信协议基于二进制数据流，支持 HTTP 2.0 协议，还可以为通信双方建立持续的双向数据流</li><li>protobuf 两个微服务之间通过基于 HTTP 2.0 二进制数据帧通信，那么如何约定二进制数据的格式呢？答案是使用 gRPC 内置的 protobuf 协议，其 DSL 语法 可清晰定义服务间通信的数据结构</li></ul><h2 id="docker容器"><a href="#docker容器" class="headerlink" title="docker容器"></a>docker容器</h2><p>多个容器共享宿主主机的 kernel，多个容器之间相互隔离</p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>它作为一个注册中心会记录每个微服务的 IP 和端口，各微服务上线时会在它那注册，下线时会注销</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/micro/protobuf/proto</span><br><span class="line">go get -u github.com/micro/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure><h2 id="微服务的优点"><a href="#微服务的优点" class="headerlink" title="微服务的优点"></a>微服务的优点</h2><ul><li>各个子模块互相独立，可以选用不同的技术栈，独立开发和维护。</li><li>故障隔离，一个服务挂掉不会影响其他服务。</li></ul><h2 id="微服务的缺点"><a href="#微服务的缺点" class="headerlink" title="微服务的缺点"></a>微服务的缺点</h2><ul><li>数据一致性</li><li>事务问题</li><li>session一致性问题</li><li>锁问题</li><li>单个服务不可用导致整个系统崩溃（熔断器）</li><li>不同开发团队需要紧密协作。</li><li>定位问题难，问题日志可能分布在多台nginx上</li><li>系统变得更加复杂，运维也是个问题。</li></ul><h2 id="如何保障微服务架构下的数据一致性？"><a href="#如何保障微服务架构下的数据一致性？" class="headerlink" title="如何保障微服务架构下的数据一致性？"></a>如何保障微服务架构下的数据一致性？</h2><p><a href="https://www.cnblogs.com/mahatmasmile/p/8530077.html">https://www.cnblogs.com/mahatmasmile/p/8530077.html</a><br>CAP理论，c一致性，a可用性，p分区容错性<br>具体表现为在一定时间内，可能模块之间数据是不一致的，但是通过自动或手动补偿后能够达到最终的一致。<br>二阶段提交协议<br>可靠消息最终一致性</p><ul><li>上游应用将本地业务执行和消息发送绑定在同一个本地事务中，保证要么本地操作成功并发送 MQ 消息</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;每个子业务独立部署，不会互相影响&lt;/li&gt;
&lt;li&gt;每个子业务可以使用不同的开发语言&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;gr</summary>
      
    
    
    
    <category term="微服务" scheme="https://timmy6.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>程序常用算法</title>
    <link href="https://timmy6.github.io/2020/05/20/%E7%A8%8B%E5%BA%8F%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    <id>https://timmy6.github.io/2020/05/20/%E7%A8%8B%E5%BA%8F%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</id>
    <published>2020-05-20T15:15:10.000Z</published>
    <updated>2022-05-17T06:50:09.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="给定一个数组-找最大元素值"><a href="#给定一个数组-找最大元素值" class="headerlink" title="给定一个数组,找最大元素值"></a>给定一个数组,找最大元素值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> arr = []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">45</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">var</span> beginPtr = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> endPtr = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> beginPtr &lt; endPtr &#123; <span class="comment">// 知道两个位置重叠,这个数即为最大值(最小值)</span></span><br><span class="line"><span class="keyword">if</span> arr[beginPtr] &gt; arr[endPtr] &#123;</span><br><span class="line">endPtr--</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">beginPtr++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;max value:&quot;</span>, arr[beginPtr])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给定一个数组-随机找其中几个不重复的元素"><a href="#给定一个数组-随机找其中几个不重复的元素" class="headerlink" title="给定一个数组,随机找其中几个不重复的元素"></a>给定一个数组,随机找其中几个不重复的元素</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line"><span class="keyword">var</span> arr = []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="keyword">var</span> total = <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">j := rand.Int()%total + i <span class="comment">// 从剩余元素中随机抽取一个元素</span></span><br><span class="line">arr[i], arr[j] = arr[j], arr[i] <span class="comment">// 将随机抽取的元素替换掉开头的元素</span></span><br><span class="line">total-- </span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>任何数字和某个数字a求余时,其结果不会超过a</li><li><code>rand.Int()%total</code>,随着total递减,所以改表达式求值结果最大值不会超过剩余元素个数</li><li><code>rand.Int()%total + i</code>,加<code>i</code>的目的是让元素位置往后移动</li><li><code>arr[i], arr[j] = arr[j], arr[i]</code>,后面的随机数会替换掉前面的数字</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;给定一个数组-找最大元素值&quot;&gt;&lt;a href=&quot;#给定一个数组-找最大元素值&quot; class=&quot;headerlink&quot; title=&quot;给定一个数组,找最大元素值&quot;&gt;&lt;/a&gt;给定一个数组,找最大元素值&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://timmy6.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://timmy6.github.io/2020/05/10/%E9%93%BE%E8%A1%A8/"/>
    <id>https://timmy6.github.io/2020/05/10/%E9%93%BE%E8%A1%A8/</id>
    <published>2020-05-10T15:15:10.000Z</published>
    <updated>2022-05-17T06:48:22.905Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul><li>相对于数组,链表不需要连续的存储地址</li><li>每一个节点会记录下一个节点的地址</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/weixin_41582192/article/details/81181077">https://blog.csdn.net/weixin_41582192/article/details/81181077</a></li></ul><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="节点内部结构"><a href="#节点内部结构" class="headerlink" title="节点内部结构"></a>节点内部结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">int</span></span><br><span class="line">    Next *node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>头节点没有data,有next</li><li>尾节点有data,没有next</li></ul><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>例如<code>a-&gt;b-&gt;c</code>,删除b,流程如下:</p><ul><li>根据b.next获取c的地址</li><li>要怎么找到a,并将a.next赋值为c的地址<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3>例如<code>a-&gt;c</code>之间插入b,流程如下:</li><li>创建b节点</li><li>根据a.next获取c的地址,然后赋值为b.next</li><li>将b的地址赋值给a.next</li></ul><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h3 id="节点内部结构-1"><a href="#节点内部结构-1" class="headerlink" title="节点内部结构"></a>节点内部结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">int</span></span><br><span class="line">    Next *node</span><br><span class="line">    Prev *node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;相对于数组,链表不需要连续的存储地址&lt;/li&gt;
&lt;li&gt;每一个节点会记录下一个节点的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://timmy6.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>redis架构模式</title>
    <link href="https://timmy6.github.io/2020/04/12/redis%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>https://timmy6.github.io/2020/04/12/redis%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-12T14:15:10.000Z</published>
    <updated>2022-05-17T06:41:01.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-有哪些架构模式？讲讲各自的特点"><a href="#Redis-有哪些架构模式？讲讲各自的特点" class="headerlink" title="Redis 有哪些架构模式？讲讲各自的特点"></a>Redis 有哪些架构模式？讲讲各自的特点</h2><ul><li>单机版</li><li>主从复制</li><li>哨兵模式（监控主从服务器，主服务器下线能够自动进行故障转移）</li><li>集群</li></ul><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>大概两个过程：</p><ul><li>从节点发送sync给主节点，主节点发送rdb快照文件给从节点，从节点从快照文件同步数据</li><li>主节点每写一个命令就会同步到从节点，从节点接收并执行收到的命令</li></ul><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>一般使用3个哨兵，1主2从</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>监控主节点和从节点的状态</li><li>当主节点发送故障，会自动将从节点转换为主节点，整个过程不需要人工参与<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3></li><li>哨兵节点会向所有主从节点和其他哨兵节点发送ping消息，如果主节点在一定时间内（down-after-milliseconds）没有得到回复，则会被哨兵节点标记为主观下线（SDOWN）。</li><li>当有足够数据量的哨兵节点标记主节点为主观下线，则主节点会标记为客观下线。</li><li>主节点会进行故障转移，选取一个从节点来替换主节点。<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3>准备节点：3个哨兵，1主，2从；</li><li>主从节点主要配置如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使得Redis服务器可以跨网络访问</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line"><span class="comment"># 设置密码</span></span><br><span class="line">requirepass <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="comment"># 指定主服务器，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置</span></span><br><span class="line">slaveof 192.168.11.128 6379</span><br><span class="line"><span class="comment"># 主服务器密码，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置</span></span><br><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure></li><li>哨兵节点配置如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 禁止保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"><span class="comment"># 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。</span></span><br><span class="line">sentinel monitor mymaster 192.168.11.128 6379 2</span><br><span class="line"><span class="comment"># sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure></li><li>启动哨兵节点和主从节点<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/wwwroot/redis/redis_sentinel</span><br><span class="line"><span class="comment">#启动redis</span></span><br><span class="line">redis-server redis_6480/redis.conf <span class="comment">#这个是主节点</span></span><br><span class="line">redis-server redis_6481/redis.conf</span><br><span class="line">redis-server redis_6482/redis.conf</span><br><span class="line"><span class="comment">#查看主从是否启动成功</span></span><br><span class="line">redis-cli -h 127.0.0.1 -p 6480 ping</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6480 info replication</span><br><span class="line"><span class="comment">#启动哨兵</span></span><br><span class="line">redis-sentinel sentinel_26379/sentinel.conf</span><br><span class="line">redis-sentinel sentinel_26380/sentinel.conf</span><br><span class="line">redis-sentinel sentinel_26381/sentinel.conf</span><br><span class="line"><span class="comment">#确认哨兵是否启用成功</span></span><br><span class="line">redis-cli -p 26379 info sentinel</span><br></pre></td></tr></table></figure></li></ul><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>redis的集群采用无中心结构，所有redis节点彼此互联（PING—PONG机制），当某个节点失败时需要集群中超过半数节点检测失效才会生效。客户端与redis节点直连，不需要借助中间代理层，客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。</p><h3 id="集群数据分布"><a href="#集群数据分布" class="headerlink" title="集群数据分布"></a>集群数据分布</h3><p>每一个节点负责维护一部分槽和槽存放的数据，槽的范围是0到16383<br>key -&gt; 槽 -&gt; 节点</p><h3 id="集群请求路由"><a href="#集群请求路由" class="headerlink" title="集群请求路由"></a>集群请求路由</h3><ul><li>先计算key对应的槽，可以通过<code>cluster keyslot &#123;key&#125;</code>查看对应哪个槽</li><li>找槽对应的节点</li><li>若不是本节点，则回复move重定向错误，通知客户端请求正确的节点<br>cli模式下重定向，加上<code>-c</code>参数，例如<code>redis-cli -p 6481 -c</code><h3 id="如何解决集群mget问题？"><a href="#如何解决集群mget问题？" class="headerlink" title="如何解决集群mget问题？"></a>如何解决集群mget问题？</h3></li></ul><p>集群带来的一个问题是，无法批处理，例如当我们提交了一批命令，往Redis中存储一批键，那么这些键一般会被映射到不同的slot，而不同的slot又可能在Redis Cluster中不同的节点上，这样就和的预期有点不同，有没有办法将这批键映射到同一个slot呢？</p><p>可以使用<code>hash_tag</code>，哈希标签是确保两个键都在同一个哈希槽里的一种方式。</p><ul><li>比如这两个键 {user1000}.following 和 {user1000}.followers 会被哈希到同一个哈希槽里，因为只有 user1000 这个子串会被用来计算哈希值。</li><li>对于 foo{}{bar} 这个键，整个键都会被用来计算哈希值，因为第一个出现的 { 和它右边第一个出现的 } 之间没有任何字符。</li><li>对于 foo{bar}{zap} 这个键，用来计算哈希值的是 bar 这个子串，因为算法会在第一次有效或无效（比如中间没有任何字节）地匹配到 { 和 } 的时候停止。</li></ul><p><img src="/assets/1615987751665.png" alt="1615987751665"></p><h3 id="集群是如何扩容"><a href="#集群是如何扩容" class="headerlink" title="集群是如何扩容?"></a>集群是如何扩容?</h3><ul><li>添加新节点，<code>redis-trib.rb add-node new_host:new_port exitsing_host:existing_port</code> ，新加入节点刚开始都是主节点状态，没有负责槽，不能接收任何读写操作，需要导入槽和数据，或者是设置为从节点</li><li>迁移过程<code>redis-trib.rb reshard &#123;existing_ip:existing_port&#125;</code><ul><li>目标节点准备导入槽</li><li>源节点准备导出槽</li><li>获取槽下n个key</li><li>批量迁移相关key的数据</li><li>循环迁移key</li><li>通知槽分配给目标节点</li></ul></li><li>新节点设置成从节点，具体进入从节点命令行，执行cluster replicate master_id</li></ul><h3 id="集群是如何缩容？"><a href="#集群是如何缩容？" class="headerlink" title="集群是如何缩容？"></a>集群是如何缩容？</h3><ul><li>下线节点是否有负责的槽 ，如果有的话需要先迁移到其他节点上，命令<code>使用redis-trib.rb reshared &#123;existing_ip:existing_port&#125;</code></li><li>当下线节点不再负责槽或者本身是从节点就可以通知集群其他节点忘记下线节点，命令<code>使用redis-trib.rb del-node &#123;host:port&#125; &#123;downNodeId&#125; 忘记节点</code></li><li>下线节点正常关闭</li></ul><h3 id="集群是如何故障转移的？"><a href="#集群是如何故障转移的？" class="headerlink" title="集群是如何故障转移的？"></a>集群是如何故障转移的？</h3><ul><li>首先，如果一个节点在规定时间内没有回复，会被其他节点标记为主观下线</li><li>如果被超过半数的节点标记为主观下线，则故障节点会被标为客观下线</li><li>资格检查；当从节点通过内部定时任务发现自身复制的主节点进入客观下线时，则会触发选举，触发条件：断线时间不超过<code>cluster-node-time*cluster-slave-validity-fator</code>，目的是剔除太久没有同步主节点数据的从节点</li><li>准备选举时间；一个故障主节点可能会有多个从节点，这就需要有发起选举的优先级，主要根据复制偏移量来设置延迟选举时间，复制偏移量越大，排名越靠前，延迟时间越低，越有机会才会主节点</li><li>选举投票；<ul><li>只有持有槽的主节点才能参与选举投票</li><li>只有一个从节点获得n&#x2F;2+1的选票才能选举成功</li><li>在<code>clsuter-node-timeout*2</code>内从节点没有获取足够数量的投票，选举作废</li></ul></li><li>替换主节点，接管故障节点的槽和通知集群</li></ul><h3 id="迁移槽命令参数"><a href="#迁移槽命令参数" class="headerlink" title="迁移槽命令参数"></a>迁移槽命令参数</h3><p><code>redis-trib.rb reshard &#123;existing_ip:existing_port&#125;</code></p><ul><li>–slots 需要确定迁移槽的总数量，总槽数&#x2F;总节点</li><li>–from 多个源节点，迁出槽</li><li>–to 一个目标节点，迁入槽</li><li>–timeout 控制每次migrate操作的超时时间，默认为60000毫秒</li><li>–pipeline 控制每次批量迁移键的数量，默认为10</li><li>host:port 集群中任意一个节点的地址</li></ul><h2 id="docker安装redis"><a href="#docker安装redis" class="headerlink" title="docker安装redis"></a>docker安装redis</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 redis</span><br></pre></td></tr></table></figure><h2 id="配置文件修改"><a href="#配置文件修改" class="headerlink" title="配置文件修改"></a>配置文件修改</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port 6481</span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line"><span class="comment">#集群内部配置文件</span></span><br><span class="line">cluster-config-file nodes-6481.conf</span><br><span class="line"><span class="comment">#节点超时时间，单位毫秒</span></span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line">logfile <span class="string">&quot;/data/wwwroot/redis/redis_cluster/6481/log/redis-6481.log&quot;</span></span><br><span class="line">pidfile /data/wwwroot/redis/redis_cluster/redis-6481.pid</span><br></pre></td></tr></table></figure><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动节点</span></span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6481/redis-6481.conf</span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6482/redis-6482.conf</span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6483/redis-6483.conf</span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6484/redis-6484.conf</span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6485/redis-6485.conf</span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6486/redis-6486.conf</span><br><span class="line"></span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6487/redis-6487.conf</span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6488/redis-6488.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建集群</span></span><br><span class="line"><span class="comment">#--replicas 1表示每个主节点配备几个从节点</span></span><br><span class="line">redis-trib.rb create --replicas 1 127.0.0.1:6481 127.0.0.1:6482 127.0.0.1:6483 127.0.0.1:6484 127.0.0.1:6485 127.0.0.1:6486</span><br><span class="line"></span><br><span class="line"><span class="comment">#检测集群完整性</span></span><br><span class="line"><span class="comment">#只要16384个槽中有一个没有分配给节点则表示集群不完整</span></span><br><span class="line"><span class="comment">#可以对集群中任意一个节点发起检测</span></span><br><span class="line">redis-trib.rb check 127.0.0.1:6481</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看集群所有节点</span></span><br><span class="line">cluster nodes</span><br><span class="line"></span><br><span class="line"><span class="comment">#集群扩容</span></span><br><span class="line"><span class="comment">#6487是新节点，6481是已存在节点</span></span><br><span class="line"><span class="comment">#如果新节点已存在数据，则会添加失败</span></span><br><span class="line"><span class="comment">#redis-trib.rb add-node &#123;new_ip:new_port&#125; &#123;existing_ip:existing_port&#125;</span></span><br><span class="line">redis-trib.rb add-node 127.0.0.1:6487 127.0.0.1:6481</span><br><span class="line"><span class="comment">#迁移槽和数据，127.0.0.1:6481为集群中任意一个节点</span></span><br><span class="line">redis-trib.rb reshard 127.0.0.1:6481</span><br><span class="line"></span><br><span class="line"><span class="comment">#集群缩容</span></span><br><span class="line"><span class="comment">#迁移槽</span></span><br><span class="line">redis-trib.rb reshard 127.0.0.1:6481</span><br><span class="line"><span class="comment">#忘记节点</span></span><br><span class="line">redis-trib.rb del-node 127.0.0.1:6487 d4aafc5465d0f85a55ccd648e045cedcb46478cd</span><br><span class="line"></span><br><span class="line"><span class="comment">#请求路由</span></span><br><span class="line"><span class="comment">#查看key对应的槽</span></span><br><span class="line">cluster keyslot &#123;key&#125;</span><br><span class="line"><span class="comment">#cli模式下加上-c可以重定向到正确节点</span></span><br><span class="line">redis-cli -p 6481 -c</span><br></pre></td></tr></table></figure><h2 id="新节点迁移槽和数据"><a href="#新节点迁移槽和数据" class="headerlink" title="新节点迁移槽和数据"></a>新节点迁移槽和数据</h2><h2 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">M: b079123bb42e1de36e9bc21d0473f8ceda6f7265 127.0.0.1:6481</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: bcbb401d25543cfc6384546ad24b46eb264b426e 127.0.0.1:6483</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 8f2f21cb11d1986da9137f099e938bdb4e0f230e 127.0.0.1:6484</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates fa0015a21a575b170f5e39f463cc62fdb3a6e667</span><br><span class="line">S: af886e91bf0f42e36627d16d35bc270c0b6fb35e 127.0.0.1:6486</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates b079123bb42e1de36e9bc21d0473f8ceda6f7265</span><br><span class="line">M: fa0015a21a575b170f5e39f463cc62fdb3a6e667 127.0.0.1:6482</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 41e8cc7350b94185fca11ce243183f414307b037 127.0.0.1:6485</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates bcbb401d25543cfc6384546ad24b46eb264b426e</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis-有哪些架构模式？讲讲各自的特点&quot;&gt;&lt;a href=&quot;#Redis-有哪些架构模式？讲讲各自的特点&quot; class=&quot;headerlink&quot; title=&quot;Redis 有哪些架构模式？讲讲各自的特点&quot;&gt;&lt;/a&gt;Redis 有哪些架构模式？讲讲各自的特点&lt;/</summary>
      
    
    
    
    <category term="redis" scheme="https://timmy6.github.io/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>redis持久化</title>
    <link href="https://timmy6.github.io/2020/03/03/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://timmy6.github.io/2020/03/03/redis%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2020-03-03T14:15:10.000Z</published>
    <updated>2022-05-17T06:33:50.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/bab8f4b26445">https://www.jianshu.com/p/bab8f4b26445</a></li><li><a href="https://www.cnblogs.com/lizhimin123/p/10192217.html">https://www.cnblogs.com/lizhimin123/p/10192217.html</a></li></ul><blockquote><p>相对于memcache,redis的是数据可以做持久化处理,主要有两种方式,快照rdb和追加文件aof,redis是持久化处理是比较耗时,一般在主从模式中,master不做持久化处理,由slave处理</p></blockquote><h2 id="什么是Redis持久化？"><a href="#什么是Redis持久化？" class="headerlink" title="什么是Redis持久化？"></a>什么是Redis持久化？</h2><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p><h2 id="快照rdb"><a href="#快照rdb" class="headerlink" title="快照rdb"></a>快照rdb</h2><ul><li>redis使用操作系统的多进程COW机制(Copy On Write)复制写机制来实现快照的持久化</li><li>由子进程进行持久操作，子进程刚刚产生时，和父进程共享内存里面的代码段和数据段</li><li>子进程会</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>持久化有两个命令，<code>save</code>和<code>bgsave</code>，<code>save</code>会阻塞服务进程，直到持久化完成，<code>bgsave</code>会fork子进程，由子进程去完成持久化，<code>bgsave</code>对应配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 满足以上三个条件中的任意一个，则自动触发 BGSAVE 操作 </span><br><span class="line">save 900 1       // 服务器在900秒之内，对数据库执行了至少1次修改 </span><br><span class="line">save 300 10      // 服务器在300秒之内，对数据库执行了至少10修改 </span><br><span class="line">save 60  1000    // 服务器在60秒之内，对数据库执行了至少1000修改</span><br></pre></td></tr></table></figure><h3 id="rdb文件结构"><a href="#rdb文件结构" class="headerlink" title="rdb文件结构"></a>rdb文件结构</h3><p><a href="https://www.cnblogs.com/lizhimin123/p/10192217.html">https://www.cnblogs.com/lizhimin123/p/10192217.html</a><br><img src="https://img2018.cnblogs.com/blog/1522047/201812/1522047-20181229102040895-1225006452.png" alt="https://img2018.cnblogs.com/blog/1522047/201812/1522047-20181229102040895-1225006452.png"></p><ul><li>REDIS：5字节，保存着 “REDIS” 五个字符</li><li>db_version：4字节，RDB文件的版本号</li><li>database 0：数据库中的键值对<ul><li>SELECTDB：1字节常量</li><li>db_number：数据库号码</li><li>key_value_pairs：键值对<ul><li>type: 记录类对象的编码类型，程序会根据 TYPE 属性来决定如何读入和解释value数据</li><li>key</li><li>value</li></ul></li></ul></li><li>EOF：RDB文件的结束标志</li><li>check_sum：校验和（CRC64），用来检查RDB文件是否出错</li></ul><h3 id="rdb问题"><a href="#rdb问题" class="headerlink" title="rdb问题"></a>rdb问题</h3><ul><li>持久化过程中数据发生改变？<br>rdb文件被成为快照文件，子进程所看到的数据在它被创建的一瞬间就固定下来了，父进程修改的某个数据只是该数据的复制品。（父子进程共享内存，数据发生写时会另外复制一份数据进行修改）<br><img src="https://upload-images.jianshu.io/upload_images/7789414-016d9f4ff4c14e33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1196/format/webp" alt="https://upload-images.jianshu.io/upload_images/7789414-016d9f4ff4c14e33.png?imageMogr2/auto-orient/strip|imageView2/2/w/1196/format/webp"></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul><li>性能好  <h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3></li><li>实时性差</li></ul><h2 id="追加日志aof"><a href="#追加日志aof" class="headerlink" title="追加日志aof"></a>追加日志aof</h2><p>redis将指令追加到日志，通过回放指令来恢复数据，随着时间的增大会有日志文件变大的问题，这就需要重写日志</p><h2 id="aof重写日志的过程是怎么样的？"><a href="#aof重写日志的过程是怎么样的？" class="headerlink" title="aof重写日志的过程是怎么样的？"></a>aof重写日志的过程是怎么样的？</h2><p><img src="https://upload-images.jianshu.io/upload_images/7789414-42813796f197b274.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/957/format/webp" alt="https://upload-images.jianshu.io/upload_images/7789414-42813796f197b274.png?imageMogr2/auto-orient/strip|imageView2/2/w/957/format/webp"></p><ul><li>fork子进程</li><li>子进程遍历内存数据写到新的aof文件</li><li>在生成新的aof文件的过程中，如果收到新指令，则继续保存在系统内存缓存中</li><li>完成新的aof文件之后，将系统内存缓存数据追加到新的aof文件</li><li>新的aof文件代替旧的aof文件</li></ul><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点:"></a>优点:</h3><ul><li>实时性小  <h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点:"></a>缺点:</h3></li><li>需要重写日志文件</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/bab8f4b26445&quot;&gt;https://www.jia</summary>
      
    
    
    
    <category term="redis" scheme="https://timmy6.github.io/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>redis常见问题</title>
    <link href="https://timmy6.github.io/2020/02/03/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://timmy6.github.io/2020/02/03/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-03T14:15:10.000Z</published>
    <updated>2022-05-17T06:30:07.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/jasontec/p/9699242.html">https://www.cnblogs.com/jasontec/p/9699242.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/79778696">https://zhuanlan.zhihu.com/p/79778696</a></li></ul><h2 id="使用过Redis分布式锁么，它是怎么实现的？"><a href="#使用过Redis分布式锁么，它是怎么实现的？" class="headerlink" title="使用过Redis分布式锁么，它是怎么实现的？"></a>使用过Redis分布式锁么，它是怎么实现的？</h2><p>redis的分布式锁主要使用<code>set</code>命令的<code>nx</code>选项抢占锁，以及<code>ex</code>设置过期时间，先nx获得锁并且设置过期时间，这两个过程是原子性的，中间不会被其他命令打断；<br>另外防止锁超时过期误删锁，一般使用<code>set</code>获得锁时会设置一个唯一值，释放锁的时候需要匹配一下两个值是否一致</p><h2 id="什么是一致性哈希算法？什么是哈希槽？"><a href="#什么是一致性哈希算法？什么是哈希槽？" class="headerlink" title="什么是一致性哈希算法？什么是哈希槽？"></a>什么是一致性哈希算法？什么是哈希槽？</h2><p><a href="https://www.jianshu.com/p/6ad87a1f070e">https://www.jianshu.com/p/6ad87a1f070e</a></p><p>redis 的 custer 提供了两个功能：</p><ul><li>自动对数据分片，落到各个节点上</li><li>即使集群部分节点失效或者连接不上，依然可以继续处理命令</li></ul><p>普通哈希算法是<code>hash(key)%number</code>对数量进行取余获得key所在节点位置，如果改变数量会导致原有节点上的数据发生变化；</p><p>在一致性哈希算法中，整个哈希空间是一个虚拟圆环。 对节点取哈希值，然后分配到哈希环上。对某个值进行搜索的时候按顺时针搜索找到key第一个存在的节点，即使发生节点数据变化，也只是影响一小部分区间的数据；</p><p>一致性哈希算法对于容错性和扩展性有非常好的支持。但一致性哈希算法也有一个严重的问题，就是数据倾斜。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>对每个真实节点增加多个虚拟节点，然后维护一个虚拟节点和真实节点的映射关系表；（即环上都是）<a href="https://geektutu.com/post/geecache-day4.html">https://geektutu.com/post/geecache-day4.html</a></li><li>rredis 集群（cluster）并没有选用上面一致性哈希，而是采用了哈希槽（slot）的这种概念。每个redis节点会维护一部分槽以及槽上的数据，总的槽大概一万六千多，槽可以均匀分布在多个节点</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> --net=host --name redis-manager  \</span><br><span class="line">-e DATASOURCE_DATABASE=<span class="string">&#x27;redis_manager&#x27;</span> \</span><br><span class="line">-e DATASOURCE_URL=<span class="string">&#x27;jdbc:mysql://127.0.0.1:3306/redis_manager?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2b8&#x27;</span> \</span><br><span class="line">-e DATASOURCE_USERNAME=<span class="string">&#x27;root&#x27;</span> \</span><br><span class="line">-e DATASOURCE_PASSWORD=<span class="string">&#x27;123456&#x27;</span> \</span><br><span class="line">reasonduan/redis-manager</span><br></pre></td></tr></table></figure><p><a href="https://www.fengpt.cn/archives/redis%E9%9B%86%E7%BE%A4%E5%9C%A8%E6%9F%A5%E6%89%BEkey%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%AF%E7%94%B1%E7%9A%84">https://www.fengpt.cn/archives/redis%E9%9B%86%E7%BE%A4%E5%9C%A8%E6%9F%A5%E6%89%BEkey%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%AF%E7%94%B1%E7%9A%84</a></p><h2 id="redis集群哈希槽"><a href="#redis集群哈希槽" class="headerlink" title="redis集群哈希槽"></a>redis集群哈希槽</h2><p>redis cluster 包含了16384个哈希槽，每个 key 通过计算后都会落在具体一个槽位上，而这个槽位是属于哪个存储节点的，则由用户自己定义分配。例如机器硬盘小的，可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。所以哈希槽这种概念很好地解决了一致性哈希的弊端。</p><p>在容错性和扩展性上，redis对槽位的转移，把故障节点负责的槽位转移到其他正常的节点上。 </p><p>但一定要注意的是，对于槽位的转移和分派，redis 集群是不会自动进行的，而是需要人工配置的。所以 redis 集群的高可用是依赖于节点的主从复制与主从间的自动故障转移。</p><h2 id="使用过Redis做异步队列么，你是怎么用的？有什么缺点？"><a href="#使用过Redis做异步队列么，你是怎么用的？有什么缺点？" class="headerlink" title="使用过Redis做异步队列么，你是怎么用的？有什么缺点？"></a>使用过Redis做异步队列么，你是怎么用的？有什么缺点？</h2><p>可以是使用<code>blpop</code>和<code>rpush</code>，<code>blpop</code>会移除列表头部元素，如果列表没有元素会阻塞直到等待超时或发现元素为止，<code>rpush</code>从尾部写入数据；缺点如下：</p><ul><li>消息容易丢失</li><li>消息分发策略没有专业的mq丰富，例如kafka的分区，rabbitmq的路由键等等</li></ul><h2 id="什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？"><a href="#什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？" class="headerlink" title="什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？"></a>什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>一般缓存系统会先查缓存，值不存在的时候再查数据库；一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。如何避免？</p><ul><li>对查询结果为空的情况也进行缓存，缓存时间设置短一点</li><li>对一定不存在的key进行过滤，可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤（布尔过滤器）<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。如何避免？</li><li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量</li><li>不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</li></ul><h2 id="Redis的字典是如何实现的？简述渐进式rehash的过程？"><a href="#Redis的字典是如何实现的？简述渐进式rehash的过程？" class="headerlink" title="Redis的字典是如何实现的？简述渐进式rehash的过程？"></a>Redis的字典是如何实现的？简述渐进式rehash的过程？</h2><p><a href="https://www.jianshu.com/p/e2697fecac0d">https://www.jianshu.com/p/e2697fecac0d</a><br><a href="https://www.cnblogs.com/neooelric/p/9621736.html">https://www.cnblogs.com/neooelric/p/9621736.html</a></p><h2 id="Redis事务是怎么样的？"><a href="#Redis事务是怎么样的？" class="headerlink" title="Redis事务是怎么样的？"></a>Redis事务是怎么样的？</h2><p>redis的事务是通过mutil实现的，mutil开始一个事务，然后将多个命令入队到事务中，最后执行exec命令触发事务。redis的事务有一些不足：</p><ul><li>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做</li><li>同的key是有可能分配在不同的Redis节点上的，在这种情况下Redis的事务机制是不生效的</li></ul><h2 id="集群可以使用lua脚本吗？"><a href="#集群可以使用lua脚本吗？" class="headerlink" title="集群可以使用lua脚本吗？"></a>集群可以使用lua脚本吗？</h2><p>不可以，除非key在同一个redis节点上，可以使用<code>&#123;hash_tag&#125;</code>来是不同的key落到同一个节点上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; CLUSTER KEYSLOT somekey</span><br><span class="line">11058</span><br><span class="line">&gt; CLUSTER KEYSLOT foo&#123;hash_tag&#125;</span><br><span class="line">(<span class="built_in">integer</span>) 2515</span><br><span class="line">&gt; CLUSTER KEYSLOT bar&#123;hash_tag&#125;</span><br><span class="line">(<span class="built_in">integer</span>) 2515</span><br></pre></td></tr></table></figure><p>keySlot算法中，如果key包含{}，就会使用第一个{}内部的字符串作为hash key，这样就可以保证拥有同样{}内部字符串的key就会拥有相同slot</p><h2 id="Redis的多数据库机制，了解多少？"><a href="#Redis的多数据库机制，了解多少？" class="headerlink" title="Redis的多数据库机制，了解多少？"></a>Redis的多数据库机制，了解多少？</h2><p>单机版有16个数据库，每个数据库的数据相互隔离，集群版只有一个数据库</p><h2 id="谈谈你对分布式和集群，微服务的理解？两则之间有什么关系？"><a href="#谈谈你对分布式和集群，微服务的理解？两则之间有什么关系？" class="headerlink" title="谈谈你对分布式和集群，微服务的理解？两则之间有什么关系？"></a>谈谈你对分布式和集群，微服务的理解？两则之间有什么关系？</h2><ul><li>分布式是将一个业务拆分多个子业务，多个子业务可以部署不同机器上面，子业务之间通过rpc或消息中间件或其他方式进行通信，如果有一个子业务不可用，那么整个业务就不可用</li><li>微服务是将一个业务拆分多个子业务，多个子业务可以部署在不同机器或统一机器上面（和分布式的区别）。</li><li>集群是同一个业务部署到多个机器上面，比如用nginx做负载均衡。</li><li>分布式下每个子业务都可以做集群，分布式和微服务类似，只是部署方式不一样</li></ul><h2 id="redis集群有什么限制"><a href="#redis集群有什么限制" class="headerlink" title="redis集群有什么限制"></a>redis集群有什么限制</h2><ul><li>不能批量处理key</li><li>不支持事务，多数据库</li><li>一些大的键值对象不能映射到不同的节点上</li></ul><h2 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h2><ul><li>使用keys 指定模式可以获得key列表</li><li>因为redis是单线程模式，使用keys命令会导致线程阻塞一段时间，线上服务会停顿，直到命令执行完毕才能恢复</li><li>可以用scan命令，无阻塞的，但是会有一定的重复概率</li></ul><h2 id="bgsave的原理是什么？"><a href="#bgsave的原理是什么？" class="headerlink" title="bgsave的原理是什么？"></a>bgsave的原理是什么？</h2><p>fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p><h2 id="Pipeline有什么好处，为什么要用pipeline？"><a href="#Pipeline有什么好处，为什么要用pipeline？" class="headerlink" title="Pipeline有什么好处，为什么要用pipeline？"></a>Pipeline有什么好处，为什么要用pipeline？</h2><p>可以将多次IO往返的时间缩减为一次</p><h2 id="Redis的同步机制了解么？"><a href="#Redis的同步机制了解么？" class="headerlink" title="Redis的同步机制了解么？"></a>Redis的同步机制了解么？</h2><ul><li>第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。</li><li>加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</li></ul><h2 id="是否使用过Redis集群，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的原理是什么？"></a>是否使用过Redis集群，集群的原理是什么？</h2><p>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。<br>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/jasontec/p/9699242.html&quot;&gt;https:</summary>
      
    
    
    
    <category term="redis" scheme="https://timmy6.github.io/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis的常用淘汰策略以及算法</title>
    <link href="https://timmy6.github.io/2020/01/05/Redis%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95/"/>
    <id>https://timmy6.github.io/2020/01/05/Redis%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95/</id>
    <published>2020-01-05T14:15:10.000Z</published>
    <updated>2022-05-17T06:24:53.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis配置内存为多少合适？"><a href="#Redis配置内存为多少合适？" class="headerlink" title="Redis配置内存为多少合适？"></a>Redis配置内存为多少合适？</h2><p><strong>默认</strong>：如果<strong>不设置最大内存</strong>大小或者<strong>设置最大内存大小为0</strong>，在<strong>64为操作系统下不限制内存大小</strong>，在<strong>32位操作</strong>系统下<strong>最多使用3GB</strong>内存。</p><p>一般推荐Redis设置<strong>内存为最大物理内存的75%都是安全</strong>的 </p><h2 id="如何修改内存"><a href="#如何修改内存" class="headerlink" title="如何修改内存"></a>如何修改内存</h2><p><strong>redis.conf中</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maxmemory  <span class="number">104857600</span></span><br><span class="line">config set maxmemory <span class="number">104857600</span></span><br></pre></td></tr></table></figure><h2 id="Redis的内存淘汰策略"><a href="#Redis的内存淘汰策略" class="headerlink" title="Redis的内存淘汰策略"></a>Redis的内存淘汰策略</h2><h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><ul><li>定期删除</li><li>惰性删除</li></ul><h3 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h3><ul><li>lru - 最近最少使用的 key，也就是首先淘汰最长时间未被使用的缓存，强调的是时间</li><li>random - 随机删除</li><li>lfu - 最近最不经常使用，,也就是淘汰一定时期内被访问次数最少的缓存，强调的是频率</li></ul><h3 id="LRU算法原理"><a href="#LRU算法原理" class="headerlink" title="LRU算法原理"></a>LRU算法原理</h3><p>其原理是维护一个双向链表，key -&gt; node，其中node保存链表前后节点关系及数据data。新插入的key时，放在头部，并检查是否超出总容量，如果超出则删除最后的key；访问key时，无论是查找还是更新，将该Key被调整到头部。</p><p><img src="/images/other/20191119154442706.png" alt="在这里插入图片描述"></p><p>Redis并没有使用严格的LRU算法，因为维护一个那么大的双向链表需要的内存空间较大。redis通过随机采样法淘汰数据，每次随机出5（默认）个key，从里面淘汰掉最近最少使用的key。</p><p>显然LRU的缺陷是明显的，最新访问的数据被当做热数据显然是不合理的，热数据顾名思义就是被访问频次叫高的数据，显然是不同的概念</p><h3 id="LFU算法原理"><a href="#LFU算法原理" class="headerlink" title="LFU算法原理"></a>LFU算法原理</h3><p>假如你使用的是LRU算法，一个key很久没有被访问到，只刚刚是偶尔被访问了一次，那么它就被认为是热点数据，不会被淘汰，而有些key将来是很有可能被访问到的则被淘汰了。如果使用LFU算法则不会出现这种情况，因为使用一次并不会使一个key成为热点数据。LFU原理使用计数器来对key进行排序，每次key被访问的时候，计数器增大。计数器越大，可以约等于访问越频繁。具有相同引用计数的数据块则按照时间排序。</p><p><img src="/images/other/20191119182623142-1615863469510.png" alt="å¨è¿éæå¥å¾çæè¿°"></p><p>LFC算法存在两个问题：</p><ul><li>在LRU算法中可以维护一个双向链表，然后简单的把被访问的节点移至链表开头，但在LFU中是不可行的，节点要严格按照计数器进行排序，新增节点或者更新节点位置时，时间复杂度可能达到O(N)。</li><li>只是简单的增加计数器的方法并不完美。访问模式是会频繁变化的，一段时间内频繁访问的key一段时间之后可能会很少被访问到，只增加计数器并不能体现这种趋势</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/raoxiaoya/article/details/103141022">https://blog.csdn.net/raoxiaoya/article/details/103141022</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis配置内存为多少合适？&quot;&gt;&lt;a href=&quot;#Redis配置内存为多少合适？&quot; class=&quot;headerlink&quot; title=&quot;Redis配置内存为多少合适？&quot;&gt;&lt;/a&gt;Redis配置内存为多少合适？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;默认&lt;/strong</summary>
      
    
    
    
    <category term="redis" scheme="https://timmy6.github.io/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql索引知识</title>
    <link href="https://timmy6.github.io/2019/12/15/mysql%E7%B4%A2%E5%BC%95%E7%9F%A5%E8%AF%86/"/>
    <id>https://timmy6.github.io/2019/12/15/mysql%E7%B4%A2%E5%BC%95%E7%9F%A5%E8%AF%86/</id>
    <published>2019-12-15T14:15:10.000Z</published>
    <updated>2022-05-17T06:16:11.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.toutiao.com/i6732776474308248072/">https://www.toutiao.com/i6732776474308248072/</a></li><li><a href="https://www.cnblogs.com/jie-y/p/11153480.html">https://www.cnblogs.com/jie-y/p/11153480.html</a></li><li><a href="https://www.cnblogs.com/kkbill/p/11381783.html">https://www.cnblogs.com/kkbill/p/11381783.html</a></li></ul><h2 id="为什么要用索引？"><a href="#为什么要用索引？" class="headerlink" title="为什么要用索引？"></a>为什么要用索引？</h2><p>索引用于加速查询速度</p><h2 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h2><ul><li>需要维护索引文件,占物理空间</li><li>影响增删改性能</li></ul><h2 id="数据存储文件"><a href="#数据存储文件" class="headerlink" title="数据存储文件"></a>数据存储文件</h2><h3 id="对于MyISAM存储引擎来说"><a href="#对于MyISAM存储引擎来说" class="headerlink" title="对于MyISAM存储引擎来说"></a>对于MyISAM存储引擎来说</h3><ul><li><code>.frm</code>后缀的文件存储的是表结构。</li><li><code>.myd</code>后缀的文件存储的是表数据。</li><li><code>.myi</code>后缀的文件存储的就是索引文件。<h3 id="对于InnoDB-存储引擎来说"><a href="#对于InnoDB-存储引擎来说" class="headerlink" title="对于InnoDB 存储引擎来说:"></a>对于InnoDB 存储引擎来说:</h3></li><li><code>.frm</code>后缀的文件存储的是表结构。</li><li><code>.ibd</code>后缀的文件存放索引文件和数据(需要开启innodb_file_per_table 参数)</li></ul><h2 id="myisam和innodb从索引方面上来说有什么区别？"><a href="#myisam和innodb从索引方面上来说有什么区别？" class="headerlink" title="myisam和innodb从索引方面上来说有什么区别？"></a>myisam和innodb从索引方面上来说有什么区别？</h2><p><a href="https://www.cnblogs.com/jie-y/p/11153480.html">https://www.cnblogs.com/jie-y/p/11153480.html</a></p><ul><li>myisam主索引和数据是分开的，innodb数据文件本身就是主索引文件</li><li>myisam的主索引文件和辅助索引文件结构一样，叶子节点保存行数据的物理地址</li><li>innodb的主索引文件是按主键构造的<code>b+</code>树（也叫聚簇索引），叶子节点保存行数据；辅助索引的叶子节点保存主键值</li></ul><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p><code>聚簇索引</code>并不是一种索引类型，也是一种数据存储方式，它按照主键的顺序构建<code>b+树</code>，行数据存放在叶子节点上</p><h3 id="聚簇索引的缺点"><a href="#聚簇索引的缺点" class="headerlink" title="聚簇索引的缺点"></a>聚簇索引的缺点</h3><ul><li>页分裂会导致表占用更多的磁盘空间；假如磁盘中的某一个已经存满了，但是新增的行要插入到这一页当中，存储引擎就会把该也分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间</li></ul><h2 id="什么是二级索引？"><a href="#什么是二级索引？" class="headerlink" title="什么是二级索引？"></a>什么是二级索引？</h2><p>对于非主键列其他列建立的索引就是二级索引</p><h2 id="聚簇索引和二级索引有什么区别？"><a href="#聚簇索引和二级索引有什么区别？" class="headerlink" title="聚簇索引和二级索引有什么区别？"></a>聚簇索引和二级索引有什么区别？</h2><ul><li>聚簇索引的叶子节点存放行数据，二级索引的叶子节点存放索引列的值和主键</li><li>二级索引需要回表查询，也就是二次查询，而聚簇索引不需要<br><img src="http://p1-tt.byteimg.com/large/pgc-image/818ae93727da4ced81edc2ba548541bb?from=pc" alt="http://p1-tt.byteimg.com/large/pgc-image/818ae93727da4ced81edc2ba548541bb?from=pc"></li></ul><h2 id="为什么选择B-树作为数据库索引结构？"><a href="#为什么选择B-树作为数据库索引结构？" class="headerlink" title="为什么选择B+树作为数据库索引结构？"></a>为什么选择B+树作为数据库索引结构？</h2><p><a href="https://www.cnblogs.com/kkbill/p/11381783.html">https://www.cnblogs.com/kkbill/p/11381783.html</a><br>首先需要理解的是<code>b树</code>和<code>b+树</code>的区别；</p><h3 id="b树"><a href="#b树" class="headerlink" title="b树"></a>b树</h3><p>b树就是平衡的多路搜索树，b树通常意味着所有的值都是按顺序存储的，并且每一个叶子也到根的距离相同，所谓的m阶B树，即m路平衡搜索树；一颗m阶b树满足以下条件：</p><ul><li>每个结点至多含有m个分支节点（m&gt;&#x3D;2）。</li><li>除根结点之外的每个非叶结点，至少含有m&#x2F;2个分支。</li><li>若根结点不是叶子结点，则至少有2个孩子。</li><li>一个含有k个孩子的非叶结点包含k-1个关键字。 （每个结点内的关键字按升序排列）<br>所有的叶子结点都出现在同一层。实际上这些结点并不存在，可以看作是外部结点。</li><li>所有的叶子结点都出现在同一层。<h3 id="b-树相对于b树的区别"><a href="#b-树相对于b树的区别" class="headerlink" title="b+树相对于b树的区别"></a>b+树相对于b树的区别</h3></li><li>叶子结点包含全部关键字以及行记录数据（或指针）</li><li>叶子结点连接在一起，组成一个链表，利于范围搜索</li><li>非叶子结点不存放真正的数据，只存放关键字，利于同样大小的磁盘页可以容纳更多的关键字（节点元素），相对应的树的高度就越小，发生io的次数就越少</li></ul><h2 id="索引优化-原则"><a href="#索引优化-原则" class="headerlink" title="索引优化(原则)"></a>索引优化(原则)</h2><ul><li>应该选择基数大的字段作为索引</li><li>数据类型要和索引字段类型一致,如果varchar字段,用数字查询不能使用索引</li><li>多列索引需要遵循左侧前缀匹配原则,多列索引组成一个索引,比较的时候是从左到右匹配 </li><li>不在索引列做计算</li><li>字符串做索引需要避免索引长度过长问题（mysql的索引底层是一个b+树，每个节点对应一个磁盘页，能够容纳的大小是有限，如果索引越小，就能容纳更多key，树的高度就越低，发出io次数就越少，性能就越高）</li></ul><h2 id="常用索引命令"><a href="#常用索引命令" class="headerlink" title="常用索引命令"></a>常用索引命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 查看表所有索引</span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> users;</span><br><span class="line"># 创建索引,如果是<span class="type">CHAR</span>，<span class="type">VARCHAR</span>类型，length可以小于字段实际长度；如果是<span class="type">BLOB</span>和TEXT类型，必须指定 length</span><br><span class="line"><span class="keyword">create</span> index index<span class="operator">-</span>name <span class="keyword">on</span> users(name(<span class="number">10</span>));</span><br><span class="line"># 创建唯一索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index index<span class="operator">-</span>name <span class="keyword">on</span> users(name(<span class="number">10</span>))</span><br><span class="line"># 创建索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> users <span class="keyword">add</span> index index<span class="operator">-</span>name(name(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> users <span class="keyword">add</span> <span class="keyword">primary</span> key(id);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> users <span class="keyword">add</span> <span class="keyword">unique</span> index<span class="operator">-</span>name(name(<span class="number">10</span>));</span><br><span class="line"># 删除索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> users <span class="keyword">drop</span> index index<span class="operator">-</span>name;</span><br><span class="line"><span class="keyword">drop</span> index index<span class="operator">-</span>name <span class="keyword">on</span> users;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://blog.csdn.net/qq_35495339/article/details/89304012">https://blog.csdn.net/qq_35495339/article/details/89304012</a></p><ul><li><code>in</code>,<code>or</code>可以命中索引,<code>in</code>比<code>union all</code>消耗更多cpu,但是一般推荐用<code>in</code></li><li>负向条件不可以应用索引,包括<code>!=</code>、<code>&lt;&gt;</code>、<code>not in</code>、<code>not exists</code>、<code>not like</code>,可以优化为<code>in</code>查询 </li><li>最左侧查询需求，并不是指 SQL 语句的 where 顺序要和联合索引一致</li><li>范围查询可以使用索引,但是范围列后面的列无法用到索引,例如联合索引 (empno、title、fromdate,其中sql语句为<code>select * fromemployees.titles where emp_no &lt; 10010&#39; and title=&#39;Senior Engineer&#39;and from_date between &#39;1986-01-01&#39; and &#39;1986-12-31&#39;</code>,那么只有 emp_no 可以用到索引，而 title 和 from_date 则使用不到索引</li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.toutiao.com/i6732776474308248072/&quot;&gt;https://</summary>
      
    
    
    
    <category term="MySql" scheme="https://timmy6.github.io/categories/MySql/"/>
    
    
    <category term="数据库优化" scheme="https://timmy6.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>mysql主从复制和读写分离</title>
    <link href="https://timmy6.github.io/2019/11/25/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%92%8C%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <id>https://timmy6.github.io/2019/11/25/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%92%8C%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</id>
    <published>2019-11-25T14:15:10.000Z</published>
    <updated>2022-05-17T06:10:33.751Z</updated>
    
    <content type="html"><![CDATA[<p>一致性是指多副本中的数据一致性问题,可以分为强一致性,顺序一致性,弱一致性</p><h2 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h2><p>在任意时刻，所有节点中的数据是一样的,例如，例如主从数据库,主库更新一个数据后,可以从从库读取到</p><p>可以指定复制所有库,指定库,或者指定表</p><h2 id="主从复制的优点"><a href="#主从复制的优点" class="headerlink" title="主从复制的优点"></a>主从复制的优点</h2><ul><li>主库负责写,从库负责读,可以分配负载以提高性能</li><li>数据备份,从库可以作为备份数据库</li></ul><h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p><img src="/images/other/mysql.webp" alt="https://upload-images.jianshu.io/upload_images/11414906-1e1d8aaa7a86af96.png?imageMogr2/auto-orient/strip|imageView2/2/w/799/format/webp"></p><ul><li>主库开启二进制日志</li><li>主库将sql语句通过<code>io线程</code>保存在二进制日志<code>binary log</code></li><li>从库启动<code>io线程</code>,读取主库的<code>binary log</code>到自己的中继日志<code>realy log</code></li><li>从库开启<code>sql线程</code>,定时检查<code>realy log</code>,然后执行<code>realy log</code>语句</li><li>从库会记录主库二级制日志的坐标,所以从库可以暂停恢复继续处理</li></ul><h2 id="docker启动mysql容器"><a href="#docker启动mysql容器" class="headerlink" title="docker启动mysql容器"></a>docker启动mysql容器</h2><p><a href="https://www.cnblogs.com/sablier/p/11605606.html">https://www.cnblogs.com/sablier/p/11605606.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 镜像为mysql:5.7</span></span><br><span class="line">docker run -p 13306:3306 --name mysql_1 --network mysql-network -e MYSQL_ROOT_PASSWORD=123456 -d mysql:v57</span><br><span class="line"><span class="comment"># 进入容器 </span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql_1 /bin/bash</span><br><span class="line"><span class="comment"># 允许root远程登录mysql</span></span><br><span class="line">grant all privileges on *.* to root@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&quot;password&quot;</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h2 id="主库配置"><a href="#主库配置" class="headerlink" title="主库配置"></a>主库配置</h2><p>创建用户 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用于复制数据的用户,并只赋予replication权限</span></span><br><span class="line">create user <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">grant replication slave on *.* to repl@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="comment"># 导出主库已经存在的数据</span></span><br><span class="line">mysqldump  -u用户名  -p密码  --all-databases  --master-data=1 &gt; dbdump.db</span><br></pre></td></tr></table></figure><p>配置<code>my.cnf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker默认路径`/etc/mysql/my.cnf`</span></span><br><span class="line">vi /etc/mysql/my.cnf</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">server-id=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">/etc/init.d/mysqld restart</span><br></pre></td></tr></table></figure><ul><li>server-id 为0时,表示主库拒绝任何来自从库的连接</li><li>主从库server-id不能冲突，主要Master要依靠server_id来决定是否执行event。从库会把主库的event发送回主库???</li><li>多个从库的server-id不能冲突，server-id用来表示从库连接</li></ul><h2 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h2><p>配置<code>my.cnf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">/etc/init.d/mysqld restart</span><br><span class="line"><span class="comment"># 设置主库信息</span></span><br><span class="line">change master to master_host=<span class="string">&#x27;mysql_1&#x27;</span>,master_user=<span class="string">&#x27;repl&#x27;</span>,master_password=<span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">start slave;</span><br><span class="line"><span class="comment"># 查看是否成功</span></span><br><span class="line">show slave status\G</span><br></pre></td></tr></table></figure><h2 id="测试sql"><a href="#测试sql" class="headerlink" title="测试sql"></a>测试sql</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建users表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> users( id <span class="type">int</span>(<span class="number">11</span>) auto_increment, name <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="keyword">null</span>, age <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="number">0</span>, <span class="keyword">primary</span> key(id) )engine<span class="operator">=</span>InnoDB <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"># 插入一条数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> users(name,age) <span class="keyword">values</span>(<span class="string">&#x27;wuzhc&#x27;</span>,<span class="number">20</span>),(<span class="string">&#x27;mayun&#x27;</span>,<span class="number">65</span>);</span><br></pre></td></tr></table></figure><h2 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h2><p>当master上写操作繁忙时，当前POS点例如是10，而slave上IO_THREAD线程接收过来的是3，此时master宕机，会造成相差7个点未传送到slave上而数据丢失</p><ul><li>异步复制</li><li>半同步复制</li></ul><h2 id="常见的错误"><a href="#常见的错误" class="headerlink" title="常见的错误"></a>常见的错误</h2><p><code>sql_slave_skip_counter</code>表示跳过复制错误</p><ul><li>master上删除一条记录，而slave上找不到 <ul><li><code>set global sql_slave_skip_counter=1;</code></li></ul></li><li>主键重复。在slave已经有该记录，又在master上插入了同一条记录<ul><li>删除从库重复的记录</li></ul></li><li>在master上更新一条记录，而slave上找不到，丢失了数据<ul><li>从库补充数据,跳过<code>set global sql_slave_skip_counter=1;</code></li></ul></li></ul><h2 id="恢复relay-log日志"><a href="#恢复relay-log日志" class="headerlink" title="恢复relay-log日志"></a>恢复relay-log日志</h2><p>从库有两个线程,一个是<code>Slave_IO_Running</code>,一个是<code>Slave_SQL_Running</code></p><h3 id="Slave-IO-Running-：接收master的binlog信息"><a href="#Slave-IO-Running-：接收master的binlog信息" class="headerlink" title="Slave_IO_Running ：接收master的binlog信息"></a>Slave_IO_Running ：接收master的binlog信息</h3><ul><li>Master_Log_File</li><li>Read_Master_Log_Pos<h3 id="Slave-SQL-Running：执行写操作"><a href="#Slave-SQL-Running：执行写操作" class="headerlink" title="Slave_SQL_Running：执行写操作"></a>Slave_SQL_Running：执行写操作</h3></li><li>Relay_Master_Log_File</li><li>Exec_Master_Log_Pos<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line"><span class="comment"># MASTER_LOG_FILE对应Relay_Master_Log_File,MASTER_LOG_POS对应Exec_Master_Log_Pos</span></span><br><span class="line">CHANGE MASTER TO MASTER_LOG_FILE=<span class="string">&#x27;mysql-bin.000001&#x27;</span>,MASTER_LOG_POS=1609;</span><br><span class="line">start slave;</span><br><span class="line">show slave status\G;</span><br></pre></td></tr></table></figure></li></ul><h2 id="mysql自定义dock镜像"><a href="#mysql自定义dock镜像" class="headerlink" title="mysql自定义dock镜像"></a>mysql自定义dock镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM mysql:5.7</span><br><span class="line">RUN sed -i <span class="string">&quot;s@http://deb.debian.org@http://mirrors.aliyun.com@g&quot;</span> /etc/apt/sources.list \</span><br><span class="line">&amp;&amp; sed -i <span class="string">&quot;s@http://security.debian.org@http://mirrors.aliyun.com@g&quot;</span> /etc/apt/sources.list \</span><br><span class="line">&amp;&amp; <span class="built_in">rm</span> -Rf /var/lib/apt/lists/* \</span><br><span class="line">&amp;&amp; apt-get update \</span><br><span class="line">&amp;&amp; apt-get install vim -y \</span><br><span class="line">&amp;&amp; apt-get install iputils-ping -y \</span><br><span class="line">&amp;&amp; apt-get install net-tools -y \</span><br><span class="line">&amp;&amp; apt-get install ssh -y </span><br></pre></td></tr></table></figure><h2 id="主从复制需要考虑哪些问题？"><a href="#主从复制需要考虑哪些问题？" class="headerlink" title="主从复制需要考虑哪些问题？"></a>主从复制需要考虑哪些问题？</h2><h3 id="主从复制延迟"><a href="#主从复制延迟" class="headerlink" title="主从复制延迟"></a>主从复制延迟</h3><ul><li>升级从库配置</li><li>升级mysql到5.6之后，采用并行复制</li><li>分库</li><li>写一份数据到redis，读从库没有数据时从redis读</li><li>更改读库的方式</li><li>使用事务<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3>同一个事务的sql发到同个从库</li></ul><h2 id="主从复制有哪些方式？"><a href="#主从复制有哪些方式？" class="headerlink" title="主从复制有哪些方式？"></a>主从复制有哪些方式？</h2><ul><li>半同步复制；防止主库挂掉后数据丢失（半同步复制确保事务提交后binlog至少传输到一个从库，只是传输到从库，不保证从库应用完这个事务的binlog ）</li><li>并行复制；主要解决主从复制延迟问题</li></ul><h2 id="如何查看主从延迟的时间？"><a href="#如何查看主从延迟的时间？" class="headerlink" title="如何查看主从延迟的时间？"></a>如何查看主从延迟的时间？</h2><p>通过在从库执行命令<code>show status</code>，其中<code>Seconds_Behind_Master</code>可以反映延迟时间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一致性是指多副本中的数据一致性问题,可以分为强一致性,顺序一致性,弱一致性&lt;/p&gt;
&lt;h2 id=&quot;强一致性&quot;&gt;&lt;a href=&quot;#强一致性&quot; class=&quot;headerlink&quot; title=&quot;强一致性&quot;&gt;&lt;/a&gt;强一致性&lt;/h2&gt;&lt;p&gt;在任意时刻，所有节点中的数据是一样</summary>
      
    
    
    
    <category term="MySql" scheme="https://timmy6.github.io/categories/MySql/"/>
    
    
    <category term="数据库优化" scheme="https://timmy6.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>一些常用的命令</title>
    <link href="https://timmy6.github.io/2019/11/16/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    <id>https://timmy6.github.io/2019/11/16/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/</id>
    <published>2019-11-16T14:15:10.000Z</published>
    <updated>2022-05-17T05:44:51.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些常用的命令"><a href="#一些常用的命令" class="headerlink" title="一些常用的命令"></a>一些常用的命令</h1><h3 id="查看端口占用情况"><a href="#查看端口占用情况" class="headerlink" title="查看端口占用情况"></a>查看端口占用情况</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp:8989</span><br></pre></td></tr></table></figure><p>eg: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp:80</span><br><span class="line"></span><br><span class="line">COMMAND    PID        USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME</span><br><span class="line">Google     328 mengyueping  181u  IPv4 0x393cc3d704a30853      0t0  TCP bogon:65200-&gt;202.108.249.246:http (ESTABLISHED)</span><br></pre></td></tr></table></figure><h3 id="杀死正在运行的服务"><a href="#杀死正在运行的服务" class="headerlink" title="杀死正在运行的服务"></a>杀死正在运行的服务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -9 应用的pid</span><br><span class="line">kill -9 $(pgrep 应用名字)</span><br></pre></td></tr></table></figure><h3 id="查看某个应用进程的-pid"><a href="#查看某个应用进程的-pid" class="headerlink" title="查看某个应用进程的 pid"></a>查看某个应用进程的 <code>pid</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo $(pgrep bee)</span><br><span class="line"># $(pgrep 进程的名字)</span><br><span class="line"></span><br><span class="line">ps -ef | grep 应用名（支持通配符）</span><br></pre></td></tr></table></figure><p>eg: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_3_centos ~]# ps -ef | grep bee</span><br><span class="line">root     16864 16828  0 15:47 pts/0    00:00:00 grep --color=auto bee</span><br><span class="line">root     18955     1  0 6月08 ?       00:00:44 bee run</span><br></pre></td></tr></table></figure><h3 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        3881904      861012      469244         480     2551648     2712060</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 单位为 megabytes</span><br><span class="line">free -m</span><br></pre></td></tr></table></figure><blockquote><p><code>total</code> : 总计物理内存大小</p></blockquote><blockquote><p><code>used</code> : 已使用多大</p></blockquote><blockquote><p><code>free</code> : 可用有多少</p></blockquote><blockquote><p><code>shared</code> : 多个进程共享的内存总额</p></blockquote><blockquote><p><code>buff/cache</code> :磁盘缓存的大小</p></blockquote><h3 id="查看磁盘空间"><a href="#查看磁盘空间" class="headerlink" title="查看磁盘空间"></a>查看磁盘空间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/vda1        50G  6.6G   41G   15% /</span><br><span class="line">devtmpfs        1.9G     0  1.9G    0% /dev</span><br><span class="line">tmpfs           1.9G   24K  1.9G    1% /dev/shm</span><br><span class="line">tmpfs           1.9G  444K  1.9G    1% /run</span><br><span class="line">tmpfs           1.9G     0  1.9G    0% /sys/fs/cgroup</span><br><span class="line">tmpfs           380M     0  380M    0% /run/user/0</span><br></pre></td></tr></table></figure><ul><li>查看某个目录的大小：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># du -sh [目录名] 返回该目录的大小</span><br><span class="line">du -sh ./src</span><br><span class="line">272M./src</span><br></pre></td></tr></table></figure><ul><li>查看指定文件夹下的所有文件大小（包含子文件夹）：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h ../src/</span><br></pre></td></tr></table></figure><h3 id="查看内核-x2F-操作系统-x2F-CPU信息的linux系统信息命令"><a href="#查看内核-x2F-操作系统-x2F-CPU信息的linux系统信息命令" class="headerlink" title="查看内核&#x2F;操作系统&#x2F;CPU信息的linux系统信息命令"></a>查看内核&#x2F;操作系统&#x2F;CPU信息的linux系统信息命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br><span class="line">Linux VM_0_3_centos 3.10.0-514.26.2.el7.x86_64 #1 SMP Tue Jul 4 15:04:05 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><h3 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一些常用的命令&quot;&gt;&lt;a href=&quot;#一些常用的命令&quot; class=&quot;headerlink&quot; title=&quot;一些常用的命令&quot;&gt;&lt;/a&gt;一些常用的命令&lt;/h1&gt;&lt;h3 id=&quot;查看端口占用情况&quot;&gt;&lt;a href=&quot;#查看端口占用情况&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Linux" scheme="https://timmy6.github.io/categories/Linux/"/>
    
    
    <category term="常用命令" scheme="https://timmy6.github.io/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>数据库结构设计</title>
    <link href="https://timmy6.github.io/2019/11/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>https://timmy6.github.io/2019/11/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2019-11-05T14:15:10.000Z</published>
    <updated>2022-05-17T02:16:36.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库结构设计"><a href="#数据库结构设计" class="headerlink" title="数据库结构设计"></a>数据库结构设计</h2><ul><li><p>减少数据冗余</p></li><li><p>尽量避免数据维护中出现更新，插入和删除异常</p><ul><li>插入异常：如果表中的某个实体随着另一个实体而存在</li><li>更新异常：如果更改表中的某个实体的单独属性时，需要对多行进行更新</li><li>删除异常：如果删除表中的某一实体则会导致其他实体的消失</li></ul></li><li><p>节约数据存储空间</p></li><li><p>提高查询效率</p></li></ul><h2 id="数据库结构设计的步骤"><a href="#数据库结构设计的步骤" class="headerlink" title="数据库结构设计的步骤"></a>数据库结构设计的步骤</h2><ul><li><ol><li>需求分析：全面了解产品设计的存储需求</li></ol><ul><li>存储需求</li><li>数据处理需求 </li><li>数据的安全性和完整性</li></ul></li><li><ol start="2"><li>逻辑设计：设计数据的逻辑存储结构</li></ol><ul><li>数据实体之间的逻辑关系，解决数据冗余和数据维护异常</li></ul></li><li><ol start="3"><li>物理设计：根据所使用的数据库特点进行表结构设计</li></ol><ul><li>关系型数据库：Oralce，SQLServer，Mysql，postgresSQL</li><li>非关系型数据库：mongo，Redis，Hadoop</li><li>存储引擎： Innodb</li></ul></li><li><ol start="4"><li>维护优化：根据实际情况对索引，存储结构等进行优化</li></ol></li></ul><h2 id="数据库设计范式"><a href="#数据库设计范式" class="headerlink" title="数据库设计范式"></a>数据库设计范式</h2><p>设计出没有数据冗余和数据维护异常的数据库结构。</p><ul><li>数据库设计的第一范式：<ul><li>数据库表中的所有字段都只具有单一属性</li><li>单一属性的列是由基本的数据类型所构成的</li><li>设计出来的表都是简单的二维表</li></ul></li><li>数据库设计的第二范式：<ul><li>要求一个表中只具有一个业务主键，也就是说符合第二范式的表中不能存在非主键列对只对部分主键的依赖关系。</li></ul></li><li>数据库设计的第三范式：<ul><li>指每一个非主属性既不部分依赖于也不传递依赖于业务主键，也就是在第二范式的基础上消除了非主属性对主键的传递依赖。</li></ul></li></ul><h2 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h2><p>根据所选择的关系型数据库的特点，对逻辑模型进行存储结构设计。包括：</p><ul><li>定义数据库、表及字段的命名规范</li><li>选择合适的存储引擎</li><li>为表中的字段选择合适的数据类型</li><li>建立数据库表具体结构</li></ul><h3 id="定义数据库、表及字段的命名规范"><a href="#定义数据库、表及字段的命名规范" class="headerlink" title="定义数据库、表及字段的命名规范"></a>定义数据库、表及字段的命名规范</h3><p>数据库、表及字段的命名要遵守：</p><ul><li>可读性原则</li><li>表意性原则</li><li>长名原则</li></ul><h3 id="选择合适的存储引擎"><a href="#选择合适的存储引擎" class="headerlink" title="选择合适的存储引擎"></a>选择合适的存储引擎</h3><table><thead><tr><th>存储引擎</th><th>事务</th><th>锁粒度</th><th>主要应用</th><th>忌用</th></tr></thead><tbody><tr><td>MyISAM</td><td>不支持</td><td>支持并发插入的表级锁</td><td>select，insert</td><td>读写操作频繁</td></tr><tr><td>MRG_MYISAM</td><td>不支持</td><td>支持并发插入的表级锁</td><td>分段归档，数据仓库</td><td>全局查找过多的场景</td></tr><tr><td>Innodb</td><td>支持</td><td>支持MVCC的行级锁</td><td>事务处理</td><td>无</td></tr><tr><td>Archive</td><td>不支持</td><td>行级锁</td><td>日志记录，只支持insert，select</td><td>需要随机读取，更新，删除</td></tr><tr><td>Ndb cluster</td><td>支持</td><td>行级锁</td><td>高可用性</td><td>大部分应用</td></tr></tbody></table><h3 id="数据类型的选择"><a href="#数据类型的选择" class="headerlink" title="数据类型的选择"></a>数据类型的选择</h3><p>为表中的字段选择合适的数据类型：</p><ul><li>当一个列可以选择多种数据类型时，应该优先考虑数字类型。</li><li>其次是日期或二进制类型</li><li>最后是字符类型。</li><li>对于相同级别的数据类型，应该优先选择占用空间小的数据类型。</li></ul><p>在对数据进行比较（查询条件、Join条件有关联排序时）：字符类型是与排序规则有关系；而数字类型和二进制类型不需要参照这种这种规则，是按照二进制大小进行排序的，同样的数据字符类型处理就比较慢。</p><p>数据库中数据存储是以页为单位的，每一页存储的数据量是一定的，Innodb中是16k，数据的长度越小，在每页中能容纳的数据行数就越多，这样在加载同样的数据时，使用的宽度较小的类型就比宽度较大的类型加载的数据页较少，也就减少了磁盘IO，有利于性能的提升。</p><h4 id="如何选择正确的整数类型"><a href="#如何选择正确的整数类型" class="headerlink" title="如何选择正确的整数类型"></a>如何选择正确的整数类型</h4><table><thead><tr><th>列类型</th><th>存储空间</th><th>取值范围（SIGNED）</th><th>取值范围（UNSIGNED）</th></tr></thead><tbody><tr><td>tinyint</td><td>1个字节</td><td>-128~127 (2^7 ~ 2^7-1)</td><td>0~255</td></tr><tr><td>smallint</td><td>2个字节</td><td>-32768 ~ 32767</td><td>0~65535</td></tr><tr><td>mediumint</td><td>3个字节</td><td>-8388608 ~ 8388607</td><td>0~16777215</td></tr><tr><td>int</td><td>4个字节</td><td>-2147483648 ~ 2147483647</td><td>0~4294967295</td></tr><tr><td>bigint</td><td>8个字节</td><td>-9223372036854775808 ~ 9223372036854775807</td><td>0 ~ 18446744073709551615</td></tr></tbody></table><p>如果只存储两位数，就使用 tinyint 类型，不要使用 int 类型，可以节约空间。</p><h4 id="如何选择正确的实数类型"><a href="#如何选择正确的实数类型" class="headerlink" title="如何选择正确的实数类型"></a>如何选择正确的实数类型</h4><table><thead><tr><th>列类型</th><th>存储空间</th><th>是否精确类型</th></tr></thead><tbody><tr><td>FLOAT</td><td>4个字节</td><td>否</td></tr><tr><td>DOUBLE</td><td>8个字节</td><td>否</td></tr><tr><td>DECIMAL</td><td>每4个字节存9个数字，小数点占一个字节</td><td>是</td></tr></tbody></table><p>DECIMAL(18,9) 需要 9 个字节来存储。</p><h4 id="如何选择-VARCHAR-和-CHAR-类型"><a href="#如何选择-VARCHAR-和-CHAR-类型" class="headerlink" title="如何选择 VARCHAR 和 CHAR 类型"></a>如何选择 VARCHAR 和 CHAR 类型</h4><ul><li><p>VARCHAR 类型的存储特点：</p><ul><li>varchar 用于存储变长字符串，只占用必要的存储空间</li><li>列的最大长度小于255则只占用一个额外字节用于记录字符串长度</li><li>列的最大长度大于255则要占用两个额外字节用于记录字符串长度</li></ul></li><li><p>VARCHAR 长度的选择问题</p><ul><li>使用最小的符合需求的长度</li><li>varchar(5)和varchar(200)存储’Mysql’字符串性能不同<ul><li>mysql 为了更有效的优化查询，在内存中对字符串的使用是固定的宽度，列太长就会消耗更多的内存。</li></ul></li></ul></li><li><p>VARCHAR 的适用场景：</p><ul><li>字符串列的最大长度比平均长度大很多（发挥变长存储的特点）</li><li>字符串列很少被更新（更新，字符串长度会产生变化，可能引起存储页的分裂；还会产生很多存储碎片）</li><li>使用了多字节字符集存储字符串（例如utf8，不同字符存储字节数不同，中文和英文就不同）</li></ul></li><li><p>CHAR 类型的存储特点：</p><ul><li>CHAR 类型是定长的</li><li>字符串存储在 CHAR 类型的列中会删除末尾的空格</li><li>CHAR 类型的最大宽度为 255</li></ul></li><li><p>CHAR 的适用场景：</p><ul><li>CHAR 类型适合存储所有长度近似的值 （eg： md5值，身份证号，手机号）</li><li>CHAR 类型适合存储短字符串</li><li>CHAR 类型适合存储经常更新的字符串列</li></ul></li></ul><h4 id="如何存储日期类型"><a href="#如何存储日期类型" class="headerlink" title="如何存储日期类型"></a>如何存储日期类型</h4><ul><li>DATATIME 类型</li></ul><p>以 <code>YYYY-MM-DD HH:MM:SS[.fraction]</code> 格式存储日期时间</p><p>datetime &#x3D; YYYY-MM-DD HH:MM:SS</p><p>datetime(6) &#x3D; YYYY-MM-DD HH:MM:SS.fraction</p><p>DATATIME类型与时区无关，占用8个字节的存储空间</p><p>时间范围：1000-01-01 00:00:00 到 9999-12-31 23:59:59</p><ul><li>TIMESTAMP 类型</li></ul><p>时间戳，存储了由格林尼治时间1970年1月1日到当前时间的秒数</p><p>以 YYYY-MM-DD HH:MM:SS.[.fraction] 的格式显示，占用4个字节。</p><p>时间范围： 1970-01-01 到 2038-01-19</p><p>timestamp 类型显示依赖于所指定的时区</p><p>在行的数据修改时，可以自动修改 timestamp 列的值。</p><ul><li>date类型</li></ul><blockquote><p>存储用户生日时，只需要存储日期部分</p></blockquote><p>一是把日期部分存储为字符串（至少要8个字节）</p><p>二是使用int类型来存储（4个字节）</p><p>三是使用datetime类型来存储（8个字节）</p><p>date 类型的优点：</p><ol><li><p>占用的字节数比使用字符串、datetime、int存储要少，使用date类型只需要3个字节。</p></li><li><p>使用Date类型还可以利用日期时间函数进行日期之间的计算</p></li></ol><p>date类型用于保存 1000-01-01 到 9999-12-31 之间的日期</p><ul><li>time类型</li></ul><p>time类型用于存储时间数据，格式为：HH:MM:SS </p><ul><li><p>存储日期时间数据的注意事项</p><ul><li>不要使用字符串类型来存储日期时间数据<ul><li>日期时间类型通常比字符串占用的存储空间小</li><li>日期时间类型在进行查找过滤时可以利用日期来进行对比</li><li>日期时间类型还有着丰富的处理函数，可以方便的对时期类型进行日期计算</li></ul></li><li>使用Int存储日期时间不如使用 Timestamp 类型</li></ul></li></ul><h3 id="如何为-Innodb-选择主键"><a href="#如何为-Innodb-选择主键" class="headerlink" title="如何为 Innodb 选择主键"></a>如何为 Innodb 选择主键</h3><ul><li>主键应该尽可能的小</li><li>主键应该是顺序增长的<ul><li>（Innodb 内部的逻辑顺序是和主键顺序相同的，主键的顺序是顺序增长的，那么插入数据就能顺序插入，避免了随机IO的产生，所以这样可以增加数据的插入效率）</li></ul></li><li>Innodb 的主键和业务主键可以不同 （业务主键可以添加唯一索引）</li></ul><p>数据库结构：（查询性能要求、范式化要求）</p><p>从数据库架构方面优化数据库；<br>维护和优化：索引&amp;sql优化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据库结构设计&quot;&gt;&lt;a href=&quot;#数据库结构设计&quot; class=&quot;headerlink&quot; title=&quot;数据库结构设计&quot;&gt;&lt;/a&gt;数据库结构设计&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;减少数据冗余&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尽量避免数据维护中出现更新，插入和</summary>
      
    
    
    
    <category term="MySql" scheme="https://timmy6.github.io/categories/MySql/"/>
    
    
    <category term="数据库优化" scheme="https://timmy6.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>mysql基准测试</title>
    <link href="https://timmy6.github.io/2019/10/15/mysql%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/"/>
    <id>https://timmy6.github.io/2019/10/15/mysql%E5%9F%BA%E5%87%86%E6%B5%8B%E8%AF%95/</id>
    <published>2019-10-15T15:15:10.000Z</published>
    <updated>2022-05-17T02:14:22.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="MySQL基准测试"><a href="#MySQL基准测试" class="headerlink" title="MySQL基准测试"></a>MySQL基准测试</h2><ul><li><p>基准测试</p><ul><li>是一种测量和评估软件性能指标的活动，用于建立某个时刻的性能基准，以便当系统发生软硬件变化时，重新进行基准测试以评估变化对性能影响。</li><li>直接、简单、易于比较，用于评估服务器的处理能力</li><li>可能不关心业务逻辑，所使用的查询和业务的真实性可以和业务环境没关系</li></ul></li><li><p>压力测试：</p><ul><li>对真实的业务数据进行测试，获得真实系统所能承受的压力</li><li>针对不同主题，所使用的数据和查询也是真实用到的（比如购物车流程，报名流程）</li></ul></li></ul><h2 id="基准测试目的："><a href="#基准测试目的：" class="headerlink" title="基准测试目的："></a>基准测试目的：</h2><ul><li>建立 mysql 服务器的性能基准线<ul><li>确定当前 mysql 服务器运行情况</li></ul></li><li>模拟比当系统更高的负载，以找出系统的扩展瓶颈<ul><li>增加数据库并发，观察 QPS，TPS变化，确定并发量与性能最优的关系</li></ul></li><li>测试不同的硬件、软件和操作系统配置</li><li>证明新的硬件设备是否配置正确</li></ul><h2 id="如何进行基准测试"><a href="#如何进行基准测试" class="headerlink" title="如何进行基准测试"></a>如何进行基准测试</h2><ul><li><p>对整个系统进行基准测试</p><ul><li>从系统入口进行测试（如网站Web前端，手机APP前端）</li><li>优点：<ul><li>能够测试整个系统的性能，包括web服务器缓存、数据库等</li><li>能反映出系统中各个组件接口间的性能问题体现真实性能状况</li></ul></li><li>缺点：测试设计复杂，消耗时间长</li></ul></li><li><p>单独对 mysql 进行基准测试</p><ul><li>优点：<ul><li>测试设计简单，消耗时间短</li></ul></li><li>缺点：无法全面了解整个系统的性能基线</li></ul></li></ul><h2 id="mysql-基准测试的常见指标"><a href="#mysql-基准测试的常见指标" class="headerlink" title="mysql 基准测试的常见指标"></a>mysql 基准测试的常见指标</h2><ul><li>单位时间内所处理的事务数 （TPS）</li><li>单位时间内所处理的查询数 （QPS）</li><li>响应时间<ul><li>平均响应时间、最小响应时间、最大响应时间、各时间所占百分比</li></ul></li><li>并发量：同时处理的查询请求的数量 <ul><li>（并发量不等于连接数）</li><li>正在工作中的并发的操作数 或 同时工作的数量</li></ul></li></ul><h2 id="设计基准测试"><a href="#设计基准测试" class="headerlink" title="设计基准测试"></a>设计基准测试</h2><ul><li><p>对整个系统还是某一组件</p></li><li><p>使用什么样的数据</p></li><li><p>准备基准测试及数据收集脚本</p><ul><li>CPU使用率、IO、网络流量、状态与计数器信息等</li></ul></li><li><p>运行基准测试</p></li><li><p>保存及分析基准测试</p></li></ul><h2 id="基准测试中容易忽略的问题"><a href="#基准测试中容易忽略的问题" class="headerlink" title="基准测试中容易忽略的问题"></a>基准测试中容易忽略的问题</h2><ul><li><p>使用功能生产环境数据时，只使用了部分数据</p><ul><li>推荐：使用生产环境数据库完全备份来测试</li></ul></li><li><p>在多用户场景中，只做单用户的测试</p><ul><li>推荐：使用多线程并发测试</li></ul></li><li><p>在单服务器上测试分布式应用</p><ul><li>推荐：使用相同架构进行测试</li></ul></li><li><p>返回执行同一个查询</p><ul><li>容易缓存命中，无法反应真实查询性能。</li></ul></li></ul><h2 id="基准测试工具"><a href="#基准测试工具" class="headerlink" title="基准测试工具"></a>基准测试工具</h2><h3 id="mysqlslap"><a href="#mysqlslap" class="headerlink" title="mysqlslap"></a>mysqlslap</h3><p><code>mysqlslap</code> ： mysql自带的基准测试工具，随 mysql 一起安装。</p><ul><li><p>可以模拟服务器负载，并输出相关统计信息</p></li><li><p>可以指定也可以自动生成查询语句</p></li><li><p>常用参数说明：</p><ul><li><p><code>--auto-generate-sql</code> 由系统自动生成 SQL 脚本进行测试</p></li><li><p><code>--auto-generate-sql-add-autoincrement</code> 在生成的表中增加自增ID</p></li><li><p><code>--auto-generate-sql-load-type</code> 指定测试中使用的查询类型 (混合、读写、删除)</p></li><li><p><code>--auto-generate-sql-write-number</code> 指定初始化数据时生成的数据量</p></li><li><p><code>--concurrency</code> 指定并发线程的数量</p></li><li><p><code>--engine</code> 指定要测试表的存储引擎，可以用逗号分割多个存储引擎</p></li><li><p><code>--no-drop</code> 指定不清理测试数据</p></li><li><p><code>--iterations</code> 指定测试运行的次数</p></li><li><p><code>--number-of-queries</code> 指定每一个线程执行的查询数量</p></li><li><p><code>--debug-info</code> 指定输出额外的内存及CPU统计信息</p></li><li><p><code>--number-int-cols</code> 指定测试表中包含的 INT 类型列的数量</p></li><li><p><code>--number-char-cols</code> 指定测试表中包含的 varchar 类型的数量</p></li><li><p><code>--create-schema</code> 指定了用于执行测试的数据库的名字</p></li><li><p><code>--query</code> 用户指定自定义 SQL 的脚本</p></li><li><p><code>--only-print</code> 并不运行测试脚本，而是把生成的脚本打印出来</p></li></ul></li></ul><p>mysql 表中列不要太多，可以使用 <code>--number-int-cols</code> 和 <code>--number-char-cols</code> 对列的数量进行控制，得出列的数量和性能之间的关系。</p><h3 id="sysbench"><a href="#sysbench" class="headerlink" title="sysbench"></a>sysbench</h3><p><a href="https://github.com/akopytov/sysbench">https://github.com/akopytov/sysbench</a></p><p>多线程基准测试工具</p><ul><li>常用参数：<ul><li><p><code>--test</code> 用于指定所要执行的测试类型，支持以下参数</p><ul><li><code>Fileio</code> 文件系统 I&#x2F;O 性能测试</li><li><code>cpu</code> cpu 性能测试</li><li><code>memory</code> 内存性能测试</li><li><code>Oltp</code> 测试要指定具体的 lua 脚本（Lua脚本位于：sysbench-0.5&#x2F;sysbench&#x2F;tests&#x2F;db）</li></ul></li><li><p><code>--mysql-db</code> 用于指定执行基准测试的数据库名</p></li><li><p><code>--mysql-table-engine</code> 用于指定所使用的存储引擎</p></li><li><p><code>--oltp-tables-count</code> 执行测试的表的数量</p></li><li><p><code>--oltp-table-size</code> 指定每个表中的数据行数</p></li><li><p><code>--num-threads</code> 指定测试的并发线程数量</p></li><li><p><code>--max-time</code> 指定最大的测试时间</p></li><li><p><code>--report-interval</code> 指定间隔多长时间输出一次统计信息</p></li><li><p><code>--mysql-user</code> 指定执行测试的 mysql 用户</p></li><li><p><code>--mysql-password</code> 指定执行测试的 mysql 用户的密码</p></li><li><p><code>prepare</code> 用于准备测试数据</p></li><li><p><code>run</code> 用于实际进行测试</p></li><li><p><code>cleanup</code> 用于清理测试数据</p></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;MySQL基准测试&quot;&gt;&lt;a href=&quot;#MySQL基准测试&quot; class=&quot;headerlink&quot; title=&quot;MySQL基准测试&quot;&gt;&lt;/a&gt;MySQL基准测试&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;基准测试&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;是一种测量和评估软件性能指标的</summary>
      
    
    
    
    <category term="MySql" scheme="https://timmy6.github.io/categories/MySql/"/>
    
    
    <category term="数据库优化" scheme="https://timmy6.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>mysql服务器参数介绍</title>
    <link href="https://timmy6.github.io/2019/09/15/mysql%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D/"/>
    <id>https://timmy6.github.io/2019/09/15/mysql%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D/</id>
    <published>2019-09-15T15:15:10.000Z</published>
    <updated>2022-05-17T02:12:16.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mysql-获取配置信息路径"><a href="#mysql-获取配置信息路径" class="headerlink" title="mysql 获取配置信息路径"></a>mysql 获取配置信息路径</h2><ul><li>命令行</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld_safe --datadir=/data/sql_data</span><br></pre></td></tr></table></figure><ul><li>配置文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysqld --help --verbose | grep -A 1 &#x27;Default options&#x27;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Default options are read from the following files in the given order:</span><br><span class="line">/etc/my.cnf /etc/mysql/my.cnf /usr/etc/my.cnf /usr/local/mysql/my.cnf ~/.my.cnf</span><br></pre></td></tr></table></figure><h2 id="mysql-配置参数的作用域"><a href="#mysql-配置参数的作用域" class="headerlink" title="mysql 配置参数的作用域"></a>mysql 配置参数的作用域</h2><ul><li>全局参数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set global 参数名=参数值;</span><br><span class="line">mysql&gt; set @@global.参数名:=参数值;</span><br></pre></td></tr></table></figure><p>全局参数配置完，需要重新退出才会生效。</p><ul><li>会话参数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; set [session] 参数名=参数值;</span><br><span class="line">mysql&gt; set @@session.参数名:=参数值;</span><br></pre></td></tr></table></figure><h2 id="内存配置相关的参数"><a href="#内存配置相关的参数" class="headerlink" title="内存配置相关的参数"></a>内存配置相关的参数</h2><ul><li><p>确定可以使用的内存上限</p><ul><li>32位操作系统只能使用3g以内的内存</li><li>设置的不能超过物理内存大小</li></ul></li><li><p>确定mysql的每个连接使用的内存</p></li></ul><p><code>sort_buffer_size</code> </p><p><code>join_buffer_size</code></p><p><code>read_buffer_size</code></p><p><code>read_rnd_buffer_size</code></p><ul><li><p>确定需要为操作系统保留多少内存</p></li><li><p>如何为缓存池分配内存</p></li></ul><p>Innodb_buffer_pool_size</p><p>总内存 -（每个线程所需要的内存 * 连接数） - 系统保留内存</p><p>key_buffer_size</p><p>select sum(index_length) from information_schema.tables where engine&#x3D;’myisam’</p><h2 id="IO配置相关的参数"><a href="#IO配置相关的参数" class="headerlink" title="IO配置相关的参数"></a>IO配置相关的参数</h2><h2 id="安全相关配置参数"><a href="#安全相关配置参数" class="headerlink" title="安全相关配置参数"></a>安全相关配置参数</h2><h2 id=""><a href="#" class="headerlink" title=""></a></h2><h1 id="数据库结构优化"><a href="#数据库结构优化" class="headerlink" title="数据库结构优化"></a>数据库结构优化</h1><p>良好的数据库逻辑设计 和 物理设计<br>使查询语句尽量简单</p><ul><li><p>尽量减少数据冗余</p></li><li><p>尽量避免数据维护中出现更新，插入和删除异常</p><ul><li>插入异常：如果表中的某个实体随着另一个实体而存在。</li><li>更新异常：如果更改表中的某个实体的单独属性时，需要对多行进行更新。</li><li>删除异常：如果删除表中的某一实体则会导致其他实体的消失</li></ul></li><li><p>节约数据存储空间</p></li><li><p>提高查询效率</p></li><li><p>设计步骤：</p><ul><li>需求分析：全面了解产品设计的存储需求<ul><li>存储需求</li><li>数据处理需求</li><li>数据的安全性和完整性</li></ul></li><li>逻辑设计：设计数据的逻辑存储结构<ul><li>数据实体之间的逻辑关系，解决数据冗余和数据维护异常</li></ul></li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;mysql-获取配置信息路径&quot;&gt;&lt;a href=&quot;#mysql-获取配置信息路径&quot; class=&quot;headerlink&quot; title=&quot;mysql 获取配置信息路径&quot;&gt;&lt;/a&gt;mysql 获取配置信息路径&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;命令行&lt;/li&gt;
&lt;/ul&gt;
&lt;</summary>
      
    
    
    
    <category term="MySql" scheme="https://timmy6.github.io/categories/MySql/"/>
    
    
    <category term="数据库优化" scheme="https://timmy6.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>sql存储引擎对性能影响</title>
    <link href="https://timmy6.github.io/2019/09/10/mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D/"/>
    <id>https://timmy6.github.io/2019/09/10/mysql%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E%E5%AF%B9%E6%80%A7%E8%83%BD%E5%BD%B1%E5%93%8D/</id>
    <published>2019-09-10T15:15:10.000Z</published>
    <updated>2022-05-17T02:04:54.709Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mysql-体系架构"><a href="#mysql-体系架构" class="headerlink" title="mysql 体系架构"></a>mysql 体系架构</h2><p>插件式存储引擎</p><h2 id="存储引擎：MyISAM"><a href="#存储引擎：MyISAM" class="headerlink" title="存储引擎：MyISAM"></a>存储引擎：MyISAM</h2><p>MySQL5.5之前版本默认存储引擎</p><p>会把索引缓存到内存中，数据缓存到系统中。</p><ul><li>使用 MyISAM 存储引擎的表： <ul><li>系统表</li><li>临时表：在排序、分组等操作中，当数量超过一定的大小之后，由查询优化器所建立的临时表。</li></ul></li></ul><h3 id="创建一个-MyISAM-表"><a href="#创建一个-MyISAM-表" class="headerlink" title="创建一个 MyISAM 表"></a>创建一个 MyISAM 表</h3><p>MyISAM 存储引擎表由 MYD 和 MYI 组成。创建一张 MyISAM 表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> good (id <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="keyword">NULL</span>, name <span class="type">varchar</span>(<span class="number">10</span>) <span class="keyword">default</span> <span class="keyword">NULL</span>) engine<span class="operator">=</span>MyISAM <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#进入到mysql 数据存储目录，/usr/local/mysql/data，对应的数据库目录下： 执行 ls -1</span></span><br><span class="line"><span class="built_in">ls</span> -1</span><br><span class="line">good.MYD </span><br><span class="line">good.MYI</span><br><span class="line">good_5008.sdi</span><br></pre></td></tr></table></figure><ul><li><code>.MYD</code> : 存储数据信息</li><li><code>.MYI</code> : 存储索引信息</li></ul><h3 id="MyISAM-特性"><a href="#MyISAM-特性" class="headerlink" title="MyISAM 特性"></a>MyISAM 特性</h3><ul><li><p>并发性与锁级别</p><ul><li>表级锁（不是行级锁）<ul><li>对表中的数据修改时，需要对整个表加锁；对表中的数据进行读取的时候，也需要对整个表进行加共享锁（共享锁之间不会阻塞）。（读写和写入是互斥的，在一些情况在对表中数据进行读取的时候，可以在表末尾插入数据。对读写并发不是很好。）</li></ul></li></ul></li><li><p>表损坏修复（可能会导致数据丢失，不支持事务）</p></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#对表进行检查</span></span><br><span class="line">check table tablename</span><br><span class="line"><span class="comment">#对表恢复</span></span><br><span class="line">repair table tablename</span><br></pre></td></tr></table></figure><p>或者使用命令行 <code>myisamchk</code> 对表进行修复，需要mysql停止服务，否则表可能造成更大损坏。</p><ul><li><p>MyISAM 表支持的索引类型（支持全文索引）</p></li><li><p>MyISAM 表支持数据压缩 （压缩后的表只能进行读操作，不能写）<br>命令行： <code>myisampack</code> </p></li><li><p>限制：</p><ul><li>版本 &lt; MySQL5.0时，默认表大小为4G；如果存储大表则要修改 <code>MAX_Rows</code> 和 <code>AVG_ROW_LENGTH</code></li><li>版本 &gt; MySQL5.0时，默认支持为256TB；</li></ul></li><li><p>适用场景：</p><ul><li>非事务型应用（在线分析、报表，不涉及财务的应用）</li><li>只读类应用（只读报表等）</li><li>空间类应用（存储GPS类数据，支持空间函数）</li></ul></li></ul><h2 id="存储引擎：InnoDB"><a href="#存储引擎：InnoDB" class="headerlink" title="存储引擎：InnoDB"></a>存储引擎：InnoDB</h2><p>MySQL5.5及以后默认存储引擎。<br>MySQL5.7以后 Innodb 支持全文索引和空间函数。<br>Innodb 适合大多数 OLTP 应用。</p><p>InnoDB 是事务级存储引擎，完美支持行级锁，事务ACID特性。<br>会同时在内存中缓存索引和数据。</p><p>具有在线热备份方案。</p><p>InnoDB 使用表空间进行数据存储。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">innodb_file_per_table</span><br><span class="line">ON : 数据会存储在独立表空间（ tablename.ibd ）</span><br><span class="line">OFF : 数据会存储在系统表空间（ ibdataX ）</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#查看</span><br><span class="line">show variables like &#x27;innodb_file_per_table&#x27;</span><br><span class="line">#设置</span><br><span class="line">set global innodb_file_per_table=off</span><br></pre></td></tr></table></figure><ul><li><p>系统表空间和独立表空间要如何选择：</p><ul><li>系统表空间无法简单的收缩文件大小（删除数据不会缩小；只能把整个数据库innodb表导出后，删除innodb相关的表空间文件后，重启mysql，表空间重建，重新导入数据）</li><li>独立表空间可以通过 <code>optimize table</code> 命令收缩系统文件</li><li>系统表空间会产生IO瓶颈</li><li>独立表空间可以同时向多个文件刷新数据</li><li>建议：对InnoDB使用独立表空间（mysql5.6之后默认是独立表空间）</li></ul></li><li><p>把系统表空间中的表转移到独立表空间步骤：</p><ul><li>1、使用 mysqldump 导出所有数据库表数据（如果数据存储过程有事件触发器一起导出）</li><li>2、停止mysql服务，修改参数，并删除innodb相关文件</li><li>3、重启mysql服务，重建innodb系统表空间</li><li>4、重新导入数据</li></ul></li><li><p>Innodb状态检查</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show engine innodb status</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;mysql-体系架构&quot;&gt;&lt;a href=&quot;#mysql-体系架构&quot; class=&quot;headerlink&quot; title=&quot;mysql 体系架构&quot;&gt;&lt;/a&gt;mysql 体系架构&lt;/h2&gt;&lt;p&gt;插件式存储引擎&lt;/p&gt;
&lt;h2 id=&quot;存储引擎：MyISAM&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="MySql" scheme="https://timmy6.github.io/categories/MySql/"/>
    
    
    <category term="数据库优化" scheme="https://timmy6.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>CentOS参数配置对mysql性能优化</title>
    <link href="https://timmy6.github.io/2019/08/15/CentOS%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E5%AF%B9mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://timmy6.github.io/2019/08/15/CentOS%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E5%AF%B9mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2019-08-15T13:15:10.000Z</published>
    <updated>2022-05-16T09:59:32.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CentOS系统参数优化"><a href="#CentOS系统参数优化" class="headerlink" title="CentOS系统参数优化"></a>CentOS系统参数优化</h2><p>推荐书籍：《Linux性能优化大师》</p><p>内核相关参数( <code>/etc/sysctl.conf</code> )</p><ul><li>查看内核(<code>kernel</code>)参数配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a</span><br></pre></td></tr></table></figure><h4 id="网络性能参数"><a href="#网络性能参数" class="headerlink" title="网络性能参数"></a>网络性能参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.core.somaxconn=65535</span><br><span class="line">net.core.netdev_max_backlog=65535</span><br><span class="line">net.ipv4.tcp_max_syn_backlog=65535</span><br></pre></td></tr></table></figure><p>http 请求经过三次握手建立网络连接，处于监听状态的端口，都会有自己的监听队列，参数 <code>net.core.somaxconn</code> 就决定了监听队列大小的长度，负载很大的服务器，就需要把这个参数修改大一些。</p><p><code>net.core.netdev_max_backlog</code> 在每个网络接口接收数据包的速率 比 内核处理数据包的速率快的时候，允许被发送到队列中的数据包的最大数量。</p><p><code>net.ipv4.tcp_max_syn_backlog</code> 还未获得对方连接的请求，可以保存到队列中的最大数目，超过这个数据大小的连接可能就会被抛弃。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查看有多少个请求由监听变成了链接</span><br><span class="line"></span><br><span class="line">#列出所有的端口，包括监听的和未监听的。</span><br><span class="line">netstat -a</span><br><span class="line"></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 0.0.0.0:etlservicemgr   0.0.0.0:*               LISTEN</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#列出所有的tcp协议的端口</span><br><span class="line">netstat -t</span><br><span class="line"></span><br><span class="line">#列出所有的UDP协议的端口</span><br><span class="line">netstat -ua</span><br><span class="line"></span><br><span class="line">#找出程序运行的端口</span><br><span class="line">netstat -ap | grep &#x27;程序名&#x27;</span><br><span class="line"></span><br><span class="line">#找出端口的程序名</span><br><span class="line">netstat -ap | grep &#x27;端口号&#x27;</span><br><span class="line"></span><br><span class="line">#显示路由表的信息</span><br><span class="line">netstat -r</span><br><span class="line"></span><br><span class="line">#显示接口信息</span><br><span class="line">netstat -i</span><br><span class="line"></span><br><span class="line">#分类统计各个协议的相关信息</span><br><span class="line">netstat -sa</span><br></pre></td></tr></table></figure><ul><li><code>net.ipv4.tcp_fin_timeout</code> 用于处理 tcp 连接等待状态的时间</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#用于加快 tcp 连接的回收，tcp连接占满就会出现无法连接的状态</span><br><span class="line">net.ipv4.tcp_fin_timeout=10</span><br><span class="line">net.ipv4.tcp_tw_reuse=1</span><br><span class="line">net.ipv4.tcp_tw_recycle=1</span><br></pre></td></tr></table></figure><ul><li>tcp 连接接收和发送缓冲区大小的默认值和最大值（调整的大一些）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.core.wmem_default = 87380</span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line">net.core.rmem_default=87380</span><br><span class="line">net.core.rmem_max=16777216</span><br></pre></td></tr></table></figure><ul><li>减少失效连接所占用的 tcp 资源的数量，加快资源回收的效率（调整小一些）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#tcp 发送 keepalive 的时间间隔，用户确认tcp连接是否有效，单位秒</span><br><span class="line">net.ipv4.tcp_keepalive_time=120</span><br><span class="line"></span><br><span class="line">#当发送探测点消息没有响应时，重发该消息的时间间隔，单位秒</span><br><span class="line">net.ipv4.tcp_keepalive_intvl=30</span><br><span class="line"></span><br><span class="line">#认定 tcp 连接失效之前，最多发送多少个 keepalive 消息</span><br><span class="line">net.ipv4.tcp_keepalive_probes=3</span><br></pre></td></tr></table></figure><h4 id="内存性能参数"><a href="#内存性能参数" class="headerlink" title="内存性能参数"></a>内存性能参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.shmmax = 4294967295</span><br></pre></td></tr></table></figure><ul><li>这个参数应该设置的足够大，以便能在一个共享内存段下容纳下整个的 Innodb 缓冲池的大小。（如果太低，就需要创建多个共享内存段，可能导致系统性能下降，原因是当实例启动的时候，多个共享内存段可能会导致当时系统性能轻微的性能下降，其他时候不会有影响）</li><li>这个值的大小对 64 位 linux 系统，可取的最大值为物理内存值-1byte，建议值为大于物理内存的一半，一般取值大于Innodb缓冲池的大小即可，可以取物理内存-1byte。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.swappiness = 0</span><br></pre></td></tr></table></figure><ul><li>这个参数当内存不足时，会对性能产生比较明显的影响</li></ul><p>Linux 系统内存交换区：<br>在Linux系统安装时，都会有一个特殊的磁盘分区，称之为系统交换分区。<br>使用 <code>free -m</code> 在系统中查看，可以看到类似下面的内容，其中 <code>swap</code> 就是交换分区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_3_centos ~]# free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           3790        1763         235           0        1791        1732</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure><p>当操作系统因为没有足够的内存时，就会将一些虚拟内存写到磁盘的交换区中，这样就会发生内存交换。</p><p>在MySQL 服务器上是或否要使用交换分区有一些争议：在MySQL服务所在的Linux系统上完全禁用交换分区。<br>带来的风险：降低操作系统的性能；容易造成内存溢出，崩溃，或都被操作系统kill掉。</p><p>在MySQL服务器上保留交换分区还是很有必要的，但是要控制何时使用交换分区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.swappiness = 0</span><br></pre></td></tr></table></figure><ul><li>参数告诉Linux内核除非虚拟内存完全满了，否则不要使用交换分区。</li></ul><h4 id="增加资源限制-etc-security-limit-conf"><a href="#增加资源限制-etc-security-limit-conf" class="headerlink" title="增加资源限制 /etc/security/limit.conf"></a>增加资源限制 <code>/etc/security/limit.conf</code></h4><p>这个文件实际上市 Linux PAM 也就是插入式认证模块的配置文件。<br>打开文件数的限制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65535</span><br><span class="line">* hard nofile 65535</span><br></pre></td></tr></table></figure><ul><li>用于控制打开文件的数量，加到 limit.conf 文件的末尾即可。 增加到 65535 以保证可以打开足够多的文件句柄。</li><li><ul><li>表示对所有用户有效</li></ul></li><li>soft 指的是当前系统生效的设置</li><li>hard 表明系统中所有设定的最大值</li><li>nofile 表示所限制的资源是打开文件的最大数目</li><li>65536 就是限制的数量</li><li>这个文件修改需要重启系统才能生效。</li></ul><h4 id="磁盘调度策略"><a href="#磁盘调度策略" class="headerlink" title="磁盘调度策略"></a>磁盘调度策略</h4><p><code>/sys/block/devname/queue/scheduler</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/block/vda/queue/scheduler</span><br><span class="line"></span><br><span class="line">cat /sys/block/sda/queue/scheduler</span><br><span class="line">noop anticipatory deadline [cfq]</span><br></pre></td></tr></table></figure><ul><li><p>noop（电梯式调度策略） ：NOOP 实现了一个 FIFO 队列，它像电梯的工作方法一样对 I&#x2F;O 请求进行组织，当有一个新的请求到来时，它将请求合并到最近的请求之后，以此来保证请求同一介质。 NOOP 倾向饿死读而立于写，因此 NOOP 对于闪存设备、RAM及嵌入式系统是最好的选择。</p></li><li><p>deadline（截止时间调度策略）： deadline 确保了一个截止时间内服务请求，这个截止时间是可调整的，而默认读期限短于写期限。 这样就防止了写操作因为不能被读取而饿死的现象， deadline 对数据库类应用是最好的选择。</p></li><li><p>anticipatory （预料I&#x2F;O调度策略）： 本质上与deadline 一样，但在最后一次读操作后，要等待6ms，才能继续进行对其他I&#x2F;O请求进行调度。 它会在每个6ms中插入新的I&#x2F;O操作，而会将一些小写入流合并成一个大写入流，用写入延时换取最大的写入吞吐量。 AS适合于写入较多的环境，比如文件服务器，AS对数据库环境表现很差。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CentOS系统参数优化&quot;&gt;&lt;a href=&quot;#CentOS系统参数优化&quot; class=&quot;headerlink&quot; title=&quot;CentOS系统参数优化&quot;&gt;&lt;/a&gt;CentOS系统参数优化&lt;/h2&gt;&lt;p&gt;推荐书籍：《Linux性能优化大师》&lt;/p&gt;
&lt;p&gt;内核相关</summary>
      
    
    
    
    <category term="MySql" scheme="https://timmy6.github.io/categories/MySql/"/>
    
    
    <category term="数据库优化" scheme="https://timmy6.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>影响数据库性能的因素</title>
    <link href="https://timmy6.github.io/2019/08/10/%E5%BD%B1%E5%93%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E7%9A%84%E5%9B%A0%E7%B4%A0/"/>
    <id>https://timmy6.github.io/2019/08/10/%E5%BD%B1%E5%93%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E7%9A%84%E5%9B%A0%E7%B4%A0/</id>
    <published>2019-08-10T15:15:10.000Z</published>
    <updated>2022-05-16T09:56:55.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="影响数据库性能的因素"><a href="#影响数据库性能的因素" class="headerlink" title="影响数据库性能的因素"></a>影响数据库性能的因素</h2><ul><li>影响数据库性能的因素<ul><li>sql查询速度</li><li>服务器硬件</li><li>网卡流量</li><li>磁盘IO</li><li>网卡流量</li><li>大表</li><li>大事务</li></ul></li></ul><h3 id="QPS-amp-TPS"><a href="#QPS-amp-TPS" class="headerlink" title="QPS &amp; TPS"></a>QPS &amp; TPS</h3><p>QPS：每秒钟处理的查询量</p><ul><li>eg：<ul><li>一个cpu 10ms 处理 1个sql，</li><li>1s 处理 100个sql，那么QPS&lt;&#x3D;100</li><li>一个cpu 100ms处理 1个sql，QPS&lt;&#x3D;10</li></ul></li></ul><p>TPS：</p><ul><li>超高的QPS和TPS带来的风险：效率低下的SQL</li></ul><p>数据库的性能问题大部分都是由于sql的慢查询造成的，大部分问题可以通过对sql的优化得到解决。</p><h3 id="并发量-amp-CPU使用率"><a href="#并发量-amp-CPU使用率" class="headerlink" title="并发量 &amp; CPU使用率"></a>并发量 &amp; CPU使用率</h3><p>并发量：同一时间处理的请求的数量；与同时连接数不同。</p><p>空闲的百分比值越高空闲率越高。</p><ul><li>大量的并发和超高的CPU使用率</li></ul><p>大量的并发：数据库连接数被占满。（max_connections默认100）</p><p>超高的CPU使用率：因cpu资源耗尽而出现宕机。</p><h3 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h3><p>数据库备份远程同步计划任务会导致IO达到峰值。</p><ul><li>最好不要在主库上数据库备份</li><li>大型活动前取消这类计划</li></ul><p>风险：</p><p>磁盘IO性能突然下降（使用更快的磁盘设备）</p><p>其他大量消耗磁盘性能的计划任务（调整计划任务，做好磁盘维护）</p><ul><li>数据库扩展需要完整性和一致性</li></ul><h3 id="网卡流量"><a href="#网卡流量" class="headerlink" title="网卡流量"></a>网卡流量</h3><p>网卡IO被占满（1000Mb&#x2F;8 约等于 100MB）</p><ul><li>如何避免无法连接数据库的情况：<ul><li>减少从服务器的数量</li><li>进行分级缓存</li><li>避免使用 select * 进行查询</li><li>分离业务网络和服务器网络</li></ul></li></ul><h3 id="大表"><a href="#大表" class="headerlink" title="大表"></a>大表</h3><ul><li><p>记录行数巨大，单标超过千万行</p></li><li><p>表数据文件巨大，表数据文件超过10G</p></li><li><p>第一、 大表对查询的影响：</p><ul><li>慢查询：很难再一定的时间内过滤出所需要的数据。</li><li>查询的维度区分度比较低（只有几个维度，例如三方登录字段：只有微信、qq几个有限的维度，查询的数据量就比较大），会产生大量磁盘IO，降低磁盘效率。</li></ul></li><li><p>第二、大表对DDL操作的影响：</p><ul><li>建立索引需要很长的时间</li><li>Mysql 版本 &lt; 5.5 建立索引会锁表</li><li>Mysql 版本 &gt;&#x3D; 5.5 虽然不会锁表，但会引起主从延迟</li><li>大表对DDL操作的影响：修改表结构需要长时间锁表。</li><li>风险：会造成长时间的主从延迟。影响正常的数据操作。</li></ul></li><li><p>如何处理数据库中的大表：</p><ul><li><ol><li>分库分表把一张大表分成多个小表。</li></ol><ul><li>难点：</li><li>分表主键的选择；分表后跨分区数据的查询和统计。</li></ul></li><li><ol start="2"><li>大表的历史数据归档：</li></ol><ul><li>减少对前后端业务的影响</li><li>难点：归档时间点的选择。如何进行归档操作。</li></ul></li></ul></li></ul><h3 id="大事务"><a href="#大事务" class="headerlink" title="大事务"></a>大事务</h3><ul><li><p>什么是事务？</p><ul><li>事务是数据库系统区别于其他一切文件系统的重要特征之一</li><li>事务是一组具有原子性的sql语句，或是一个独立的工作单元</li></ul></li><li><p>特点：原子性、一致性、隔离性、持久性</p></li><li><p>事务原子性 atomicity：</p><ul><li>一个事务被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作</li><li>银行例子：1. 取钱  2.存钱</li></ul></li><li><p>事务的一致性 consistency：</p><ul><li>一致性是指事务将数据库从一种一致性状态转换到另外一种一致性状态，在事务开始之前和事务结束后数据库中数据的完整性没有被破坏</li></ul></li><li><p>事务的隔离性 isolation： </p><ul><li>隔离性要求一个事务对数据库中数据的修改，在未提交完成前对于其它事务是不可见的</li><li>SQL标准中定义的四种隔离级别：<ul><li>未提交读（READ uncommited）</li><li>已提交读（READ commited）（不可重复读）</li><li>可重复读（repeatable READ）</li><li>可串行化（serializable）</li></ul></li><li>隔离性由低-&gt;高，并发性由高-&gt;低</li></ul></li><li><p>事务的持久性 durability：</p><ul><li>一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，已经提交的修改数据也不会丢失</li></ul></li><li><p>大事务：</p><ul><li>运行时间比较长，操作的数据比较多的事务</li><li>风险：<ul><li>锁定太多的数据，造成大量的阻塞和锁超时</li><li>回滚时所需时间比较长</li><li>执行时间长，容易造成主从延迟</li></ul></li></ul></li><li><p>如何处理大事务：</p><ul><li>避免一次处理太多的数据</li><li>移除不必要在事务中的select操作</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;影响数据库性能的因素&quot;&gt;&lt;a href=&quot;#影响数据库性能的因素&quot; class=&quot;headerlink&quot; title=&quot;影响数据库性能的因素&quot;&gt;&lt;/a&gt;影响数据库性能的因素&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;影响数据库性能的因素&lt;ul&gt;
&lt;li&gt;sql查询速度&lt;/li&gt;
</summary>
      
    
    
    
    <category term="MySql" scheme="https://timmy6.github.io/categories/MySql/"/>
    
    
    <category term="数据库优化" scheme="https://timmy6.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>go interface</title>
    <link href="https://timmy6.github.io/2019/07/25/go-interface/"/>
    <id>https://timmy6.github.io/2019/07/25/go-interface/</id>
    <published>2019-07-25T15:15:10.000Z</published>
    <updated>2022-05-16T09:51:17.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><ul><li><p>接口（interface）无法被实例化.</p></li><li><p>接口类型也算是引用类型。</p></li><li><p>接口是根据方法集合区分的（定义的所有方法）。</p></li><li><p>代表某一类特征（<code>Duck Typing</code>）</p></li></ul><h2 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Animal interface &#123;</span><br><span class="line">    Eat(foot string)</span><br><span class="line">    Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">func (p *Person)Eat(foot string) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">func (p *Person)Run() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Person 实现了 <code>Eat(foot string)</code> 方法和 <code>Run()</code> 方法, 也就是说 Person 实现了接口 Animal ，并且这种实现接口的方式是无侵入的.</p></li><li><p>判断一个类型是否实现了某个接口：</p><ul><li>两个方法的签名需要完全一致</li><li>两个方法的名称要一模一样</li></ul></li></ul><h2 id="接口的另一种使用"><a href="#接口的另一种使用" class="headerlink" title="接口的另一种使用"></a>接口的另一种使用</h2><ul><li>可以把实现接口的类型，赋值给对应的接口类型变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p Person = &amp;Person&#123;&#125;</span><br><span class="line">var a Animal = p</span><br></pre></td></tr></table></figure><ul><li><p>变量 <code>p</code> 是接口变量 <code>a</code> 的<code>实际值</code>，也叫<code>动态值</code>.</p></li><li><p>变量 <code>p</code> 的类型 <code>Person</code> 叫做接口变量 <code>a</code> 的<code>实际类型</code>，也叫 <code>动态类型</code>.</p></li><li><p>类型 <code>Animal</code> 是接口变量 <code>a</code> 的 <code>静态类型</code>，是永远不会变化的。（相对于动态类型是变化的跟我们的赋值有关）</p></li><li><p>接口类型变量的零值是<code>nil</code>。</p></li><li><p>当给一个接口变量赋值的时候，该变量的动态类型和动态值会一起被存储在一个专用的数据结构中。</p></li><li><p>其实，这个接口变量的值是这个专用数据结构的一个实例，而不是我们赋给改变量的那个实际值。</p></li><li><p>这个专用的数据结构在 Go 语言的 <code>runtime</code> 包中叫 <code>iface</code> 。<code>iface</code>的实例会包含两个指针，一个是指向类型信息的指针，另一个是指向动态值的指针。这里的类型信息是由另一个专用数据结构的实例承载的，其中包含了动态值的类型，以及使它实现了接口的方法和调用他们的途径。</p></li><li><p>使用 <code>==</code> 判断接口变量是否为 <code>nil</code>：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var p Person</span><br><span class="line">var a Animal = p</span><br><span class="line">// p == nil , a != nil</span><br><span class="line">if a == nil &#123;</span><br><span class="line">fmt.Println(&quot;a == nil&quot;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">fmt.Println(&quot;a != nil&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对一个接口变量只声明不初始化，或者直接给接口变量赋值 <code>nil</code>，这时接口变量值为 <code>nil</code>。</li></ul><h2 id="接口的组合"><a href="#接口的组合" class="headerlink" title="接口的组合"></a>接口的组合</h2><p>接口的组合：接口类型之间的嵌入。</p><p>建议声明小接口，更容易组合接口，扩展性强、比较灵活。</p><p>组合的接口之间有同名的方法（方法签名不同也不行）就会编译报错。</p><p>看Go标准库 <code>io</code> 包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Reader interface &#123;</span><br><span class="line">Read(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Writer interface &#123;</span><br><span class="line">Write(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ReadWriter interface &#123;</span><br><span class="line">Reader</span><br><span class="line">Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同时实现了 <code>Reader</code> 接口和 <code>Writer</code> 接口，就相当于实现了组合接口 <code>ReadWriter</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Closer interface &#123;</span><br><span class="line">Close() error</span><br><span class="line">&#125;</span><br><span class="line">type ReadCloser interface &#123;</span><br><span class="line">Reader</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br><span class="line">type WriteCloser interface &#123;</span><br><span class="line">Writer</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nil-接口变量"><a href="#nil-接口变量" class="headerlink" title="nil 接口变量"></a>nil 接口变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var p Person = nil</span><br><span class="line">var a Animal = p</span><br><span class="line">// p == nil , a != nil</span><br></pre></td></tr></table></figure><p>Person 实现了接口，p 是一个nil变量，赋值给接口类型变量 a，a 依然可以调用接口实现的方法。方法接收者必须是指针类型才能调用接口实现的方法。</p><h2 id="Duck-Typing"><a href="#Duck-Typing" class="headerlink" title="Duck Typing"></a>Duck Typing</h2><p><code>Duck Typing</code> ，看起来像鸭子，它就是鸭子。</p><ul><li><p><code>Go</code>语言对象没有继承和多态，只有封装性。</p></li><li><p>协议注重关注方法的实现，而很少关注类型。</p></li><li><p>只要实现了B协议方法的实体，是B协议类型的入参， 都可以作为的传入。</p></li><li><p>变相实现了继承和多态，实现多个协议，就可以是类似多继承。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;interface&quot;&gt;&lt;a href=&quot;#interface&quot; class=&quot;headerlink&quot; title=&quot;interface&quot;&gt;&lt;/a&gt;interface&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;接口（interface）无法被实例化.&lt;/p&gt;
&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>go mod</title>
    <link href="https://timmy6.github.io/2019/07/16/go-mod/"/>
    <id>https://timmy6.github.io/2019/07/16/go-mod/</id>
    <published>2019-07-16T14:15:10.000Z</published>
    <updated>2022-05-16T09:48:42.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h1><h2 id="go-mod-命令管理包"><a href="#go-mod-命令管理包" class="headerlink" title="go mod 命令管理包"></a><code>go mod</code> 命令管理包</h2><ul><li>在当前目录初始化生成 <code>go.mod</code> 文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init </span><br></pre></td></tr></table></figure><ul><li>下载包依赖到本地缓存</li></ul><p>本地缓存目录：<code>$GOPATH/pkg/mod</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod download</span><br></pre></td></tr></table></figure><ul><li>编辑<code>go.mod</code></li></ul><p>格式化<code>go.mod</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -fmt</span><br></pre></td></tr></table></figure><p>以<code>json</code>的形式查看依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go list -m -json all</span><br><span class="line">go mod edit -json</span><br></pre></td></tr></table></figure><ul><li>打印模块依赖图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod graph</span><br></pre></td></tr></table></figure><ul><li>拉取缺少的模块，移除不用的模块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><ul><li>将依赖复制到<code>vendor</code>下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod vendor</span><br></pre></td></tr></table></figure><ul><li>验证依赖是否正确</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod verify</span><br></pre></td></tr></table></figure><ul><li>需要依赖的原因</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod why</span><br></pre></td></tr></table></figure><h2 id="go-mod-编写"><a href="#go-mod-编写" class="headerlink" title="go.mod 编写"></a><code>go.mod</code> 编写</h2><p>四个命令: </p><ul><li><code>module</code> : 指定包的名字（路径）</li><li><code>require</code>: 指定的依赖项模块</li><li><code>replace</code>: 可以替换依赖项模块</li><li><code>exclude</code>: 可以忽略依赖项模块</li></ul><p>eg:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module cocktail</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.12</span></span><br><span class="line"></span><br><span class="line">require github.com/gin-gonic/gin v1<span class="number">.4</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">replace (</span><br><span class="line">golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190308221718</span>-c2843e01d9a2 =&gt; github.com/golang/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190513172903</span><span class="number">-22</span>d7a77e9e5f</span><br><span class="line">golang.org/x/net =&gt; github.com/golang/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190514140710</span><span class="number">-3</span>ec191127204</span><br><span class="line">golang.org/x/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190404232315</span>-eb5bcb51f2a3 =&gt; github.com/golang/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190514140710</span><span class="number">-3</span>ec191127204</span><br><span class="line">golang.org/x/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190503192946</span>-f4e77d36d62c =&gt; github.com/golang/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190514140710</span><span class="number">-3</span>ec191127204</span><br><span class="line"></span><br><span class="line">golang.org/x/sync =&gt; github.com/golang/sync v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190423024810</span><span class="number">-112230192</span>c58</span><br><span class="line">golang.org/x/sys v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190222072716</span>-a9d3bda3a223 =&gt; github.com/golang/sys v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190516110030</span><span class="number">-61</span>b9204099cb</span><br><span class="line">golang.org/x/sys v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190412213103</span><span class="number">-97732733099</span>d =&gt; github.com/golang/sys v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190516110030</span><span class="number">-61</span>b9204099cb</span><br><span class="line"></span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.0</span> =&gt; github.com/golang/text v0<span class="number">.3</span><span class="number">.2</span></span><br><span class="line">golang.org/x/tools v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180917221912</span><span class="number">-90</span>fa682c2a6e =&gt; github.com/golang/tools v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190517183331</span>-d88f79806bbd</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用 <code>replace</code> 可以把 <code>golang.rog/</code> 替换成 <code>github/ </code> 。</p><h2 id="一些其他使用"><a href="#一些其他使用" class="headerlink" title="一些其他使用"></a>一些其他使用</h2><ul><li><p>执行 <code>go run server.go</code> 运行代码会发现 <code>go mod</code> 会自动查找依赖自动下载。</p></li><li><p><code>go module</code> 安装 <code>package</code> 的原則是先拉最新的 <code>release tag</code>，若无<code>tag</code>则拉最新的<code>commit</code>。 </p></li><li><p><code>go</code> 会自动生成一个 <code>go.sum</code> 文件来记录 <code>dependency tree</code>。</p></li><li><p>来检查可以升级的 <code>package</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go list -m -u all</span><br></pre></td></tr></table></figure><ul><li>升级依赖版本<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u need-upgrade-package</span><br></pre></td></tr></table></figure></li></ul><p>或者 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u</span><br></pre></td></tr></table></figure><blockquote><p>Modules官方介绍：<a href="https://github.com/golang/go/wiki/Modules">https://github.com/golang/go/wiki/Modules</a></p></blockquote><h2 id="一些遇到的问题"><a href="#一些遇到的问题" class="headerlink" title="一些遇到的问题"></a>一些遇到的问题</h2><ul><li>go 1.10.3 版本Bug。需要升级版本,删除 <code>/usr/local/Cellar/go/</code> 目录下文件，重新安装。</li></ul><p>原因参考：<a href="https://github.com/golang/go/issues?q=milestone:Go1.10.4">https://github.com/golang/go/issues?q=milestone%3AGo1.10.4</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/beego/bee</span><br><span class="line"></span><br><span class="line"><span class="comment"># github.com/beego/bee</span></span><br><span class="line">/usr/local/Cellar/go/1.10.3/libexec/pkg/tool/darwin_amd64/link: /usr/local/Cellar/go/1.10.3/libexec/pkg/tool/darwin_amd64/link: combining dwarf failed: Unknown load <span class="built_in">command</span> 0x32 (50)</span><br></pre></td></tr></table></figure><ul><li>go mod init 报错</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go mod </span><br><span class="line"></span><br><span class="line">go: modules disabled inside GOPATH/src by GO111MODULE=auto; see &#x27;go help modules&#x27;</span><br><span class="line"></span><br><span class="line"># 设置环境变量解决 GO111MODULE 默认值为auto  其他：on 、off</span><br><span class="line">export GO111MODULE=on</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;go-mod&quot;&gt;&lt;a href=&quot;#go-mod&quot; class=&quot;headerlink&quot; title=&quot;go mod&quot;&gt;&lt;/a&gt;go mod&lt;/h1&gt;&lt;h2 id=&quot;go-mod-命令管理包&quot;&gt;&lt;a href=&quot;#go-mod-命令管理包&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Golang不同类型比较</title>
    <link href="https://timmy6.github.io/2019/06/16/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83/"/>
    <id>https://timmy6.github.io/2019/06/16/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83/</id>
    <published>2019-06-16T14:15:10.000Z</published>
    <updated>2022-05-16T09:39:13.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-13-Golang不同类型比较"><a href="#9-13-Golang不同类型比较" class="headerlink" title="9.13  Golang不同类型比较"></a>9.13  Golang不同类型比较</h1><p>在日常开发过程中难免会遇到各个类型的变量的比较以及运算操作，这里做了一些简单的汇总，希望能给各位同学在开发中带来帮助。</p><p>这里先上一波关系运算符&#x3D;&#x3D;，!&#x3D;，&lt;，&lt;&#x3D;，&gt; 和 &gt;&#x3D;。</p><h3 id="float浮点数比较"><a href="#float浮点数比较" class="headerlink" title="float浮点数比较"></a>float浮点数比较</h3><p>golang 支持两种浮点float32和float64，众所众知，涉及浮点数比较或运算是会遇到精度问题，具体要根据golang实现IEEE 754的情况定。</p><p>默认情况下，float32精度是小数后7位，float64精度是小数点后15位。</p><p>如例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a float32 = 1.00000001</span><br><span class="line">var b float32 = 1.000000000001</span><br><span class="line">var c float32 = 1.0000001</span><br><span class="line">var d float32 = 1.000000000001</span><br><span class="line"></span><br><span class="line">fmt.Println(a == b) //true</span><br><span class="line">fmt.Println(a &gt; b)  //false</span><br><span class="line">fmt.Println(c == d) //false</span><br><span class="line">fmt.Println(c &gt; d)  //true</span><br></pre></td></tr></table></figure><p>float64</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a float64 = 1.0000000000000001</span><br><span class="line">var b float64 = 1.000000000000000001</span><br><span class="line">var c float64 = 1.000000000000001</span><br><span class="line">var d float64 = 1.0000000000000000001</span><br><span class="line"></span><br><span class="line">fmt.Println(a == b) //true</span><br><span class="line">fmt.Println(a &gt; b)  //false</span><br><span class="line">fmt.Println(c == d) //false</span><br><span class="line">fmt.Println(c &gt; d)  //true</span><br></pre></td></tr></table></figure><p>这里写了一个根据精度进行float比较的简单的类，注意最大精度为小数点后15位，超出会丢失精度。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Floater struct &#123;</span><br><span class="line">Accuracy float64   //精度,最大为小数点后15位</span><br><span class="line">&#125;</span><br><span class="line">//是否相等</span><br><span class="line">func (f Floater) IsEqual(a, b float64) bool &#123;</span><br><span class="line">return math.Abs(a-b) &lt; f.Accuracy</span><br><span class="line">&#125;</span><br><span class="line">//0为相等 1为a大于b -1为a小于b</span><br><span class="line">func (f Floater) Bccomp(a, b float64) int8 &#123;</span><br><span class="line">if math.Abs(a-b) &lt; f.Accuracy &#123;</span><br><span class="line">return 0</span><br><span class="line">&#125;</span><br><span class="line">if math.Max(a, b) == a &#123;</span><br><span class="line">return 1</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">f := Floater&#123;Accuracy: 0.000000000001&#125;</span><br><span class="line">var a float64 = 1.0000000002</span><br><span class="line">var b float64 = 1.0000000001</span><br><span class="line"></span><br><span class="line">fmt.Println(f.Bccomp(a, b)) //1</span><br><span class="line">fmt.Println(f.Bccomp(b, a)) //-1</span><br><span class="line">fmt.Println(f.Bccomp(a, a)) //0</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>顺便讲一下如何实现保留小数点后2位如何实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   //方法1</span><br><span class="line">a := 2.556</span><br><span class="line">v, _ := strconv.ParseFloat(fmt.Sprintf(&quot;%.2f&quot;, a), 64)</span><br><span class="line">fmt.Println(v)   //2.56</span><br><span class="line">   //方法2   </span><br><span class="line">v = math.Trunc(a*1e2+0.5) * 1e-2</span><br><span class="line">fmt.Println(v)   //2.56</span><br><span class="line"></span><br><span class="line">//方法3</span><br><span class="line">n10 := math.Pow10(2)</span><br><span class="line">v = math.Trunc((a+0.5/n10)*n10) / n10</span><br><span class="line">fmt.Println(v)</span><br></pre></td></tr></table></figure><h3 id="指针类型比较"><a href="#指针类型比较" class="headerlink" title="指针类型比较"></a>指针类型比较</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := &quot;hello&quot;</span><br><span class="line">b := &amp;a</span><br><span class="line">c := &amp;a</span><br><span class="line">fmt.Println(b == c)</span><br></pre></td></tr></table></figure><p>当变量是相同或者都为nil时，指针值相等。</p><h3 id="interface类型比较"><a href="#interface类型比较" class="headerlink" title="interface类型比较"></a>interface类型比较</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">type I1 interface &#123;</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line">type I2 interface &#123;</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type S1 struct &#123;</span><br><span class="line">name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s S1) f() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type S2 struct &#123;</span><br><span class="line">name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s S2) f() &#123;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var a, b, c, d I1</span><br><span class="line">var e I2</span><br><span class="line">a = S1&#123;&quot;hello&quot;&#125;</span><br><span class="line">b = S1&#123;&quot;hello&quot;&#125;</span><br><span class="line">c = S1&#123;&quot;world&quot;&#125;</span><br><span class="line">d = S2&#123;&quot;hello&quot;&#125;</span><br><span class="line">fmt.Println(a == b) //true</span><br><span class="line">fmt.Println(a == c) //false</span><br><span class="line">fmt.Println(a == d) //false</span><br><span class="line">fmt.Println(a == e) //false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较-slice-x2F-struct-x2F-map"><a href="#比较-slice-x2F-struct-x2F-map" class="headerlink" title="比较 slice&#x2F;struct&#x2F;map"></a>比较 slice&#x2F;struct&#x2F;map</h3><p>这三个都可以用reflect.DeepEqual来判断是否相等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type S struct &#123;</span><br><span class="line">s string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">s1 := S&#123;s: &quot;hello&quot;&#125;</span><br><span class="line">s2 := S&#123;s: &quot;hello&quot;&#125;</span><br><span class="line">if reflect.DeepEqual(s1, s2) &#123;</span><br><span class="line">fmt.Println(s1, &quot;==&quot;, s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a1 := []int&#123;1, 2&#125;</span><br><span class="line">a2 := []int&#123;1, 2&#125;</span><br><span class="line">if reflect.DeepEqual(a1, a2) &#123;</span><br><span class="line">fmt.Println(a1, &quot;==&quot;, a2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m1 := map[int]string&#123;1: &quot;a&quot;, 2: &quot;b&quot;&#125;</span><br><span class="line">m2 := map[int]string&#123;1: &quot;a&quot;, 2: &quot;b&quot;&#125;</span><br><span class="line">if reflect.DeepEqual(m1, m2) &#123;</span><br><span class="line">fmt.Println(m1, &quot;==&quot;, m2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;9-13-Golang不同类型比较&quot;&gt;&lt;a href=&quot;#9-13-Golang不同类型比较&quot; class=&quot;headerlink&quot; title=&quot;9.13  Golang不同类型比较&quot;&gt;&lt;/a&gt;9.13  Golang不同类型比较&lt;/h1&gt;&lt;p&gt;在日常开发过程中</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
