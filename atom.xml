<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://timmy6.github.io/atom.xml" rel="self"/>
  
  <link href="https://timmy6.github.io/"/>
  <updated>2022-05-18T09:33:42.657Z</updated>
  <id>https://timmy6.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>缓存穿透、缓存击穿、缓存血崩的区别以及解决方案</title>
    <link href="https://timmy6.github.io/2021/06/25/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E8%A1%80%E5%B4%A9%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://timmy6.github.io/2021/06/25/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E8%A1%80%E5%B4%A9%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2021-06-25T15:15:10.000Z</published>
    <updated>2022-05-18T09:33:42.657Z</updated>
    
    <content type="html"><![CDATA[<p>平时我们使用缓存的方案，一般是在数据库中存储一份，在缓存中同步存储一份。当请求过来的视乎，可以先从缓存中取数据，如果有数据，直接返回缓存中的结果。如果缓存中没有数据，那么去数据库中取出数据，同时更新到缓存中，返回结果。如果数据库中也没有数据，可以直接返回空。</p><p>关于缓存，一般会有以下几个常见的问题</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指，<strong>缓存和数据库都没有的数据</strong>，被大量请求，比如订单号不可能为<code>-1</code>，但是用户请求了大量订单号为<code>-1</code>的数据，由于数据不存在，缓存就也不会存在该数据，所有的请求都会直接穿透到数据库。<br>如果被恶意用户利用，疯狂请求不存在的数据，就会导致数据库压力过大，甚至垮掉。</p><p>注意：穿透的意思是，都没有，直接一路打到数据库。</p><p><strong>那对于这种情况，我们该如何解决呢？</strong></p><ol><li>接口增加业务层级的<code>Filter</code>，进行合法校验，这可以有效拦截大部分不合法的请求。</li><li>作为第一点的补充，最常见的是使用布隆过滤器，针对一个或者多个维度，把可能存在的数据值hash到bitmap中，bitmap证明该数据不存在则该数据一定不存在，但是bitmap证明该数据存在也只能是可能存在，因为不同的数值hash到的bit位很有可能是一样的，hash冲突会导致误判，多个hash方法也只能是降低冲突的概率，无法做到避免。</li><li>另外一个常见的方法，则是针对数据库与缓存都没有的数据，对空的结果进行缓存，但是过期时间设置得较短，一般五分钟内。而这种数据，如果数据库有写入，或者更新，必须同时刷新缓存，否则会导致不一致的问题存在。</li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿是指数据库原本有得数据，但是缓存中没有，一般是缓存突然失效了，这时候如果有大量用户请求该数据，缓存没有则会去数据库请求，会引发数据库压力增大，可能会瞬间打垮。</p><p>针对这类问题，一般有以下做法：</p><ol><li>如果是热点数据，那么可以考虑设置永远不过期。</li><li>如果数据一定会过期，那么就需要在数据为空的时候，设置一个互斥的锁，只让一个请求通过，只有一个请求去数据库拉取数据，取完数据，不管如何都需要释放锁，异常的时候也需要释放锁，要不其他线程会一直拿不到锁。</li></ol><p>下面是缓存击穿的时候互斥锁的写法，注意：获取锁之后操作，不管成功或者失败，都应该释放锁，而其他的请求，如果没有获取到锁，应该等待，再重试。当然，如果是需要更加全面一点，应该加上一个等待次数，比如1s中，那么也就是睡眠五次，达到这个阈值，则直接返回空，不应该过度消耗机器，以免当个不可用的场景把整个应用的服务器带挂了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getProductDescById</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> redis.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空，过期了</span></span><br><span class="line">    <span class="keyword">if</span> (desc == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 互斥锁，只有一个请求可以成功</span></span><br><span class="line">        <span class="keyword">if</span> (redis.setnx(lock_id, <span class="number">1</span>, <span class="number">60</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 从数据库取出数据</span></span><br><span class="line">                desc = getFromDB(id);</span><br><span class="line">                redis.set(id, desc, <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                LogHelper.error(ex);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 确保最后删除，释放锁</span></span><br><span class="line">                redis.del(lock_id);</span><br><span class="line">                <span class="keyword">return</span> desc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则睡眠200ms，接着获取锁</span></span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span> getProductDescById(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指缓存中有大量的数据，在同一个时间点，或者较短的时间段内，全部过期了，这个时候请求过来，缓存没有数据，都会请求数据库，则数据库的压力就会突增，扛不住就会宕机。</p><p>针对这种情况，一般我们都是使用以下方案：</p><ol><li>如果是热点数据，那么可以考虑设置永远不过期。</li><li>缓存的过期时间除非比较严格，要不考虑设置一个波动随机值，比如理论十分钟，那这类key的缓存时间都加上一个1<del>3分钟，过期时间在7</del>13分钟内波动，有效防止都在同一个时间点上大量过期。</li><li>方法1避免了有效过期的情况，但是要是所有的热点数据在一台redis服务器上，也是极其危险的，如果网络有问题，或者redis服务器挂了，那么所有的热点数据也会雪崩（查询不到），因此将热点数据打散分不到不同的机房中，也可以有效减少这种情况。</li><li>也可以考虑双缓存的方式，数据库数据同步到缓存A和B，A设置过期时间，B不设置过期时间，如果A为空的时候去读B，同时异步去更新缓存，但是更新的时候需要同时更新两个缓存。</li></ol><p>比如设置产品的缓存时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.set(id,value,<span class="number">60</span>*<span class="number">60</span> + Math.random()*<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>缓存穿透是指数据库原本就没有的数据，请求如入无人之境，直奔数据库，而缓存击穿，则是指数据库有数据，缓存也本应该有数据，但是突然缓存过期了，这层保护屏障被击穿了，请求直奔数据库，缓存雪崩则是指很多缓存同一个时间失效了，流量全部涌入数据库，造成数据库极大的压力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;平时我们使用缓存的方案，一般是在数据库中存储一份，在缓存中同步存储一份。当请求过来的视乎，可以先从缓存中取数据，如果有数据，直接返回缓存中的结果。如果缓存中没有数据，那么去数据库中取出数据，同时更新到缓存中，返回结果。如果数据库中也没有数据，可以直接返回空。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="MySql" scheme="https://timmy6.github.io/categories/MySql/"/>
    
    
    <category term="数据库优化" scheme="https://timmy6.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>timer复用问题</title>
    <link href="https://timmy6.github.io/2021/03/02/timer%E5%A4%8D%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://timmy6.github.io/2021/03/02/timer%E5%A4%8D%E7%94%A8%E9%97%AE%E9%A2%98/</id>
    <published>2021-03-02T15:22:10.000Z</published>
    <updated>2022-05-18T09:14:51.738Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重用timer"><a href="#重用timer" class="headerlink" title="重用timer"></a>重用timer</h1><blockquote><p>重用的timer的目的在于减少减少创建timer实例</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://studygolang.com/articles/9289">https://studygolang.com/articles/9289</a></li></ul><h2 id="重置条件"><a href="#重置条件" class="headerlink" title="重置条件"></a>重置条件</h2><ul><li>第一步是要确定timer是否已过期,用<code>timer.Stop</code>确定,<code>true</code>表示timer未过期,<code>false</code>表示timer已过期</li><li>timer已过期,选择性抽干channel,然后调用<code>time.Reset</code></li><li>timer未过期,<code>timer.Stop</code>返回<code>true</code>,此时不必关系channel会被删除,可以直接调用<code>time.Reset</code></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       timer := time.NewTimer(time.Second * <span class="number">5</span>)</span><br><span class="line">       <span class="keyword">for</span> &#123;</span><br><span class="line">           <span class="comment">// 不管有没有过期,我们都尝试stop timer,成功表示timer未过期,失败表示timer已过期</span></span><br><span class="line">           <span class="keyword">if</span> !timer.Stop() &#123;</span><br><span class="line">               <span class="keyword">select</span> &#123;</span><br><span class="line">               <span class="keyword">case</span> &lt;-timer.C: <span class="comment">// 尝试抽干channel,因为不知道channel过期之前是否已经被抽干了,但是这不是完美的,会有竞争条件</span></span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           timer.Reset(time.Second * <span class="number">5</span>)</span><br><span class="line">           <span class="keyword">select</span> &#123;</span><br><span class="line">           <span class="keyword">case</span> b := &lt;-c:</span><br><span class="line">               <span class="keyword">if</span> b == <span class="literal">false</span> &#123;</span><br><span class="line">                   fmt.Println(time.Now(), <span class="string">&quot;:recv false. continue&quot;</span>)</span><br><span class="line">                   <span class="keyword">continue</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//we want true, not false</span></span><br><span class="line">               fmt.Println(time.Now(), <span class="string">&quot;:recv true. return&quot;</span>)</span><br><span class="line">               <span class="keyword">return</span></span><br><span class="line">           <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">               fmt.Println(time.Now(), <span class="string">&quot;:timer expired&quot;</span>)</span><br><span class="line">               <span class="keyword">continue</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;()</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li><code>timer</code>过期,之后从最小堆移除,此时调用<code>timer.Stop</code>会失败,失败之后需要显示抽干channel</li><li><code>timer</code>未过期,调用<code>timer.Stop</code>成功(此时channel抽干),可以直接调用<code>timer.Reset</code></li><li><code>timer</code>未过期,若调用<code>timer.Stop</code>失败,此时channel有可能之前被抽干,也有可能未被抽干,这个时候需要用<code>select&#123;&#125;</code>选择性抽干</li></ul><h2 id="time-timer和time-ticker的区别"><a href="#time-timer和time-ticker的区别" class="headerlink" title="time.timer和time.ticker的区别"></a>time.timer和time.ticker的区别</h2><ul><li><code>time.timer</code> 一次性,到期后会从最小堆移除,可以用<code>time.Reset</code>实现持续运行效果</li><li><code>time.ticker</code> 持续性,到期后执行下个周期</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;重用timer&quot;&gt;&lt;a href=&quot;#重用timer&quot; class=&quot;headerlink&quot; title=&quot;重用timer&quot;&gt;&lt;/a&gt;重用timer&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;重用的timer的目的在于减少减少创建timer实例&lt;/p&gt;
&lt;/bloc</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>sync.WaitGroup实现协程同步</title>
    <link href="https://timmy6.github.io/2021/02/20/sync-WaitGroup%E5%AE%9E%E7%8E%B0%E5%8D%8F%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>https://timmy6.github.io/2021/02/20/sync-WaitGroup%E5%AE%9E%E7%8E%B0%E5%8D%8F%E7%A8%8B%E5%90%8C%E6%AD%A5/</id>
    <published>2021-02-20T14:11:10.000Z</published>
    <updated>2022-05-18T09:11:50.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/u011304970/article/details/72722044">https://blog.csdn.net/u011304970/article/details/72722044</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Goroutine 1&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Goroutine 2&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上代码很可能看不到输出，因为有可能这两个协程还没得到执行主协程已经结束了，而主协程结束时会结束所有其他协程。</p><h2 id="管道同步方法"><a href="#管道同步方法" class="headerlink" title="管道同步方法"></a>管道同步方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    count := <span class="number">2</span> <span class="comment">// count 表示活动的协程个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Goroutine 1&quot;</span>)</span><br><span class="line">        ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 协程结束，发出信号</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Goroutine 2&quot;</span>)</span><br><span class="line">        ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 协程结束，发出信号</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> ch &#123;</span><br><span class="line">        <span class="comment">// 每次从ch中接收数据，表明一个活动的协程结束</span></span><br><span class="line">        count--</span><br><span class="line">        <span class="comment">// 当所有活动的协程都结束时，关闭管道</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">close</span>(ch)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><p>WaitGroup顾名思义，就是用来等待一组操作完成的。WaitGroup内部实现了一个计数器，用来记录未完成的操作个数，它提供了三个方法，Add()用来添加计数。Done()用来在操作结束时调用，使计数减一。Wait()用来等待所有的操作结束，即计数变为0，该函数会在计数不为0时等待，在计数为0时立即返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">2</span>) <span class="comment">// 因为有两个动作，所以增加2个计数</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Goroutine 1&quot;</span>)</span><br><span class="line">        wg.Done() <span class="comment">// 操作完成，减少一个计数</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Goroutine 2&quot;</span>)</span><br><span class="line">        wg.Done() <span class="comment">// 操作完成，减少一个计数</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    wg.Wait() <span class="comment">// 等待，直到计数为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><ul><li>定义<code>var wg sync.WaitGroup</code></li><li>增加一个<code>goroutine</code>就执行一下<code>wg.Add(1)</code>,必须在之前</li><li>执行完一个<code>goroutine</code>就执行下<code>wg.Done()</code>,计数减一</li><li>程序最后用<code>wg.Wait()</code>等待所有<code>goroutine</code>退出</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/u011304970/article/details/727220</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>索引原理分析</title>
    <link href="https://timmy6.github.io/2021/01/15/%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://timmy6.github.io/2021/01/15/%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2021-01-15T14:11:10.000Z</published>
    <updated>2022-05-18T07:58:52.280Z</updated>
    
    <content type="html"><![CDATA[<p>索引的本质是便于快速查找的数据结构，MySQL 数据库索引一般采用 B+Tree 作为索引的实现。</p><h3 id="一、磁盘-IO-与预读"><a href="#一、磁盘-IO-与预读" class="headerlink" title="一、磁盘 IO 与预读"></a>一、磁盘 IO 与预读</h3><p>上面也讲了索引的目的是为了快速查找，MySQL 的数据存储在磁盘上，快速查找意味着降低磁盘的 I&#x2F;O 次数。</p><p>磁盘 IO 是非常高昂的操作，计算机操作系统做了一些优化，当一次 IO 时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次 IO 读取的数据我们称之为一页 (page)。具体一页有多大数据跟操作系统有关，一般为 4k 或 8k，也就是我们读取一页内的数据时候，实际上才发生了一次 IO。</p><p>磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在 5ms 以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘 7200 转，表示每分钟能转 7200 次，也就是说 1 秒钟能转 120 次，旋转延迟就是 1&#x2F;120&#x2F;2 &#x3D; 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘 IO 的时间约等于 5+4.17 &#x3D; 9ms 左右，听起来还挺不错的，但要知道一台 500 -MIPS 的机器每秒可以执行 5 亿条指令，因为指令依靠的是电的性质，换句话说执行一次 IO 的时间可以执行 40 万条指令，数据库动辄十万百万乃至千万级数据，每次 9 毫秒的时间，显然是个灾难。</p><h3 id="二、B-Tree"><a href="#二、B-Tree" class="headerlink" title="二、B+Tree"></a>二、B+Tree</h3><p><img src="/images/other/mysql_index.jpeg"></p><p><strong>2.1 B+Tree 概述</strong></p><p>浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块 1 包含数据项 17 和 35，包含指针 P1、P2、P3，P1 表示小于 17 的磁盘块，P2 表示在 17 和 35 之间的磁盘块，P3 表示大于 35 的磁盘块。真实的数据存在于叶子节点即 3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如 17、35 并不真实存在于数据表中。</p><p><strong>2.2 B+Tree 查找过程</strong></p><p>如果要查找数据项 29，那么首先会把磁盘块 1 由磁盘加载到内存，此时发生一次 IO，在内存中用二分查找确定 29 在 17 和 35 之间，锁定磁盘块 1 的 P2 指针，内存时间因为非常短（相比磁盘的 IO）可以忽略不计，通过磁盘块 1 的 P2 指针的磁盘地址把磁盘块 3 由磁盘加载到内存，发生第二次 IO，29 在 26 和 30 之间，锁定磁盘块 3 的 P2 指针，通过指针加载磁盘块 8 到内存，发生第三次 IO，同时内存中做二分查找找到 29，结束查询，总计三次 IO。真实的情况是，3 层的 b+树可以表示上百万的数据，如果上百万的数据查找只需要三次 IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次 IO，那么总共需要百万次的 IO，显然成本非常非常高。</p><p><strong>2.3 B+Tree 性质</strong></p><ul><li>IO 次数取决于 b+ 树的高度 h，假设当前数据表的数据为 N，每个磁盘块的数据项的数量是 m，则有 h&#x3D;㏒(m+1)N，当数据量 N 一定的情况下，m 越大，h 越小；而 m &#x3D; 磁盘块的大小 &#x2F; 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如 int 占 4 字节，要比 bigint8 字节少一半。这也是为什么 b+ 树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于 1 时将会退化成线性表。</li><li>当 b+ 树的数据项是复合的数据结构，比如 (name,age,sex) 的时候，b+ 数是按照从左到右的顺序来建立搜索树的，比如当 (张三,20,F) 这样的数据来检索的时候，b+树会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex，最后得到检索的数据；但当 (20,F) 这样的没有 name 的数据来的时候，b+ 树就不知道下一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。比如当 (张三,F) 这样的数据来检索时，b+ 树可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</li></ul><p><strong>2.4 B+Tree 与 B-Tree 的区别</strong></p><p>B+ 树只有叶节点存放数据，其余节点用来索引，而 B- 树是每个索引节点都会有 Data 域。为什么 MySQL 索引使用 B+Tree 而不使用 B-Tree 呢？其实在上面已经讲过了，B-Tree 因为节点存放数据会导致磁盘快的数据项变少，导致树的高度变高，查找时会增加 I&#x2F;O 的次数。</p><h3 id="三、索引优化"><a href="#三、索引优化" class="headerlink" title="三、索引优化"></a>三、索引优化</h3><p><strong>3.1 优化策略</strong></p><ul><li>最佳左前缀原则：当我们创建了的索引包括多列，查询的顺序应该是从索引的最前端开始，并且不要跳过索引中的其他列（跳过只会使用索引的一部分），如果最左端的字段不包括，索引直接失效</li><li>不要在索引列上做计算，函数等操作</li><li>不要在索引上做范围操作</li><li>在查询时尽量覆盖索引列，少使用 <code>SELECT *</code></li><li>不要在索引上使用 !&#x3D; 、 &lt;&gt; 、 IS NULL 、 IS NOT NULL</li><li>少使用 OR…</li></ul><p><strong>3.2 SQL 语句分析</strong></p><p>如何判定一个 SQL 使用了索引，并评判它的性能，关于这点我们可以使用 <code>EXPLAIN</code> 关键字进行分析。以下是几个关于索引的重要字段：</p><ul><li>rows：根据表统计信息及选取索引的情况，大致估算出查到记录所需要读取的行数，所以优化语句基本上都是在优化rows</li><li>type：表示查询语句的连接类型，该字段有很多值，最好到最差的顺序是：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all ，但是对于一般来说，能够保证达到 range 级别就可以了，最好达到 ref 级别</li><li>key：实际上使用的索引，可以为 null 表示没有使用索引</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://tech.meituan.com/2014/06/30/mysql-index.html">MySQL索引原理及慢查询优化</a> by 美团技术团队 NeverMore <br><br>[2] <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a> by 张洋 <br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;索引的本质是便于快速查找的数据结构，MySQL 数据库索引一般采用 B+Tree 作为索引的实现。&lt;/p&gt;
&lt;h3 id=&quot;一、磁盘-IO-与预读&quot;&gt;&lt;a href=&quot;#一、磁盘-IO-与预读&quot; class=&quot;headerlink&quot; title=&quot;一、磁盘 IO 与预读&quot;&gt;</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>短链接生成原理</title>
    <link href="https://timmy6.github.io/2020/11/15/%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%94%9F%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <id>https://timmy6.github.io/2020/11/15/%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%94%9F%E6%88%90%E5%8E%9F%E7%90%86/</id>
    <published>2020-11-15T13:11:10.000Z</published>
    <updated>2022-05-18T07:57:33.460Z</updated>
    
    <content type="html"><![CDATA[<p>看业务代码的时候，有些逻辑用到了短链接服务，感觉还蛮有意思的，这里简单的记录一下。</p><p><img src="/images/other/8.message_short_url.png"></p><p>这种营销短信大家应该都收到过，短信有最大字符限制，而且为了更好的观感体验，短信里的链接一般都很短。现成的短链接生成服务也比较多，比如<a href="https://www.sina.lt/">新浪</a>、<a href="https://dwz.cn/console/operation">百度</a>等，谷歌之前也有短链接服务，号称是最快的，但是在 2018 年关闭了。</p><h3 id="一、短链接原理"><a href="#一、短链接原理" class="headerlink" title="一、短链接原理"></a>一、短链接原理</h3><p><img src="/images/other/9.short_url_process.png"></p><p>我们点击短链接会发起一个 GET 方式的 HTTP 请求，当请求到对应的 API 后，会解析短链接里的标识获取到对应的长链接，然后重定向到长链接，这样整个流程就结束了。</p><p>比如我用新浪的短链接服务为 <a href="https://www.google.com/">https://www.google.com/</a> 生成了一个短链接：<a href="http://dwz.date/evn">http://dwz.date/evn</a>，下面是我请求短链接时对应的 HTTP 信息：</p><p><img src="/images/other/7.short_url_http.png"></p><h3 id="二、短链接生成算法"><a href="#二、短链接生成算法" class="headerlink" title="二、短链接生成算法"></a>二、短链接生成算法</h3><p>短链接标识一般是 [0-9, a-z, A-Z] 随机组合而成的字符串，字符一共有 62 个，因此短链接标识可以用 62 进制的字符串表示。</p><p>首先维护一个自增的 ID，当生成短链接时，将 10 进制的自增 ID 转换成 62 进制字符串，这个字符串就可以唯一标识一个长链接。由于 ID 是自增的，对应的 62 进制字符串是不同的，这样就不会出现一个短链接对应多个长链接的问题，62 个字符排列组合，可以保证短链接是用不完的，就算仅限于 6 位长度标识的短链接，也有 558 亿多种情况，这种算法在网上被称为自增序列算法。</p><p>维护自增 ID 主要有以下几种方式：</p><ol><li>数据库主键自增</li><li>redis 自增</li><li>分布式自增主键 ID（雪花算法，存在 ID 浪费）</li></ol><p>下面是 62 进制的 encode 与 decode 方法，来自 <a href="https://github.com/dukky/Base62/blob/master/base62/src/im/duk/base62/Base62.java">Base62</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">base62</span><span class="params">(Long b10)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (b10 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret.insert(<span class="number">0</span>, characters.charAt((<span class="type">int</span>) (b10 % <span class="number">62</span>)));</span><br><span class="line">        b10 /= <span class="number">62</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">decodeBase62</span><span class="params">(String b62)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    b62 = <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(b62).reverse().toString();</span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> character : b62.toCharArray()) &#123;</span><br><span class="line">        ret += characters.indexOf(character) * count;</span><br><span class="line">        count *= <span class="number">62</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、一些细节"><a href="#三、一些细节" class="headerlink" title="三、一些细节"></a>三、一些细节</h3><p>自增序列算法也存在一定的缺点，当自增主键很大时，生成的 62 进制字符串会变长，以 <code>0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</code> 顺序的 62 进制为例，当主键大于 56800235583 时，会生成 7 位长度的 62 进制字符串。可以通过控制自增主键的增长速度来解决这个问题，避免主键浪费。</p><p>62 进制的顺序并不一定严格按照 <code>0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</code> 的顺序来表示，这个顺序可以是打乱的，这样生成的短链接标识更随机不易被破解。</p><p>长链接与短链接是否需要一对多关系，同一个长链接使用自增主键 ID 算法生成的短链接是不同的，因为自增主键 ID 不同，生成的 62 进制字符串自然也不同。如果我们有一个长链接唯一对应一个短链接需求，可以将长链接进行 md5 加密，将加密后的 md5 值存储在 DB 中，每次生成短链接前都根据长链接 md5 值查询 DB，如果存在，则直接返回短链接，当然也可以使用其他方式维护这种关系。</p><p>跳转用 301 还是 302，301 永久重定向，302 是临时重定向。短地址一经生成就不会变化，所以用 301 是符合 http 语义的。同时对服务器压力也会有一定减少。<br>但是如果使用了 301，我们就无法统计到短地址被点击的次数了。而这个点击次数是一个非常有意思的大数据分析数据源。能够分析出的东西非常非常多。所以选择 302 虽然会增加服务器压力，但是我想是一个更好的选择。from <a href="https://www.zhihu.com/question/29270034/answer/46446911">短 URL 系统是怎么设计的？</a> by iammutex</p><p>如果短链接请求频繁，可以借助 redis 做对应的缓存优化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看业务代码的时候，有些逻辑用到了短链接服务，感觉还蛮有意思的，这里简单的记录一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/other/8.message_short_url.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种营销短信大家应该都收到过，短信有最大字符限制，而且为了更好</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>秒杀业务总结</title>
    <link href="https://timmy6.github.io/2020/10/15/%E7%A7%92%E6%9D%80%E4%B8%9A%E5%8A%A1%E6%80%BB%E7%BB%93/"/>
    <id>https://timmy6.github.io/2020/10/15/%E7%A7%92%E6%9D%80%E4%B8%9A%E5%8A%A1%E6%80%BB%E7%BB%93/</id>
    <published>2020-10-15T13:11:10.000Z</published>
    <updated>2022-05-18T07:28:05.796Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、秒杀商品模型"><a href="#一、秒杀商品模型" class="headerlink" title="一、秒杀商品模型"></a>一、秒杀商品模型</h4><p><img src="/images/other/miaosha.png"></p><h4 id="二、架构设计"><a href="#二、架构设计" class="headerlink" title="二、架构设计"></a>二、架构设计</h4><h4 id="2-1-Redis-MQ"><a href="#2-1-Redis-MQ" class="headerlink" title="2.1 Redis + MQ"></a>2.1 Redis + MQ</h4><p><img src="/images/other/miaosha_redis.png"></p><ul><li>缓存预热：秒杀商品一般时效性比较强，一场秒杀活动持续的时间不会很长，当在后台设置秒杀活动添加秒杀商品时，把商品对应的库存直接存到 Redis，但是要注意的是，设置缓存时一定要设置过期时间。</li><li>削减请求流量：当用户进到秒杀商品详情及后续所有操作都应当进行库存、秒杀资格校验</li><li>扣减 Redis 库存：当用户从秒杀商品详情到账单页请求下单时，加分布式锁防止用户重复提交请求，等后续校验通过后，扣减 Redis 库存，通过 Redis 保证线程安全，也能保证商品不会超卖，但是此时并不扣减 DB 库存</li><li>扣减 DB 库存：用户支付核销监听交易支付成功消息，以乐观锁形式扣减 DB 库存。因为只有抢到库存后才能到后续的支付逻辑，一般到秒杀支付逻辑的流量已经很少了，当并发通过乐观锁扣减 DB 库存失败时，消息会重试，保证 Redis 库存与 DB 库存的一致性</li><li>归还 Redis 库存：用户抢到库存不一定会支付，当用户取消订单或者订单超时未支付时，监听订单取消消息，归还 Redis 库存</li><li>归还 Redis 与 DB 库存：用户下单支付后请求退款，应当归还 Redis 与 DB 的库存，这里可以考虑监听交易消息，也可以通过交易直调接口的形式处理，因为退款场景比较少，一般不会有很大的流量</li></ul><p>这种方式实现起来比较简单，对于流量不是特别大的业务一般够用了，当流量特别大时就需要在上游进行流量控制了，整个过程要考虑是否会出现缓存穿透、缓存雪崩问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、秒杀商品模型&quot;&gt;&lt;a href=&quot;#一、秒杀商品模型&quot; class=&quot;headerlink&quot; title=&quot;一、秒杀商品模型&quot;&gt;&lt;/a&gt;一、秒杀商品模型&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/other/miaosha.png&quot;&gt;&lt;/p&gt;
&lt;h4 </summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP和UDP的一些优缺点和区别</title>
    <link href="https://timmy6.github.io/2020/09/25/TCP%E5%92%8CUDP%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>https://timmy6.github.io/2020/09/25/TCP%E5%92%8CUDP%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB/</id>
    <published>2020-09-25T14:15:10.000Z</published>
    <updated>2022-05-18T06:45:03.508Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TCP 的优点：</strong> </p><p>可靠，稳定。</p><p>TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。</p><p><strong>TCP 的缺点：</strong> </p><p>慢，效率低，占用系统资源高，易被攻击。</p><p>TCP 在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的 CPU、内存等硬件资源。</p><p>而且，因为 TCP 有确认机制、三次握手机制，这些也导致 TCP 容易被人利用，实现 DOS、DDOS、CC 等攻击。</p><p><strong>UDP 的优点：</strong> </p><p>快，比 TCP 稍安全。</p><p>UDP 没有 TCP 的握手、确认、窗口、重传、拥塞控制等机制，UDP 是一个无状态的传输协议，所以它在传递数据时非常快。没有 TCP 的这些机制，UDP 较 TCP 被攻击者利用的漏洞就要少一些。但 UDP 也是无法避免攻击的，比如：UDP Flood 攻击。 </p><p><strong>UDP 的缺点：</strong> </p><p>不可靠，不稳定。</p><p>因为 UDP 没有 TCP 那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 </p><p>基于上面的优缺点，那么，TCP 和 UDP 的应用场景都有哪些呢？</p><p><strong>TCP 应用场景：</strong></p><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如 HTTP、HTTPS、FTP 等传输文件的协议，POP、SMTP 等邮件传输的协议。</p><p>在日常生活中，常见使用 TCP 协议的应用如下： 浏览器用的 HTTP， FlashFXP 用的 FTP，Outlook 用的 POP、SMTP，Putty 用的 Telnet、SSH，QQ 文件传输。</p><p><strong>UDP 应用场景：</strong> </p><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用 UDP。 </p><p>比如，日常生活中，常见使用 UDP 协议的应用如下：QQ 语音，QQ 视频，TFTP 等。有些应用场景对可靠性要求不高会用到 UPD，比如长视频，要求速率。</p><p><strong>TCP 与 UDP 区别总结：</strong></p><p>1、TCP 面向连接（如打电话要先拨号建立连接）; UDP 是无连接的，即发送数据之前不需要建立连接。</p><p>2、TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付。</p><p>3、TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的。UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</p><p>4、每一条 TCP 连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信。</p><p>5、TCP 首部开销 20 字节；UDP 的首部开销小，只有 8 个字节。</p><p>6、TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;TCP 的优点：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;可靠，稳定。&lt;/p&gt;
&lt;p&gt;TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="网络" scheme="https://timmy6.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>推荐三个实用的Go开发工具</title>
    <link href="https://timmy6.github.io/2020/08/15/%E6%8E%A8%E8%8D%90%E4%B8%89%E4%B8%AA%E4%BD%BF%E7%94%A8%E7%9A%84Go%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    <id>https://timmy6.github.io/2020/08/15/%E6%8E%A8%E8%8D%90%E4%B8%89%E4%B8%AA%E4%BD%BF%E7%94%A8%E7%9A%84Go%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</id>
    <published>2020-08-15T14:15:10.000Z</published>
    <updated>2022-05-18T06:30:53.386Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原文链接：</strong> <a href="https://mp.weixin.qq.com/s/3GLMLhegB3wF5_62mpmePA">推荐三个实用的 Go 开发工具</a></p><p>孙悟空在花果山称王的时候，特意去了一趟东海，在那里淘到了如意金箍棒。因为身为一个山大王，怎么能没有一件趁手的兵器呢？</p><p>作为程序员的我们也一样，除了我们的傍身武器 <code>Ctrl C + V</code> 之外，还要不停的补充我们的武器库。不仅要把 <code>Ctrl C + V</code> 用的高级，更要用的恰到好处。</p><p>今天介绍三款小工具，分别可以将 <code>json</code>，<code>yaml</code> 和 <code>table</code> 转成 Go 的 <code>struct</code>。下次再碰到这样的转换场景，再也不用皱眉挠头了，一键轻松搞定。</p><p>前两个直接在线转换，最后一个需要安装一个库，但也很方便。</p><h3 id="json-to-go"><a href="#json-to-go" class="headerlink" title="json-to-go"></a>json-to-go</h3><p><strong>地址：</strong> <a href="https://mholt.github.io/json-to-go/">https://mholt.github.io/json-to-go/</a></p><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;input_index&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;candidate_index&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;delivery_line_1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1 N Rosedale St&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;components&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;primary_number&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;street_predirection&quot;</span><span class="punctuation">:</span> <span class="string">&quot;N&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;street_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Rosedale&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;street_suffix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;St&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;city_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Baltimore&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;state_abbreviation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MD&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AutoGenerated []<span class="keyword">struct</span> &#123;</span><br><span class="line">InputIndex     <span class="type">int</span>    <span class="string">`json:&quot;input_index&quot;`</span></span><br><span class="line">CandidateIndex <span class="type">int</span>    <span class="string">`json:&quot;candidate_index&quot;`</span></span><br><span class="line">DeliveryLine1  <span class="type">string</span> <span class="string">`json:&quot;delivery_line_1&quot;`</span></span><br><span class="line">Components     <span class="keyword">struct</span> &#123;</span><br><span class="line">PrimaryNumber      <span class="type">string</span> <span class="string">`json:&quot;primary_number&quot;`</span></span><br><span class="line">StreetPredirection <span class="type">string</span> <span class="string">`json:&quot;street_predirection&quot;`</span></span><br><span class="line">StreetName         <span class="type">string</span> <span class="string">`json:&quot;street_name&quot;`</span></span><br><span class="line">StreetSuffix       <span class="type">string</span> <span class="string">`json:&quot;street_suffix&quot;`</span></span><br><span class="line">CityName           <span class="type">string</span> <span class="string">`json:&quot;city_name&quot;`</span></span><br><span class="line">StateAbbreviation  <span class="type">string</span> <span class="string">`json:&quot;state_abbreviation&quot;`</span></span><br><span class="line">&#125; <span class="string">`json:&quot;components&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="yaml-to-go"><a href="#yaml-to-go" class="headerlink" title="yaml-to-go"></a>yaml-to-go</h3><p><strong>地址：</strong> <a href="https://zhwt.github.io/yaml-to-go/">https://zhwt.github.io/yaml-to-go/</a></p><p>输入：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">golang:latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">$GOPATH/src/$(dirname</span> <span class="string">$REPO_NAME)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ln</span> <span class="string">-svf</span> <span class="string">$CI_PROJECT_DIR</span> <span class="string">$GOPATH/src/$REPO_NAME</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">$GOPATH/src/$REPO_NAME</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">format:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">go</span> <span class="string">fmt</span> <span class="string">$(go</span> <span class="string">list</span> <span class="string">./...</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">-v</span> <span class="string">/vendor/)</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">go</span> <span class="string">vet</span> <span class="string">$(go</span> <span class="string">list</span> <span class="string">./...</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">-v</span> <span class="string">/vendor/)</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">go</span> <span class="string">test</span> <span class="string">-race</span> <span class="string">$(go</span> <span class="string">list</span> <span class="string">./...</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">-v</span> <span class="string">/vendor/)</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AutoGenerated <span class="keyword">struct</span> &#123;</span><br><span class="line">Image        <span class="type">string</span>   <span class="string">`yaml:&quot;image&quot;`</span></span><br><span class="line">BeforeScript []<span class="type">string</span> <span class="string">`yaml:&quot;before_script&quot;`</span></span><br><span class="line">Stages       []<span class="type">string</span> <span class="string">`yaml:&quot;stages&quot;`</span></span><br><span class="line">Format       <span class="keyword">struct</span> &#123;</span><br><span class="line">Stage  <span class="type">string</span>   <span class="string">`yaml:&quot;stage&quot;`</span></span><br><span class="line">Script []<span class="type">string</span> <span class="string">`yaml:&quot;script&quot;`</span></span><br><span class="line">&#125; <span class="string">`yaml:&quot;format&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="table-to-go"><a href="#table-to-go" class="headerlink" title="table-to-go"></a>table-to-go</h3><p><strong>地址</strong> <a href="https://github.com/gohouse/converter">https://github.com/gohouse/converter</a></p><p>假设有这样一张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `prefix_user` (</span><br><span class="line">  `Id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `Email` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  `Password` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `CreatedAt` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`Id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span></span><br></pre></td></tr></table></figure><p>使用方式分两种，分别是命令行调用和写 Go 代码：</p><h4 id="命令行调用"><a href="#命令行调用" class="headerlink" title="命令行调用"></a>命令行调用</h4><p>1、下载对应平台的可执行文件， 下载地址：<a href="https://github.com/gohouse/converter/releases">https://github.com/gohouse/converter/releases</a></p><p>2、命令行执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./table2struct-linux.v0.0.3.bin -file model.go -dsn xxx -table user</span><br></pre></td></tr></table></figure><p>3、参数说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-dsn            string 数据库dsn配置</span><br><span class="line">-enableJsonTag  bool 是否添加json的tag</span><br><span class="line">-file           string 保存路径</span><br><span class="line">-packageName    string 包名</span><br><span class="line">-prefix         string 表前缀</span><br><span class="line">-realNameMethod string 结构体对应的表名</span><br><span class="line">-table          string 要迁移的表</span><br><span class="line">-tagKey         string tag的key</span><br></pre></td></tr></table></figure><h4 id="Go-代码调用"><a href="#Go-代码调用" class="headerlink" title="Go 代码调用"></a>Go 代码调用</h4><p>安装库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/gohouse/converter</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gohouse/converter&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">t2t := converter.NewTable2Struct()</span><br><span class="line"><span class="comment">// 个性化配置</span></span><br><span class="line">t2t.Config(&amp;converter.T2tConfig&#123;</span><br><span class="line"><span class="comment">// 如果字段首字母本来就是大写, 就不添加tag, 默认false添加, true不添加</span></span><br><span class="line">RmTagIfUcFirsted: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">// tag的字段名字是否转换为小写, 如果本身有大写字母的话, 默认false不转</span></span><br><span class="line">TagToLower: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">// 字段首字母大写的同时, 是否要把其他字母转换为小写,默认false不转换</span></span><br><span class="line">UcFirstOnly: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">//// 每个struct放入单独的文件,默认false,放入同一个文件(暂未提供)</span></span><br><span class="line"><span class="comment">//SeperatFile: false,</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 开始迁移转换</span></span><br><span class="line">err := t2t.</span><br><span class="line"><span class="comment">// 指定某个表,如果不指定,则默认全部表都迁移</span></span><br><span class="line">Table(<span class="string">&quot;user&quot;</span>).</span><br><span class="line"><span class="comment">// 表前缀</span></span><br><span class="line">Prefix(<span class="string">&quot;prefix_&quot;</span>).</span><br><span class="line"><span class="comment">// 是否添加json tag</span></span><br><span class="line">EnableJsonTag(<span class="literal">true</span>).</span><br><span class="line"><span class="comment">// 生成struct的包名(默认为空的话, 则取名为: package model)</span></span><br><span class="line">PackageName(<span class="string">&quot;model&quot;</span>).</span><br><span class="line"><span class="comment">// tag字段的key值,默认是orm</span></span><br><span class="line">TagKey(<span class="string">&quot;orm&quot;</span>).</span><br><span class="line"><span class="comment">// 是否添加结构体方法获取表名</span></span><br><span class="line">RealNameMethod(<span class="string">&quot;TableName&quot;</span>).</span><br><span class="line"><span class="comment">// 生成的结构体保存路径</span></span><br><span class="line">SavePath(<span class="string">&quot;/Users/fizz/go/src/github.com/gohouse/gupiao/model/model.go&quot;</span>).</span><br><span class="line"><span class="comment">// 数据库dsn,这里可以使用 t2t.DB() 代替,参数为 *sql.DB 对象</span></span><br><span class="line">Dsn(<span class="string">&quot;root:root@tcp(localhost:3306)/test?charset=utf8&quot;</span>).</span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line">Run()</span><br><span class="line"></span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id         <span class="type">int</span>     <span class="string">`json:&quot;Id&quot; orm:&quot;Id&quot;`</span></span><br><span class="line">Email      <span class="type">string</span>  <span class="string">`json:&quot;Email&quot; orm:&quot;Email&quot;`</span>           <span class="comment">// 邮箱</span></span><br><span class="line">Password   <span class="type">string</span>  <span class="string">`json:&quot;Password&quot; orm:&quot;Password&quot;`</span>     <span class="comment">// 密码</span></span><br><span class="line">CreatedAt  <span class="type">string</span>  <span class="string">`json:&quot;CreatedAt&quot; orm:&quot;CreatedAt&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;user&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收藏吧！希望你用到的时候还能想起它。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;原文链接：&lt;/strong&gt; &lt;a href=&quot;https://mp.weixin.qq.com/s/3GLMLhegB3wF5_62mpmePA&quot;&gt;推荐三个实用的 Go 开发工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;孙悟空在花果山称王的时候，特意去了一趟东海，在那里淘到</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>rabbitmq基本操作</title>
    <link href="https://timmy6.github.io/2020/07/05/rabbitmq%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>https://timmy6.github.io/2020/07/05/rabbitmq%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2020-07-05T14:15:10.000Z</published>
    <updated>2022-05-17T07:03:05.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.toutiao.com/i6826959307888656899/">https://www.toutiao.com/i6826959307888656899/</a></li><li><a href="https://www.cnblogs.com/Zhangcsc/p/11739754.html">https://www.cnblogs.com/Zhangcsc/p/11739754.html</a></li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="交换机exchange"><a href="#交换机exchange" class="headerlink" title="交换机exchange"></a>交换机exchange</h3><p>接收消息，并根据路由键转发消息到所绑定的队列</p><h3 id="交换机的4种类型"><a href="#交换机的4种类型" class="headerlink" title="交换机的4种类型"></a>交换机的4种类型</h3><ul><li>topic 对路由键进行模式匹配，将消息转发到匹配上的队列上，其中<code>*</code> 表示匹配任意一个单词，<code>#</code> 表示匹配任意一个或多个单词，使用<code>.</code>分割单词，例如路由键<code>quick.orange.rabbit</code>，可以匹配上绑定键<code>quick.#</code>,<code>*.orange.rabbit</code></li><li>direct 要求路由键必须与绑定key完全匹配，这样才会被转发对应的队列</li><li>fanout 不处理路由键。你只需要简单的将队列绑定到交换机上，一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上</li><li>headers 不处理路由键，而是根据消息内容中的headers属性进行匹配</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><code>basic.consume</code>持续订阅,自动接收下一条消息</li><li><code>basic.get</code>获取单条消息</li><li><code>basic.ack</code>确认收到消息,或者消费者在订阅到队列的时候就将<code>auto ack</code>设置为true</li><li><code>basic.reject</code>丢弃消息,如果将<code>reject</code>命令的<code>requeue</code>参数设置为true的话,<code>rabbitmq</code>会将消息投递给下个消费者,否则会立即从队列删除消息并且存放到死信队列</li><li><code>queue.declare</code>创建队列,如果不指定名称则随机分配一个名称,作为匿名队列<ul><li><code>exclusive</code>限制只有由一个消费者够消费</li><li><code>auto-delete</code>当最后一个消费者取消订阅时候,队列会自动移除</li><li>当重复声明一个已存在的队列,若声明参数完全匹配现存队列,rabbit什么都不会做并返回成功</li><li>设置<code>queue.declare</code>的<code>passive</code>为<code>true</code>时,如果队列已存在,<code>queue.declare</code>返回成功,如果队列不存在,<code>queue.declare</code>命令不会创建队列而会返回一个错误</li></ul></li></ul><h2 id="应该由生成者还是消费者创建队列呢"><a href="#应该由生成者还是消费者创建队列呢" class="headerlink" title="应该由生成者还是消费者创建队列呢?"></a>应该由生成者还是消费者创建队列呢?</h2><p>假设由消费者创建队列,若生成者先投递消息,此时还没有消费者,这个时候消息会怎么样?当有消费者了并且创建队列了会怎么样?<br>答: 消息会提示发送成功,但是事实上它已经丢失了,即时消费者创建队列了也不能消费之前的发布的消息,最好的做法是消费者和生成者都要尝试创建队列,并且绑定队列和交换器</p><h2 id="生产消息"><a href="#生产消息" class="headerlink" title="生产消息"></a>生产消息</h2><ul><li>AMQP_NOPARAM 无</li><li>AMQP_DURABLE 持久化exchange</li><li>AMQP_PASSIVE 声明一个已存在的交换器的，如果不存在将抛出异常，这个一般用在consume端。因为一般produce端创建,在consume端建议设置成AMQP_PASSIVE,防止consume创建exchange</li><li>AMQP_AUTODELETE 该交换器将在没有消息队列绑定时自动删除</li></ul><h2 id="为什么要用信道channel"><a href="#为什么要用信道channel" class="headerlink" title="为什么要用信道channel"></a>为什么要用信道channel</h2><p>为了减少tcp连接开销,多个通道可以共享tcp连接???</p><h2 id="什么是消息幂等性？"><a href="#什么是消息幂等性？" class="headerlink" title="什么是消息幂等性？"></a>什么是消息幂等性？</h2><p>无论一条消息被消费多少次，消费的结果都是一样的。</p><h2 id="什么是confirm消息确认机制？"><a href="#什么是confirm消息确认机制？" class="headerlink" title="什么是confirm消息确认机制？"></a>什么是confirm消息确认机制？</h2><p>生成者生成消息，Broker收到消息就会给生产者一个应答，生产者接受应答来确认broker是否收到消息。</p><h3 id="如何实现confirm确认消息？"><a href="#如何实现confirm确认消息？" class="headerlink" title="如何实现confirm确认消息？"></a>如何实现confirm确认消息？</h3><ul><li>在Channel上开启确认模式：<code>channel.confirmSelect()</code></li><li>在channel上添加监听：<code>addConfirmListener</code>，监听成功和失败的结果，具体结果对消息进行重新发送或者记录日志。</li></ul><h2 id="如何生成的消息匹配不到队列会怎么样？"><a href="#如何生成的消息匹配不到队列会怎么样？" class="headerlink" title="如何生成的消息匹配不到队列会怎么样？"></a>如何生成的消息匹配不到队列会怎么样？</h2><p>如果<code>Mandatory</code>设置为true，如果找不到队列，则broker会调用<code>basic.return</code>方法将消息返还给生产者;当<code>mandatory</code>设置为false时，出现上述情况broker会直接将消息丢弃;通俗的讲，mandatory标志告诉broker代理服务器至少将消息route到一个队列中，否则就将消息return给发送者;<br><strong>Mandatory设置为true只有在confirm模式有效</strong></p><h3 id="如何获得被return回来的消息？"><a href="#如何获得被return回来的消息？" class="headerlink" title="如何获得被return回来的消息？"></a>如何获得被return回来的消息？</h3><p>通过为channel信道设置<code>ReturnListener</code>监听器来实现</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="keyword">__DIR__</span> . <span class="string">&#x27;/vendor/autoload.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Connection</span>\<span class="title">AMQPStreamConnection</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Message</span>\<span class="title">AMQPMessage</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$connection</span> = <span class="keyword">new</span> <span class="title class_">AMQPStreamConnection</span>(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">5672</span>, <span class="string">&#x27;guest&#x27;</span>, <span class="string">&#x27;guest&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="variable">$channel</span> = <span class="variable">$connection</span>-&gt;<span class="title function_ invoke__">channel</span>();</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">set_return_listener</span>(function (<span class="variable">$i</span>,<span class="variable">$msg</span>,<span class="variable">$exchange</span>,<span class="variable">$routeKey</span>,AMQPMessage <span class="variable">$message</span>) &#123;</span><br><span class="line">   <span class="title function_ invoke__">print_r</span>(<span class="variable">$message</span>-&gt;body);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">confirm_select</span>();</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">set_ack_handler</span>(function (AMQPMessage <span class="variable">$message</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">print_r</span>(<span class="variable">$message</span>-&gt;body);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">exchange_declare</span>(<span class="string">&#x27;hyperf&#x27;</span>, <span class="string">&#x27;topic&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_declare</span>(<span class="string">&#x27;kt-test&#x27;</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_bind</span>(<span class="string">&#x27;kt-test&#x27;</span>, <span class="string">&#x27;kt-test&#x27;</span>, <span class="string">&#x27;kt-test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">2</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="keyword">new</span> <span class="title class_">AMQPMessage</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">    <span class="comment">//设置一个匹配不到队列的路由键，mandatory设置为true</span></span><br><span class="line">    <span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">basic_publish</span>(<span class="variable">$msg</span>, <span class="string">&#x27;hyperf&#x27;</span>, <span class="string">&#x27;kjfwelf&#x27;</span>,<span class="literal">true</span>); </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot; [x] Sent &#x27;Hello World!&#x27;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">wait_for_pending_acks_returns</span>(<span class="number">10</span>); <span class="comment">//等待</span></span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line"><span class="variable">$connection</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br></pre></td></tr></table></figure><h2 id="什么是消费端的限流？"><a href="#什么是消费端的限流？" class="headerlink" title="什么是消费端的限流？"></a>什么是消费端的限流？</h2><p>rabbitMQ提供了一种<code>qos</code>的功能，即非自动确认消息的前提下，如果有一定数目的消息（通过consumer或者Channel设置qos）未被确认，不进行新的消费。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">basic_qos</span>(<span class="variable">$prefetch_size</span>, <span class="variable">$prefetch_count</span>, <span class="variable">$a_global</span>);</span><br></pre></td></tr></table></figure><ul><li>prefetchSize:0 单条消息的大小限制。0就是不限制，一般都是不限制。</li><li>prefetchCount: 设置一个固定的值，一旦有N个消息还没有ack，则consumer将block掉，直到有消息ack</li><li>global：是否将上面的设置用于channel，也是就是说上面设置的限制是用于channel级别的还是consumer的级别的。</li></ul><h2 id="什么是TTL队列-x2F-消息？"><a href="#什么是TTL队列-x2F-消息？" class="headerlink" title="什么是TTL队列&#x2F;消息？"></a>什么是TTL队列&#x2F;消息？</h2><ul><li>支持消息的过期时间，在消息发送时可以指定。</li><li>支持队列过期时间，在消息入队列开始计算时间，只要超过了队列的超时时间配置，那么消息就会自动的清除。</li></ul><h2 id="什么是死信队列？"><a href="#什么是死信队列？" class="headerlink" title="什么是死信队列？"></a>什么是死信队列？</h2><p>死信队列：DLX，Dead-Letter-Exchange</p><h3 id="消息变为死信的几种情况："><a href="#消息变为死信的几种情况：" class="headerlink" title="消息变为死信的几种情况："></a>消息变为死信的几种情况：</h3><ul><li>消息被拒绝（basic.reject&#x2F;basic.nack）同时requeue&#x3D;false（不重回队列）</li><li>TTL过期</li><li>队列达到最大长度<br><a href="https://www.cnblogs.com/Zhangcsc/p/11739754.html">https://www.cnblogs.com/Zhangcsc/p/11739754.html</a><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="keyword">__DIR__</span> . <span class="string">&#x27;/vendor/autoload.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Connection</span>\<span class="title">AMQPStreamConnection</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Message</span>\<span class="title">AMQPMessage</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Wire</span>\<span class="title">AMQPTable</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$connection</span> = <span class="keyword">new</span> <span class="title class_">AMQPStreamConnection</span>(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">5672</span>, <span class="string">&#x27;guest&#x27;</span>, <span class="string">&#x27;guest&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="variable">$channel</span> = <span class="variable">$connection</span>-&gt;<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$args</span> = <span class="keyword">new</span> <span class="title class_">AMQPTable</span>();</span><br><span class="line"><span class="comment">// 消息过期方式：设置 queue.normal 队列中的消息10s之后过期</span></span><br><span class="line"><span class="variable">$args</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;x-message-ttl&#x27;</span>, <span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 设置队列最大长度方式： x-max-length</span></span><br><span class="line"><span class="comment">//$args-&gt;set(&#x27;x-max-length&#x27;, 1);</span></span><br><span class="line"><span class="variable">$args</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;x-dead-letter-exchange&#x27;</span>, <span class="string">&#x27;exchange.dlx&#x27;</span>);</span><br><span class="line"><span class="variable">$args</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;x-dead-letter-routing-key&#x27;</span>, <span class="string">&#x27;routingkey&#x27;</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">exchange_declare</span>(<span class="string">&#x27;exchange.dlx&#x27;</span>, <span class="string">&#x27;direct&#x27;</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_declare</span>(<span class="string">&#x27;queue.dlx&#x27;</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_bind</span>(<span class="string">&#x27;queue.dlx&#x27;</span>, <span class="string">&#x27;exchange.dlx&#x27;</span>, <span class="string">&#x27;routingkey&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">exchange_declare</span>(<span class="string">&#x27;hyperf&#x27;</span>, <span class="string">&#x27;topic&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_declare</span>(<span class="string">&#x27;test-ttl&#x27;</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>,<span class="literal">false</span>,<span class="variable">$args</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_bind</span>(<span class="string">&#x27;test-ttl&#x27;</span>, <span class="string">&#x27;hyperf&#x27;</span>, <span class="string">&#x27;kt-test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">2</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="keyword">new</span> <span class="title class_">AMQPMessage</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">    <span class="comment">//设置一个匹配不到队列的路由键，mandatory设置为true</span></span><br><span class="line">    <span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">basic_publish</span>(<span class="variable">$msg</span>, <span class="string">&#x27;hyperf&#x27;</span>, <span class="string">&#x27;kt-test&#x27;</span>,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot; [x] Sent &#x27;Hello World!&#x27;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line"><span class="variable">$connection</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.toutiao.com/i6826959307888656899/&quot;&gt;https://</summary>
      
    
    
    
    <category term="rabbitmq" scheme="https://timmy6.github.io/categories/rabbitmq/"/>
    
    
  </entry>
  
  <entry>
    <title>微服务</title>
    <link href="https://timmy6.github.io/2020/06/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>https://timmy6.github.io/2020/06/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-06-02T14:15:10.000Z</published>
    <updated>2022-05-17T06:52:16.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>每个子业务独立部署，不会互相影响</li><li>每个子业务可以使用不同的开发语言</li></ul><h2 id="grpc和protobuf"><a href="#grpc和protobuf" class="headerlink" title="grpc和protobuf"></a>grpc和protobuf</h2><ul><li>gRPC 是谷歌开源的轻量级 RPC 通信框架，其中的通信协议基于二进制数据流，支持 HTTP 2.0 协议，还可以为通信双方建立持续的双向数据流</li><li>protobuf 两个微服务之间通过基于 HTTP 2.0 二进制数据帧通信，那么如何约定二进制数据的格式呢？答案是使用 gRPC 内置的 protobuf 协议，其 DSL 语法 可清晰定义服务间通信的数据结构</li></ul><h2 id="docker容器"><a href="#docker容器" class="headerlink" title="docker容器"></a>docker容器</h2><p>多个容器共享宿主主机的 kernel，多个容器之间相互隔离</p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>它作为一个注册中心会记录每个微服务的 IP 和端口，各微服务上线时会在它那注册，下线时会注销</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/micro/protobuf/proto</span><br><span class="line">go get -u github.com/micro/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure><h2 id="微服务的优点"><a href="#微服务的优点" class="headerlink" title="微服务的优点"></a>微服务的优点</h2><ul><li>各个子模块互相独立，可以选用不同的技术栈，独立开发和维护。</li><li>故障隔离，一个服务挂掉不会影响其他服务。</li></ul><h2 id="微服务的缺点"><a href="#微服务的缺点" class="headerlink" title="微服务的缺点"></a>微服务的缺点</h2><ul><li>数据一致性</li><li>事务问题</li><li>session一致性问题</li><li>锁问题</li><li>单个服务不可用导致整个系统崩溃（熔断器）</li><li>不同开发团队需要紧密协作。</li><li>定位问题难，问题日志可能分布在多台nginx上</li><li>系统变得更加复杂，运维也是个问题。</li></ul><h2 id="如何保障微服务架构下的数据一致性？"><a href="#如何保障微服务架构下的数据一致性？" class="headerlink" title="如何保障微服务架构下的数据一致性？"></a>如何保障微服务架构下的数据一致性？</h2><p><a href="https://www.cnblogs.com/mahatmasmile/p/8530077.html">https://www.cnblogs.com/mahatmasmile/p/8530077.html</a><br>CAP理论，c一致性，a可用性，p分区容错性<br>具体表现为在一定时间内，可能模块之间数据是不一致的，但是通过自动或手动补偿后能够达到最终的一致。<br>二阶段提交协议<br>可靠消息最终一致性</p><ul><li>上游应用将本地业务执行和消息发送绑定在同一个本地事务中，保证要么本地操作成功并发送 MQ 消息</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;每个子业务独立部署，不会互相影响&lt;/li&gt;
&lt;li&gt;每个子业务可以使用不同的开发语言&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;gr</summary>
      
    
    
    
    <category term="微服务" scheme="https://timmy6.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>程序常用算法</title>
    <link href="https://timmy6.github.io/2020/05/20/%E7%A8%8B%E5%BA%8F%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    <id>https://timmy6.github.io/2020/05/20/%E7%A8%8B%E5%BA%8F%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</id>
    <published>2020-05-20T15:15:10.000Z</published>
    <updated>2022-05-17T06:50:09.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="给定一个数组-找最大元素值"><a href="#给定一个数组-找最大元素值" class="headerlink" title="给定一个数组,找最大元素值"></a>给定一个数组,找最大元素值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> arr = []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">45</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">var</span> beginPtr = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> endPtr = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> beginPtr &lt; endPtr &#123; <span class="comment">// 知道两个位置重叠,这个数即为最大值(最小值)</span></span><br><span class="line"><span class="keyword">if</span> arr[beginPtr] &gt; arr[endPtr] &#123;</span><br><span class="line">endPtr--</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">beginPtr++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;max value:&quot;</span>, arr[beginPtr])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给定一个数组-随机找其中几个不重复的元素"><a href="#给定一个数组-随机找其中几个不重复的元素" class="headerlink" title="给定一个数组,随机找其中几个不重复的元素"></a>给定一个数组,随机找其中几个不重复的元素</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line"><span class="keyword">var</span> arr = []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="keyword">var</span> total = <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">j := rand.Int()%total + i <span class="comment">// 从剩余元素中随机抽取一个元素</span></span><br><span class="line">arr[i], arr[j] = arr[j], arr[i] <span class="comment">// 将随机抽取的元素替换掉开头的元素</span></span><br><span class="line">total-- </span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>任何数字和某个数字a求余时,其结果不会超过a</li><li><code>rand.Int()%total</code>,随着total递减,所以改表达式求值结果最大值不会超过剩余元素个数</li><li><code>rand.Int()%total + i</code>,加<code>i</code>的目的是让元素位置往后移动</li><li><code>arr[i], arr[j] = arr[j], arr[i]</code>,后面的随机数会替换掉前面的数字</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;给定一个数组-找最大元素值&quot;&gt;&lt;a href=&quot;#给定一个数组-找最大元素值&quot; class=&quot;headerlink&quot; title=&quot;给定一个数组,找最大元素值&quot;&gt;&lt;/a&gt;给定一个数组,找最大元素值&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://timmy6.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://timmy6.github.io/2020/05/10/%E9%93%BE%E8%A1%A8/"/>
    <id>https://timmy6.github.io/2020/05/10/%E9%93%BE%E8%A1%A8/</id>
    <published>2020-05-10T15:15:10.000Z</published>
    <updated>2022-05-17T06:48:49.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul><li>相对于数组,链表不需要连续的存储地址</li><li>每一个节点会记录下一个节点的地址</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/weixin_41582192/article/details/81181077">https://blog.csdn.net/weixin_41582192/article/details/81181077</a></li></ul><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="节点内部结构"><a href="#节点内部结构" class="headerlink" title="节点内部结构"></a>节点内部结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">int</span></span><br><span class="line">    Next *node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>头节点没有data,有next</li><li>尾节点有data,没有next</li></ul><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>例如<code>a-&gt;b-&gt;c</code>,删除b,流程如下:</p><ul><li>根据b.next获取c的地址</li><li>要怎么找到a,并将a.next赋值为c的地址<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3>例如<code>a-&gt;c</code>之间插入b,流程如下:</li><li>创建b节点</li><li>根据a.next获取c的地址,然后赋值为b.next</li><li>将b的地址赋值给a.next</li></ul><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h3 id="节点内部结构-1"><a href="#节点内部结构-1" class="headerlink" title="节点内部结构"></a>节点内部结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">int</span></span><br><span class="line">    Next *node</span><br><span class="line">    Prev *node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;相对于数组,链表不需要连续的存储地址&lt;/li&gt;
&lt;li&gt;每一个节点会记录下一个节点的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://timmy6.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>redis架构模式</title>
    <link href="https://timmy6.github.io/2020/04/12/redis%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>https://timmy6.github.io/2020/04/12/redis%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-12T14:15:10.000Z</published>
    <updated>2022-05-17T06:41:01.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-有哪些架构模式？讲讲各自的特点"><a href="#Redis-有哪些架构模式？讲讲各自的特点" class="headerlink" title="Redis 有哪些架构模式？讲讲各自的特点"></a>Redis 有哪些架构模式？讲讲各自的特点</h2><ul><li>单机版</li><li>主从复制</li><li>哨兵模式（监控主从服务器，主服务器下线能够自动进行故障转移）</li><li>集群</li></ul><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>大概两个过程：</p><ul><li>从节点发送sync给主节点，主节点发送rdb快照文件给从节点，从节点从快照文件同步数据</li><li>主节点每写一个命令就会同步到从节点，从节点接收并执行收到的命令</li></ul><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>一般使用3个哨兵，1主2从</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>监控主节点和从节点的状态</li><li>当主节点发送故障，会自动将从节点转换为主节点，整个过程不需要人工参与<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3></li><li>哨兵节点会向所有主从节点和其他哨兵节点发送ping消息，如果主节点在一定时间内（down-after-milliseconds）没有得到回复，则会被哨兵节点标记为主观下线（SDOWN）。</li><li>当有足够数据量的哨兵节点标记主节点为主观下线，则主节点会标记为客观下线。</li><li>主节点会进行故障转移，选取一个从节点来替换主节点。<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3>准备节点：3个哨兵，1主，2从；</li><li>主从节点主要配置如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使得Redis服务器可以跨网络访问</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line"><span class="comment"># 设置密码</span></span><br><span class="line">requirepass <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="comment"># 指定主服务器，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置</span></span><br><span class="line">slaveof 192.168.11.128 6379</span><br><span class="line"><span class="comment"># 主服务器密码，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置</span></span><br><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure></li><li>哨兵节点配置如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 禁止保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"><span class="comment"># 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。</span></span><br><span class="line">sentinel monitor mymaster 192.168.11.128 6379 2</span><br><span class="line"><span class="comment"># sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure></li><li>启动哨兵节点和主从节点<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/wwwroot/redis/redis_sentinel</span><br><span class="line"><span class="comment">#启动redis</span></span><br><span class="line">redis-server redis_6480/redis.conf <span class="comment">#这个是主节点</span></span><br><span class="line">redis-server redis_6481/redis.conf</span><br><span class="line">redis-server redis_6482/redis.conf</span><br><span class="line"><span class="comment">#查看主从是否启动成功</span></span><br><span class="line">redis-cli -h 127.0.0.1 -p 6480 ping</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6480 info replication</span><br><span class="line"><span class="comment">#启动哨兵</span></span><br><span class="line">redis-sentinel sentinel_26379/sentinel.conf</span><br><span class="line">redis-sentinel sentinel_26380/sentinel.conf</span><br><span class="line">redis-sentinel sentinel_26381/sentinel.conf</span><br><span class="line"><span class="comment">#确认哨兵是否启用成功</span></span><br><span class="line">redis-cli -p 26379 info sentinel</span><br></pre></td></tr></table></figure></li></ul><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>redis的集群采用无中心结构，所有redis节点彼此互联（PING—PONG机制），当某个节点失败时需要集群中超过半数节点检测失效才会生效。客户端与redis节点直连，不需要借助中间代理层，客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。</p><h3 id="集群数据分布"><a href="#集群数据分布" class="headerlink" title="集群数据分布"></a>集群数据分布</h3><p>每一个节点负责维护一部分槽和槽存放的数据，槽的范围是0到16383<br>key -&gt; 槽 -&gt; 节点</p><h3 id="集群请求路由"><a href="#集群请求路由" class="headerlink" title="集群请求路由"></a>集群请求路由</h3><ul><li>先计算key对应的槽，可以通过<code>cluster keyslot &#123;key&#125;</code>查看对应哪个槽</li><li>找槽对应的节点</li><li>若不是本节点，则回复move重定向错误，通知客户端请求正确的节点<br>cli模式下重定向，加上<code>-c</code>参数，例如<code>redis-cli -p 6481 -c</code><h3 id="如何解决集群mget问题？"><a href="#如何解决集群mget问题？" class="headerlink" title="如何解决集群mget问题？"></a>如何解决集群mget问题？</h3></li></ul><p>集群带来的一个问题是，无法批处理，例如当我们提交了一批命令，往Redis中存储一批键，那么这些键一般会被映射到不同的slot，而不同的slot又可能在Redis Cluster中不同的节点上，这样就和的预期有点不同，有没有办法将这批键映射到同一个slot呢？</p><p>可以使用<code>hash_tag</code>，哈希标签是确保两个键都在同一个哈希槽里的一种方式。</p><ul><li>比如这两个键 {user1000}.following 和 {user1000}.followers 会被哈希到同一个哈希槽里，因为只有 user1000 这个子串会被用来计算哈希值。</li><li>对于 foo{}{bar} 这个键，整个键都会被用来计算哈希值，因为第一个出现的 { 和它右边第一个出现的 } 之间没有任何字符。</li><li>对于 foo{bar}{zap} 这个键，用来计算哈希值的是 bar 这个子串，因为算法会在第一次有效或无效（比如中间没有任何字节）地匹配到 { 和 } 的时候停止。</li></ul><p><img src="/assets/1615987751665.png" alt="1615987751665"></p><h3 id="集群是如何扩容"><a href="#集群是如何扩容" class="headerlink" title="集群是如何扩容?"></a>集群是如何扩容?</h3><ul><li>添加新节点，<code>redis-trib.rb add-node new_host:new_port exitsing_host:existing_port</code> ，新加入节点刚开始都是主节点状态，没有负责槽，不能接收任何读写操作，需要导入槽和数据，或者是设置为从节点</li><li>迁移过程<code>redis-trib.rb reshard &#123;existing_ip:existing_port&#125;</code><ul><li>目标节点准备导入槽</li><li>源节点准备导出槽</li><li>获取槽下n个key</li><li>批量迁移相关key的数据</li><li>循环迁移key</li><li>通知槽分配给目标节点</li></ul></li><li>新节点设置成从节点，具体进入从节点命令行，执行cluster replicate master_id</li></ul><h3 id="集群是如何缩容？"><a href="#集群是如何缩容？" class="headerlink" title="集群是如何缩容？"></a>集群是如何缩容？</h3><ul><li>下线节点是否有负责的槽 ，如果有的话需要先迁移到其他节点上，命令<code>使用redis-trib.rb reshared &#123;existing_ip:existing_port&#125;</code></li><li>当下线节点不再负责槽或者本身是从节点就可以通知集群其他节点忘记下线节点，命令<code>使用redis-trib.rb del-node &#123;host:port&#125; &#123;downNodeId&#125; 忘记节点</code></li><li>下线节点正常关闭</li></ul><h3 id="集群是如何故障转移的？"><a href="#集群是如何故障转移的？" class="headerlink" title="集群是如何故障转移的？"></a>集群是如何故障转移的？</h3><ul><li>首先，如果一个节点在规定时间内没有回复，会被其他节点标记为主观下线</li><li>如果被超过半数的节点标记为主观下线，则故障节点会被标为客观下线</li><li>资格检查；当从节点通过内部定时任务发现自身复制的主节点进入客观下线时，则会触发选举，触发条件：断线时间不超过<code>cluster-node-time*cluster-slave-validity-fator</code>，目的是剔除太久没有同步主节点数据的从节点</li><li>准备选举时间；一个故障主节点可能会有多个从节点，这就需要有发起选举的优先级，主要根据复制偏移量来设置延迟选举时间，复制偏移量越大，排名越靠前，延迟时间越低，越有机会才会主节点</li><li>选举投票；<ul><li>只有持有槽的主节点才能参与选举投票</li><li>只有一个从节点获得n&#x2F;2+1的选票才能选举成功</li><li>在<code>clsuter-node-timeout*2</code>内从节点没有获取足够数量的投票，选举作废</li></ul></li><li>替换主节点，接管故障节点的槽和通知集群</li></ul><h3 id="迁移槽命令参数"><a href="#迁移槽命令参数" class="headerlink" title="迁移槽命令参数"></a>迁移槽命令参数</h3><p><code>redis-trib.rb reshard &#123;existing_ip:existing_port&#125;</code></p><ul><li>–slots 需要确定迁移槽的总数量，总槽数&#x2F;总节点</li><li>–from 多个源节点，迁出槽</li><li>–to 一个目标节点，迁入槽</li><li>–timeout 控制每次migrate操作的超时时间，默认为60000毫秒</li><li>–pipeline 控制每次批量迁移键的数量，默认为10</li><li>host:port 集群中任意一个节点的地址</li></ul><h2 id="docker安装redis"><a href="#docker安装redis" class="headerlink" title="docker安装redis"></a>docker安装redis</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 redis</span><br></pre></td></tr></table></figure><h2 id="配置文件修改"><a href="#配置文件修改" class="headerlink" title="配置文件修改"></a>配置文件修改</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port 6481</span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line"><span class="comment">#集群内部配置文件</span></span><br><span class="line">cluster-config-file nodes-6481.conf</span><br><span class="line"><span class="comment">#节点超时时间，单位毫秒</span></span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line">logfile <span class="string">&quot;/data/wwwroot/redis/redis_cluster/6481/log/redis-6481.log&quot;</span></span><br><span class="line">pidfile /data/wwwroot/redis/redis_cluster/redis-6481.pid</span><br></pre></td></tr></table></figure><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动节点</span></span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6481/redis-6481.conf</span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6482/redis-6482.conf</span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6483/redis-6483.conf</span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6484/redis-6484.conf</span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6485/redis-6485.conf</span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6486/redis-6486.conf</span><br><span class="line"></span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6487/redis-6487.conf</span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6488/redis-6488.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建集群</span></span><br><span class="line"><span class="comment">#--replicas 1表示每个主节点配备几个从节点</span></span><br><span class="line">redis-trib.rb create --replicas 1 127.0.0.1:6481 127.0.0.1:6482 127.0.0.1:6483 127.0.0.1:6484 127.0.0.1:6485 127.0.0.1:6486</span><br><span class="line"></span><br><span class="line"><span class="comment">#检测集群完整性</span></span><br><span class="line"><span class="comment">#只要16384个槽中有一个没有分配给节点则表示集群不完整</span></span><br><span class="line"><span class="comment">#可以对集群中任意一个节点发起检测</span></span><br><span class="line">redis-trib.rb check 127.0.0.1:6481</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看集群所有节点</span></span><br><span class="line">cluster nodes</span><br><span class="line"></span><br><span class="line"><span class="comment">#集群扩容</span></span><br><span class="line"><span class="comment">#6487是新节点，6481是已存在节点</span></span><br><span class="line"><span class="comment">#如果新节点已存在数据，则会添加失败</span></span><br><span class="line"><span class="comment">#redis-trib.rb add-node &#123;new_ip:new_port&#125; &#123;existing_ip:existing_port&#125;</span></span><br><span class="line">redis-trib.rb add-node 127.0.0.1:6487 127.0.0.1:6481</span><br><span class="line"><span class="comment">#迁移槽和数据，127.0.0.1:6481为集群中任意一个节点</span></span><br><span class="line">redis-trib.rb reshard 127.0.0.1:6481</span><br><span class="line"></span><br><span class="line"><span class="comment">#集群缩容</span></span><br><span class="line"><span class="comment">#迁移槽</span></span><br><span class="line">redis-trib.rb reshard 127.0.0.1:6481</span><br><span class="line"><span class="comment">#忘记节点</span></span><br><span class="line">redis-trib.rb del-node 127.0.0.1:6487 d4aafc5465d0f85a55ccd648e045cedcb46478cd</span><br><span class="line"></span><br><span class="line"><span class="comment">#请求路由</span></span><br><span class="line"><span class="comment">#查看key对应的槽</span></span><br><span class="line">cluster keyslot &#123;key&#125;</span><br><span class="line"><span class="comment">#cli模式下加上-c可以重定向到正确节点</span></span><br><span class="line">redis-cli -p 6481 -c</span><br></pre></td></tr></table></figure><h2 id="新节点迁移槽和数据"><a href="#新节点迁移槽和数据" class="headerlink" title="新节点迁移槽和数据"></a>新节点迁移槽和数据</h2><h2 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">M: b079123bb42e1de36e9bc21d0473f8ceda6f7265 127.0.0.1:6481</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: bcbb401d25543cfc6384546ad24b46eb264b426e 127.0.0.1:6483</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 8f2f21cb11d1986da9137f099e938bdb4e0f230e 127.0.0.1:6484</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates fa0015a21a575b170f5e39f463cc62fdb3a6e667</span><br><span class="line">S: af886e91bf0f42e36627d16d35bc270c0b6fb35e 127.0.0.1:6486</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates b079123bb42e1de36e9bc21d0473f8ceda6f7265</span><br><span class="line">M: fa0015a21a575b170f5e39f463cc62fdb3a6e667 127.0.0.1:6482</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 41e8cc7350b94185fca11ce243183f414307b037 127.0.0.1:6485</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates bcbb401d25543cfc6384546ad24b46eb264b426e</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis-有哪些架构模式？讲讲各自的特点&quot;&gt;&lt;a href=&quot;#Redis-有哪些架构模式？讲讲各自的特点&quot; class=&quot;headerlink&quot; title=&quot;Redis 有哪些架构模式？讲讲各自的特点&quot;&gt;&lt;/a&gt;Redis 有哪些架构模式？讲讲各自的特点&lt;/</summary>
      
    
    
    
    <category term="redis" scheme="https://timmy6.github.io/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>redis持久化</title>
    <link href="https://timmy6.github.io/2020/03/03/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://timmy6.github.io/2020/03/03/redis%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2020-03-03T14:15:10.000Z</published>
    <updated>2022-05-17T06:33:50.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/bab8f4b26445">https://www.jianshu.com/p/bab8f4b26445</a></li><li><a href="https://www.cnblogs.com/lizhimin123/p/10192217.html">https://www.cnblogs.com/lizhimin123/p/10192217.html</a></li></ul><blockquote><p>相对于memcache,redis的是数据可以做持久化处理,主要有两种方式,快照rdb和追加文件aof,redis是持久化处理是比较耗时,一般在主从模式中,master不做持久化处理,由slave处理</p></blockquote><h2 id="什么是Redis持久化？"><a href="#什么是Redis持久化？" class="headerlink" title="什么是Redis持久化？"></a>什么是Redis持久化？</h2><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p><h2 id="快照rdb"><a href="#快照rdb" class="headerlink" title="快照rdb"></a>快照rdb</h2><ul><li>redis使用操作系统的多进程COW机制(Copy On Write)复制写机制来实现快照的持久化</li><li>由子进程进行持久操作，子进程刚刚产生时，和父进程共享内存里面的代码段和数据段</li><li>子进程会</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>持久化有两个命令，<code>save</code>和<code>bgsave</code>，<code>save</code>会阻塞服务进程，直到持久化完成，<code>bgsave</code>会fork子进程，由子进程去完成持久化，<code>bgsave</code>对应配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 满足以上三个条件中的任意一个，则自动触发 BGSAVE 操作 </span><br><span class="line">save 900 1       // 服务器在900秒之内，对数据库执行了至少1次修改 </span><br><span class="line">save 300 10      // 服务器在300秒之内，对数据库执行了至少10修改 </span><br><span class="line">save 60  1000    // 服务器在60秒之内，对数据库执行了至少1000修改</span><br></pre></td></tr></table></figure><h3 id="rdb文件结构"><a href="#rdb文件结构" class="headerlink" title="rdb文件结构"></a>rdb文件结构</h3><p><a href="https://www.cnblogs.com/lizhimin123/p/10192217.html">https://www.cnblogs.com/lizhimin123/p/10192217.html</a><br><img src="https://img2018.cnblogs.com/blog/1522047/201812/1522047-20181229102040895-1225006452.png" alt="https://img2018.cnblogs.com/blog/1522047/201812/1522047-20181229102040895-1225006452.png"></p><ul><li>REDIS：5字节，保存着 “REDIS” 五个字符</li><li>db_version：4字节，RDB文件的版本号</li><li>database 0：数据库中的键值对<ul><li>SELECTDB：1字节常量</li><li>db_number：数据库号码</li><li>key_value_pairs：键值对<ul><li>type: 记录类对象的编码类型，程序会根据 TYPE 属性来决定如何读入和解释value数据</li><li>key</li><li>value</li></ul></li></ul></li><li>EOF：RDB文件的结束标志</li><li>check_sum：校验和（CRC64），用来检查RDB文件是否出错</li></ul><h3 id="rdb问题"><a href="#rdb问题" class="headerlink" title="rdb问题"></a>rdb问题</h3><ul><li>持久化过程中数据发生改变？<br>rdb文件被成为快照文件，子进程所看到的数据在它被创建的一瞬间就固定下来了，父进程修改的某个数据只是该数据的复制品。（父子进程共享内存，数据发生写时会另外复制一份数据进行修改）<br><img src="https://upload-images.jianshu.io/upload_images/7789414-016d9f4ff4c14e33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1196/format/webp" alt="https://upload-images.jianshu.io/upload_images/7789414-016d9f4ff4c14e33.png?imageMogr2/auto-orient/strip|imageView2/2/w/1196/format/webp"></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul><li>性能好  <h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3></li><li>实时性差</li></ul><h2 id="追加日志aof"><a href="#追加日志aof" class="headerlink" title="追加日志aof"></a>追加日志aof</h2><p>redis将指令追加到日志，通过回放指令来恢复数据，随着时间的增大会有日志文件变大的问题，这就需要重写日志</p><h2 id="aof重写日志的过程是怎么样的？"><a href="#aof重写日志的过程是怎么样的？" class="headerlink" title="aof重写日志的过程是怎么样的？"></a>aof重写日志的过程是怎么样的？</h2><p><img src="https://upload-images.jianshu.io/upload_images/7789414-42813796f197b274.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/957/format/webp" alt="https://upload-images.jianshu.io/upload_images/7789414-42813796f197b274.png?imageMogr2/auto-orient/strip|imageView2/2/w/957/format/webp"></p><ul><li>fork子进程</li><li>子进程遍历内存数据写到新的aof文件</li><li>在生成新的aof文件的过程中，如果收到新指令，则继续保存在系统内存缓存中</li><li>完成新的aof文件之后，将系统内存缓存数据追加到新的aof文件</li><li>新的aof文件代替旧的aof文件</li></ul><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点:"></a>优点:</h3><ul><li>实时性小  <h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点:"></a>缺点:</h3></li><li>需要重写日志文件</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/bab8f4b26445&quot;&gt;https://www.jia</summary>
      
    
    
    
    <category term="redis" scheme="https://timmy6.github.io/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>redis常见问题</title>
    <link href="https://timmy6.github.io/2020/02/03/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://timmy6.github.io/2020/02/03/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-03T14:15:10.000Z</published>
    <updated>2022-05-17T06:30:07.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/jasontec/p/9699242.html">https://www.cnblogs.com/jasontec/p/9699242.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/79778696">https://zhuanlan.zhihu.com/p/79778696</a></li></ul><h2 id="使用过Redis分布式锁么，它是怎么实现的？"><a href="#使用过Redis分布式锁么，它是怎么实现的？" class="headerlink" title="使用过Redis分布式锁么，它是怎么实现的？"></a>使用过Redis分布式锁么，它是怎么实现的？</h2><p>redis的分布式锁主要使用<code>set</code>命令的<code>nx</code>选项抢占锁，以及<code>ex</code>设置过期时间，先nx获得锁并且设置过期时间，这两个过程是原子性的，中间不会被其他命令打断；<br>另外防止锁超时过期误删锁，一般使用<code>set</code>获得锁时会设置一个唯一值，释放锁的时候需要匹配一下两个值是否一致</p><h2 id="什么是一致性哈希算法？什么是哈希槽？"><a href="#什么是一致性哈希算法？什么是哈希槽？" class="headerlink" title="什么是一致性哈希算法？什么是哈希槽？"></a>什么是一致性哈希算法？什么是哈希槽？</h2><p><a href="https://www.jianshu.com/p/6ad87a1f070e">https://www.jianshu.com/p/6ad87a1f070e</a></p><p>redis 的 custer 提供了两个功能：</p><ul><li>自动对数据分片，落到各个节点上</li><li>即使集群部分节点失效或者连接不上，依然可以继续处理命令</li></ul><p>普通哈希算法是<code>hash(key)%number</code>对数量进行取余获得key所在节点位置，如果改变数量会导致原有节点上的数据发生变化；</p><p>在一致性哈希算法中，整个哈希空间是一个虚拟圆环。 对节点取哈希值，然后分配到哈希环上。对某个值进行搜索的时候按顺时针搜索找到key第一个存在的节点，即使发生节点数据变化，也只是影响一小部分区间的数据；</p><p>一致性哈希算法对于容错性和扩展性有非常好的支持。但一致性哈希算法也有一个严重的问题，就是数据倾斜。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>对每个真实节点增加多个虚拟节点，然后维护一个虚拟节点和真实节点的映射关系表；（即环上都是）<a href="https://geektutu.com/post/geecache-day4.html">https://geektutu.com/post/geecache-day4.html</a></li><li>rredis 集群（cluster）并没有选用上面一致性哈希，而是采用了哈希槽（slot）的这种概念。每个redis节点会维护一部分槽以及槽上的数据，总的槽大概一万六千多，槽可以均匀分布在多个节点</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> --net=host --name redis-manager  \</span><br><span class="line">-e DATASOURCE_DATABASE=<span class="string">&#x27;redis_manager&#x27;</span> \</span><br><span class="line">-e DATASOURCE_URL=<span class="string">&#x27;jdbc:mysql://127.0.0.1:3306/redis_manager?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2b8&#x27;</span> \</span><br><span class="line">-e DATASOURCE_USERNAME=<span class="string">&#x27;root&#x27;</span> \</span><br><span class="line">-e DATASOURCE_PASSWORD=<span class="string">&#x27;123456&#x27;</span> \</span><br><span class="line">reasonduan/redis-manager</span><br></pre></td></tr></table></figure><p><a href="https://www.fengpt.cn/archives/redis%E9%9B%86%E7%BE%A4%E5%9C%A8%E6%9F%A5%E6%89%BEkey%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%AF%E7%94%B1%E7%9A%84">https://www.fengpt.cn/archives/redis%E9%9B%86%E7%BE%A4%E5%9C%A8%E6%9F%A5%E6%89%BEkey%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%AF%E7%94%B1%E7%9A%84</a></p><h2 id="redis集群哈希槽"><a href="#redis集群哈希槽" class="headerlink" title="redis集群哈希槽"></a>redis集群哈希槽</h2><p>redis cluster 包含了16384个哈希槽，每个 key 通过计算后都会落在具体一个槽位上，而这个槽位是属于哪个存储节点的，则由用户自己定义分配。例如机器硬盘小的，可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。所以哈希槽这种概念很好地解决了一致性哈希的弊端。</p><p>在容错性和扩展性上，redis对槽位的转移，把故障节点负责的槽位转移到其他正常的节点上。 </p><p>但一定要注意的是，对于槽位的转移和分派，redis 集群是不会自动进行的，而是需要人工配置的。所以 redis 集群的高可用是依赖于节点的主从复制与主从间的自动故障转移。</p><h2 id="使用过Redis做异步队列么，你是怎么用的？有什么缺点？"><a href="#使用过Redis做异步队列么，你是怎么用的？有什么缺点？" class="headerlink" title="使用过Redis做异步队列么，你是怎么用的？有什么缺点？"></a>使用过Redis做异步队列么，你是怎么用的？有什么缺点？</h2><p>可以是使用<code>blpop</code>和<code>rpush</code>，<code>blpop</code>会移除列表头部元素，如果列表没有元素会阻塞直到等待超时或发现元素为止，<code>rpush</code>从尾部写入数据；缺点如下：</p><ul><li>消息容易丢失</li><li>消息分发策略没有专业的mq丰富，例如kafka的分区，rabbitmq的路由键等等</li></ul><h2 id="什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？"><a href="#什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？" class="headerlink" title="什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？"></a>什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>一般缓存系统会先查缓存，值不存在的时候再查数据库；一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。如何避免？</p><ul><li>对查询结果为空的情况也进行缓存，缓存时间设置短一点</li><li>对一定不存在的key进行过滤，可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤（布尔过滤器）<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。如何避免？</li><li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量</li><li>不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</li></ul><h2 id="Redis的字典是如何实现的？简述渐进式rehash的过程？"><a href="#Redis的字典是如何实现的？简述渐进式rehash的过程？" class="headerlink" title="Redis的字典是如何实现的？简述渐进式rehash的过程？"></a>Redis的字典是如何实现的？简述渐进式rehash的过程？</h2><p><a href="https://www.jianshu.com/p/e2697fecac0d">https://www.jianshu.com/p/e2697fecac0d</a><br><a href="https://www.cnblogs.com/neooelric/p/9621736.html">https://www.cnblogs.com/neooelric/p/9621736.html</a></p><h2 id="Redis事务是怎么样的？"><a href="#Redis事务是怎么样的？" class="headerlink" title="Redis事务是怎么样的？"></a>Redis事务是怎么样的？</h2><p>redis的事务是通过mutil实现的，mutil开始一个事务，然后将多个命令入队到事务中，最后执行exec命令触发事务。redis的事务有一些不足：</p><ul><li>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做</li><li>同的key是有可能分配在不同的Redis节点上的，在这种情况下Redis的事务机制是不生效的</li></ul><h2 id="集群可以使用lua脚本吗？"><a href="#集群可以使用lua脚本吗？" class="headerlink" title="集群可以使用lua脚本吗？"></a>集群可以使用lua脚本吗？</h2><p>不可以，除非key在同一个redis节点上，可以使用<code>&#123;hash_tag&#125;</code>来是不同的key落到同一个节点上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; CLUSTER KEYSLOT somekey</span><br><span class="line">11058</span><br><span class="line">&gt; CLUSTER KEYSLOT foo&#123;hash_tag&#125;</span><br><span class="line">(<span class="built_in">integer</span>) 2515</span><br><span class="line">&gt; CLUSTER KEYSLOT bar&#123;hash_tag&#125;</span><br><span class="line">(<span class="built_in">integer</span>) 2515</span><br></pre></td></tr></table></figure><p>keySlot算法中，如果key包含{}，就会使用第一个{}内部的字符串作为hash key，这样就可以保证拥有同样{}内部字符串的key就会拥有相同slot</p><h2 id="Redis的多数据库机制，了解多少？"><a href="#Redis的多数据库机制，了解多少？" class="headerlink" title="Redis的多数据库机制，了解多少？"></a>Redis的多数据库机制，了解多少？</h2><p>单机版有16个数据库，每个数据库的数据相互隔离，集群版只有一个数据库</p><h2 id="谈谈你对分布式和集群，微服务的理解？两则之间有什么关系？"><a href="#谈谈你对分布式和集群，微服务的理解？两则之间有什么关系？" class="headerlink" title="谈谈你对分布式和集群，微服务的理解？两则之间有什么关系？"></a>谈谈你对分布式和集群，微服务的理解？两则之间有什么关系？</h2><ul><li>分布式是将一个业务拆分多个子业务，多个子业务可以部署不同机器上面，子业务之间通过rpc或消息中间件或其他方式进行通信，如果有一个子业务不可用，那么整个业务就不可用</li><li>微服务是将一个业务拆分多个子业务，多个子业务可以部署在不同机器或统一机器上面（和分布式的区别）。</li><li>集群是同一个业务部署到多个机器上面，比如用nginx做负载均衡。</li><li>分布式下每个子业务都可以做集群，分布式和微服务类似，只是部署方式不一样</li></ul><h2 id="redis集群有什么限制"><a href="#redis集群有什么限制" class="headerlink" title="redis集群有什么限制"></a>redis集群有什么限制</h2><ul><li>不能批量处理key</li><li>不支持事务，多数据库</li><li>一些大的键值对象不能映射到不同的节点上</li></ul><h2 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h2><ul><li>使用keys 指定模式可以获得key列表</li><li>因为redis是单线程模式，使用keys命令会导致线程阻塞一段时间，线上服务会停顿，直到命令执行完毕才能恢复</li><li>可以用scan命令，无阻塞的，但是会有一定的重复概率</li></ul><h2 id="bgsave的原理是什么？"><a href="#bgsave的原理是什么？" class="headerlink" title="bgsave的原理是什么？"></a>bgsave的原理是什么？</h2><p>fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p><h2 id="Pipeline有什么好处，为什么要用pipeline？"><a href="#Pipeline有什么好处，为什么要用pipeline？" class="headerlink" title="Pipeline有什么好处，为什么要用pipeline？"></a>Pipeline有什么好处，为什么要用pipeline？</h2><p>可以将多次IO往返的时间缩减为一次</p><h2 id="Redis的同步机制了解么？"><a href="#Redis的同步机制了解么？" class="headerlink" title="Redis的同步机制了解么？"></a>Redis的同步机制了解么？</h2><ul><li>第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。</li><li>加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</li></ul><h2 id="是否使用过Redis集群，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的原理是什么？"></a>是否使用过Redis集群，集群的原理是什么？</h2><p>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。<br>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/jasontec/p/9699242.html&quot;&gt;https:</summary>
      
    
    
    
    <category term="redis" scheme="https://timmy6.github.io/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>Redis的常用淘汰策略以及算法</title>
    <link href="https://timmy6.github.io/2020/01/05/Redis%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95/"/>
    <id>https://timmy6.github.io/2020/01/05/Redis%E7%9A%84%E5%B8%B8%E7%94%A8%E6%B7%98%E6%B1%B0%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95/</id>
    <published>2020-01-05T14:15:10.000Z</published>
    <updated>2022-05-17T06:24:53.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis配置内存为多少合适？"><a href="#Redis配置内存为多少合适？" class="headerlink" title="Redis配置内存为多少合适？"></a>Redis配置内存为多少合适？</h2><p><strong>默认</strong>：如果<strong>不设置最大内存</strong>大小或者<strong>设置最大内存大小为0</strong>，在<strong>64为操作系统下不限制内存大小</strong>，在<strong>32位操作</strong>系统下<strong>最多使用3GB</strong>内存。</p><p>一般推荐Redis设置<strong>内存为最大物理内存的75%都是安全</strong>的 </p><h2 id="如何修改内存"><a href="#如何修改内存" class="headerlink" title="如何修改内存"></a>如何修改内存</h2><p><strong>redis.conf中</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">maxmemory  <span class="number">104857600</span></span><br><span class="line">config set maxmemory <span class="number">104857600</span></span><br></pre></td></tr></table></figure><h2 id="Redis的内存淘汰策略"><a href="#Redis的内存淘汰策略" class="headerlink" title="Redis的内存淘汰策略"></a>Redis的内存淘汰策略</h2><h3 id="过期策略"><a href="#过期策略" class="headerlink" title="过期策略"></a>过期策略</h3><ul><li>定期删除</li><li>惰性删除</li></ul><h3 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h3><ul><li>lru - 最近最少使用的 key，也就是首先淘汰最长时间未被使用的缓存，强调的是时间</li><li>random - 随机删除</li><li>lfu - 最近最不经常使用，,也就是淘汰一定时期内被访问次数最少的缓存，强调的是频率</li></ul><h3 id="LRU算法原理"><a href="#LRU算法原理" class="headerlink" title="LRU算法原理"></a>LRU算法原理</h3><p>其原理是维护一个双向链表，key -&gt; node，其中node保存链表前后节点关系及数据data。新插入的key时，放在头部，并检查是否超出总容量，如果超出则删除最后的key；访问key时，无论是查找还是更新，将该Key被调整到头部。</p><p><img src="/images/other/20191119154442706.png" alt="在这里插入图片描述"></p><p>Redis并没有使用严格的LRU算法，因为维护一个那么大的双向链表需要的内存空间较大。redis通过随机采样法淘汰数据，每次随机出5（默认）个key，从里面淘汰掉最近最少使用的key。</p><p>显然LRU的缺陷是明显的，最新访问的数据被当做热数据显然是不合理的，热数据顾名思义就是被访问频次叫高的数据，显然是不同的概念</p><h3 id="LFU算法原理"><a href="#LFU算法原理" class="headerlink" title="LFU算法原理"></a>LFU算法原理</h3><p>假如你使用的是LRU算法，一个key很久没有被访问到，只刚刚是偶尔被访问了一次，那么它就被认为是热点数据，不会被淘汰，而有些key将来是很有可能被访问到的则被淘汰了。如果使用LFU算法则不会出现这种情况，因为使用一次并不会使一个key成为热点数据。LFU原理使用计数器来对key进行排序，每次key被访问的时候，计数器增大。计数器越大，可以约等于访问越频繁。具有相同引用计数的数据块则按照时间排序。</p><p><img src="/images/other/20191119182623142-1615863469510.png" alt="å¨è¿éæå¥å¾çæè¿°"></p><p>LFC算法存在两个问题：</p><ul><li>在LRU算法中可以维护一个双向链表，然后简单的把被访问的节点移至链表开头，但在LFU中是不可行的，节点要严格按照计数器进行排序，新增节点或者更新节点位置时，时间复杂度可能达到O(N)。</li><li>只是简单的增加计数器的方法并不完美。访问模式是会频繁变化的，一段时间内频繁访问的key一段时间之后可能会很少被访问到，只增加计数器并不能体现这种趋势</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/raoxiaoya/article/details/103141022">https://blog.csdn.net/raoxiaoya/article/details/103141022</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis配置内存为多少合适？&quot;&gt;&lt;a href=&quot;#Redis配置内存为多少合适？&quot; class=&quot;headerlink&quot; title=&quot;Redis配置内存为多少合适？&quot;&gt;&lt;/a&gt;Redis配置内存为多少合适？&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;默认&lt;/strong</summary>
      
    
    
    
    <category term="redis" scheme="https://timmy6.github.io/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>mysql索引知识</title>
    <link href="https://timmy6.github.io/2019/12/15/mysql%E7%B4%A2%E5%BC%95%E7%9F%A5%E8%AF%86/"/>
    <id>https://timmy6.github.io/2019/12/15/mysql%E7%B4%A2%E5%BC%95%E7%9F%A5%E8%AF%86/</id>
    <published>2019-12-15T14:15:10.000Z</published>
    <updated>2022-05-17T06:16:11.976Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.toutiao.com/i6732776474308248072/">https://www.toutiao.com/i6732776474308248072/</a></li><li><a href="https://www.cnblogs.com/jie-y/p/11153480.html">https://www.cnblogs.com/jie-y/p/11153480.html</a></li><li><a href="https://www.cnblogs.com/kkbill/p/11381783.html">https://www.cnblogs.com/kkbill/p/11381783.html</a></li></ul><h2 id="为什么要用索引？"><a href="#为什么要用索引？" class="headerlink" title="为什么要用索引？"></a>为什么要用索引？</h2><p>索引用于加速查询速度</p><h2 id="索引的缺点"><a href="#索引的缺点" class="headerlink" title="索引的缺点"></a>索引的缺点</h2><ul><li>需要维护索引文件,占物理空间</li><li>影响增删改性能</li></ul><h2 id="数据存储文件"><a href="#数据存储文件" class="headerlink" title="数据存储文件"></a>数据存储文件</h2><h3 id="对于MyISAM存储引擎来说"><a href="#对于MyISAM存储引擎来说" class="headerlink" title="对于MyISAM存储引擎来说"></a>对于MyISAM存储引擎来说</h3><ul><li><code>.frm</code>后缀的文件存储的是表结构。</li><li><code>.myd</code>后缀的文件存储的是表数据。</li><li><code>.myi</code>后缀的文件存储的就是索引文件。<h3 id="对于InnoDB-存储引擎来说"><a href="#对于InnoDB-存储引擎来说" class="headerlink" title="对于InnoDB 存储引擎来说:"></a>对于InnoDB 存储引擎来说:</h3></li><li><code>.frm</code>后缀的文件存储的是表结构。</li><li><code>.ibd</code>后缀的文件存放索引文件和数据(需要开启innodb_file_per_table 参数)</li></ul><h2 id="myisam和innodb从索引方面上来说有什么区别？"><a href="#myisam和innodb从索引方面上来说有什么区别？" class="headerlink" title="myisam和innodb从索引方面上来说有什么区别？"></a>myisam和innodb从索引方面上来说有什么区别？</h2><p><a href="https://www.cnblogs.com/jie-y/p/11153480.html">https://www.cnblogs.com/jie-y/p/11153480.html</a></p><ul><li>myisam主索引和数据是分开的，innodb数据文件本身就是主索引文件</li><li>myisam的主索引文件和辅助索引文件结构一样，叶子节点保存行数据的物理地址</li><li>innodb的主索引文件是按主键构造的<code>b+</code>树（也叫聚簇索引），叶子节点保存行数据；辅助索引的叶子节点保存主键值</li></ul><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p><code>聚簇索引</code>并不是一种索引类型，也是一种数据存储方式，它按照主键的顺序构建<code>b+树</code>，行数据存放在叶子节点上</p><h3 id="聚簇索引的缺点"><a href="#聚簇索引的缺点" class="headerlink" title="聚簇索引的缺点"></a>聚簇索引的缺点</h3><ul><li>页分裂会导致表占用更多的磁盘空间；假如磁盘中的某一个已经存满了，但是新增的行要插入到这一页当中，存储引擎就会把该也分裂成两个页面来容纳该行，这就是一次页分裂操作。页分裂会导致表占用更多的磁盘空间</li></ul><h2 id="什么是二级索引？"><a href="#什么是二级索引？" class="headerlink" title="什么是二级索引？"></a>什么是二级索引？</h2><p>对于非主键列其他列建立的索引就是二级索引</p><h2 id="聚簇索引和二级索引有什么区别？"><a href="#聚簇索引和二级索引有什么区别？" class="headerlink" title="聚簇索引和二级索引有什么区别？"></a>聚簇索引和二级索引有什么区别？</h2><ul><li>聚簇索引的叶子节点存放行数据，二级索引的叶子节点存放索引列的值和主键</li><li>二级索引需要回表查询，也就是二次查询，而聚簇索引不需要<br><img src="http://p1-tt.byteimg.com/large/pgc-image/818ae93727da4ced81edc2ba548541bb?from=pc" alt="http://p1-tt.byteimg.com/large/pgc-image/818ae93727da4ced81edc2ba548541bb?from=pc"></li></ul><h2 id="为什么选择B-树作为数据库索引结构？"><a href="#为什么选择B-树作为数据库索引结构？" class="headerlink" title="为什么选择B+树作为数据库索引结构？"></a>为什么选择B+树作为数据库索引结构？</h2><p><a href="https://www.cnblogs.com/kkbill/p/11381783.html">https://www.cnblogs.com/kkbill/p/11381783.html</a><br>首先需要理解的是<code>b树</code>和<code>b+树</code>的区别；</p><h3 id="b树"><a href="#b树" class="headerlink" title="b树"></a>b树</h3><p>b树就是平衡的多路搜索树，b树通常意味着所有的值都是按顺序存储的，并且每一个叶子也到根的距离相同，所谓的m阶B树，即m路平衡搜索树；一颗m阶b树满足以下条件：</p><ul><li>每个结点至多含有m个分支节点（m&gt;&#x3D;2）。</li><li>除根结点之外的每个非叶结点，至少含有m&#x2F;2个分支。</li><li>若根结点不是叶子结点，则至少有2个孩子。</li><li>一个含有k个孩子的非叶结点包含k-1个关键字。 （每个结点内的关键字按升序排列）<br>所有的叶子结点都出现在同一层。实际上这些结点并不存在，可以看作是外部结点。</li><li>所有的叶子结点都出现在同一层。<h3 id="b-树相对于b树的区别"><a href="#b-树相对于b树的区别" class="headerlink" title="b+树相对于b树的区别"></a>b+树相对于b树的区别</h3></li><li>叶子结点包含全部关键字以及行记录数据（或指针）</li><li>叶子结点连接在一起，组成一个链表，利于范围搜索</li><li>非叶子结点不存放真正的数据，只存放关键字，利于同样大小的磁盘页可以容纳更多的关键字（节点元素），相对应的树的高度就越小，发生io的次数就越少</li></ul><h2 id="索引优化-原则"><a href="#索引优化-原则" class="headerlink" title="索引优化(原则)"></a>索引优化(原则)</h2><ul><li>应该选择基数大的字段作为索引</li><li>数据类型要和索引字段类型一致,如果varchar字段,用数字查询不能使用索引</li><li>多列索引需要遵循左侧前缀匹配原则,多列索引组成一个索引,比较的时候是从左到右匹配 </li><li>不在索引列做计算</li><li>字符串做索引需要避免索引长度过长问题（mysql的索引底层是一个b+树，每个节点对应一个磁盘页，能够容纳的大小是有限，如果索引越小，就能容纳更多key，树的高度就越低，发出io次数就越少，性能就越高）</li></ul><h2 id="常用索引命令"><a href="#常用索引命令" class="headerlink" title="常用索引命令"></a>常用索引命令</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 查看表所有索引</span><br><span class="line"><span class="keyword">show</span> index <span class="keyword">from</span> users;</span><br><span class="line"># 创建索引,如果是<span class="type">CHAR</span>，<span class="type">VARCHAR</span>类型，length可以小于字段实际长度；如果是<span class="type">BLOB</span>和TEXT类型，必须指定 length</span><br><span class="line"><span class="keyword">create</span> index index<span class="operator">-</span>name <span class="keyword">on</span> users(name(<span class="number">10</span>));</span><br><span class="line"># 创建唯一索引</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> index index<span class="operator">-</span>name <span class="keyword">on</span> users(name(<span class="number">10</span>))</span><br><span class="line"># 创建索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> users <span class="keyword">add</span> index index<span class="operator">-</span>name(name(<span class="number">10</span>));</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> users <span class="keyword">add</span> <span class="keyword">primary</span> key(id);</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> users <span class="keyword">add</span> <span class="keyword">unique</span> index<span class="operator">-</span>name(name(<span class="number">10</span>));</span><br><span class="line"># 删除索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> users <span class="keyword">drop</span> index index<span class="operator">-</span>name;</span><br><span class="line"><span class="keyword">drop</span> index index<span class="operator">-</span>name <span class="keyword">on</span> users;</span><br></pre></td></tr></table></figure><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><a href="https://blog.csdn.net/qq_35495339/article/details/89304012">https://blog.csdn.net/qq_35495339/article/details/89304012</a></p><ul><li><code>in</code>,<code>or</code>可以命中索引,<code>in</code>比<code>union all</code>消耗更多cpu,但是一般推荐用<code>in</code></li><li>负向条件不可以应用索引,包括<code>!=</code>、<code>&lt;&gt;</code>、<code>not in</code>、<code>not exists</code>、<code>not like</code>,可以优化为<code>in</code>查询 </li><li>最左侧查询需求，并不是指 SQL 语句的 where 顺序要和联合索引一致</li><li>范围查询可以使用索引,但是范围列后面的列无法用到索引,例如联合索引 (empno、title、fromdate,其中sql语句为<code>select * fromemployees.titles where emp_no &lt; 10010&#39; and title=&#39;Senior Engineer&#39;and from_date between &#39;1986-01-01&#39; and &#39;1986-12-31&#39;</code>,那么只有 emp_no 可以用到索引，而 title 和 from_date 则使用不到索引</li><li></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.toutiao.com/i6732776474308248072/&quot;&gt;https://</summary>
      
    
    
    
    <category term="MySql" scheme="https://timmy6.github.io/categories/MySql/"/>
    
    
    <category term="数据库优化" scheme="https://timmy6.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>mysql主从复制和读写分离</title>
    <link href="https://timmy6.github.io/2019/11/25/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%92%8C%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/"/>
    <id>https://timmy6.github.io/2019/11/25/mysql%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E5%92%8C%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB/</id>
    <published>2019-11-25T14:15:10.000Z</published>
    <updated>2022-05-17T06:10:33.751Z</updated>
    
    <content type="html"><![CDATA[<p>一致性是指多副本中的数据一致性问题,可以分为强一致性,顺序一致性,弱一致性</p><h2 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h2><p>在任意时刻，所有节点中的数据是一样的,例如，例如主从数据库,主库更新一个数据后,可以从从库读取到</p><p>可以指定复制所有库,指定库,或者指定表</p><h2 id="主从复制的优点"><a href="#主从复制的优点" class="headerlink" title="主从复制的优点"></a>主从复制的优点</h2><ul><li>主库负责写,从库负责读,可以分配负载以提高性能</li><li>数据备份,从库可以作为备份数据库</li></ul><h2 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h2><p><img src="/images/other/mysql.webp" alt="https://upload-images.jianshu.io/upload_images/11414906-1e1d8aaa7a86af96.png?imageMogr2/auto-orient/strip|imageView2/2/w/799/format/webp"></p><ul><li>主库开启二进制日志</li><li>主库将sql语句通过<code>io线程</code>保存在二进制日志<code>binary log</code></li><li>从库启动<code>io线程</code>,读取主库的<code>binary log</code>到自己的中继日志<code>realy log</code></li><li>从库开启<code>sql线程</code>,定时检查<code>realy log</code>,然后执行<code>realy log</code>语句</li><li>从库会记录主库二级制日志的坐标,所以从库可以暂停恢复继续处理</li></ul><h2 id="docker启动mysql容器"><a href="#docker启动mysql容器" class="headerlink" title="docker启动mysql容器"></a>docker启动mysql容器</h2><p><a href="https://www.cnblogs.com/sablier/p/11605606.html">https://www.cnblogs.com/sablier/p/11605606.html</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 镜像为mysql:5.7</span></span><br><span class="line">docker run -p 13306:3306 --name mysql_1 --network mysql-network -e MYSQL_ROOT_PASSWORD=123456 -d mysql:v57</span><br><span class="line"><span class="comment"># 进入容器 </span></span><br><span class="line">docker <span class="built_in">exec</span> -it mysql_1 /bin/bash</span><br><span class="line"><span class="comment"># 允许root远程登录mysql</span></span><br><span class="line">grant all privileges on *.* to root@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&quot;password&quot;</span>;</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure><h2 id="主库配置"><a href="#主库配置" class="headerlink" title="主库配置"></a>主库配置</h2><p>创建用户 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建用于复制数据的用户,并只赋予replication权限</span></span><br><span class="line">create user <span class="string">&#x27;repl&#x27;</span>@<span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">grant replication slave on *.* to repl@<span class="string">&#x27;%&#x27;</span> identified by <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="comment"># 导出主库已经存在的数据</span></span><br><span class="line">mysqldump  -u用户名  -p密码  --all-databases  --master-data=1 &gt; dbdump.db</span><br></pre></td></tr></table></figure><p>配置<code>my.cnf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># docker默认路径`/etc/mysql/my.cnf`</span></span><br><span class="line">vi /etc/mysql/my.cnf</span><br><span class="line"></span><br><span class="line">[mysqld]</span><br><span class="line">log-bin=mysql-bin</span><br><span class="line">server-id=1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">/etc/init.d/mysqld restart</span><br></pre></td></tr></table></figure><ul><li>server-id 为0时,表示主库拒绝任何来自从库的连接</li><li>主从库server-id不能冲突，主要Master要依靠server_id来决定是否执行event。从库会把主库的event发送回主库???</li><li>多个从库的server-id不能冲突，server-id用来表示从库连接</li></ul><h2 id="从库配置"><a href="#从库配置" class="headerlink" title="从库配置"></a>从库配置</h2><p>配置<code>my.cnf</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[mysqld]</span><br><span class="line">server-id=2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启</span></span><br><span class="line">/etc/init.d/mysqld restart</span><br><span class="line"><span class="comment"># 设置主库信息</span></span><br><span class="line">change master to master_host=<span class="string">&#x27;mysql_1&#x27;</span>,master_user=<span class="string">&#x27;repl&#x27;</span>,master_password=<span class="string">&#x27;123456&#x27;</span>;</span><br><span class="line"><span class="comment"># 启动</span></span><br><span class="line">start slave;</span><br><span class="line"><span class="comment"># 查看是否成功</span></span><br><span class="line">show slave status\G</span><br></pre></td></tr></table></figure><h2 id="测试sql"><a href="#测试sql" class="headerlink" title="测试sql"></a>测试sql</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 创建users表</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> users( id <span class="type">int</span>(<span class="number">11</span>) auto_increment, name <span class="type">varchar</span>(<span class="number">100</span>) <span class="keyword">not</span> <span class="keyword">null</span>, age <span class="type">int</span>(<span class="number">1</span>) <span class="keyword">default</span> <span class="number">0</span>, <span class="keyword">primary</span> key(id) )engine<span class="operator">=</span>InnoDB <span class="keyword">default</span> charset<span class="operator">=</span>utf8;</span><br><span class="line"># 插入一条数据</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> users(name,age) <span class="keyword">values</span>(<span class="string">&#x27;wuzhc&#x27;</span>,<span class="number">20</span>),(<span class="string">&#x27;mayun&#x27;</span>,<span class="number">65</span>);</span><br></pre></td></tr></table></figure><h2 id="复制过程"><a href="#复制过程" class="headerlink" title="复制过程"></a>复制过程</h2><p>当master上写操作繁忙时，当前POS点例如是10，而slave上IO_THREAD线程接收过来的是3，此时master宕机，会造成相差7个点未传送到slave上而数据丢失</p><ul><li>异步复制</li><li>半同步复制</li></ul><h2 id="常见的错误"><a href="#常见的错误" class="headerlink" title="常见的错误"></a>常见的错误</h2><p><code>sql_slave_skip_counter</code>表示跳过复制错误</p><ul><li>master上删除一条记录，而slave上找不到 <ul><li><code>set global sql_slave_skip_counter=1;</code></li></ul></li><li>主键重复。在slave已经有该记录，又在master上插入了同一条记录<ul><li>删除从库重复的记录</li></ul></li><li>在master上更新一条记录，而slave上找不到，丢失了数据<ul><li>从库补充数据,跳过<code>set global sql_slave_skip_counter=1;</code></li></ul></li></ul><h2 id="恢复relay-log日志"><a href="#恢复relay-log日志" class="headerlink" title="恢复relay-log日志"></a>恢复relay-log日志</h2><p>从库有两个线程,一个是<code>Slave_IO_Running</code>,一个是<code>Slave_SQL_Running</code></p><h3 id="Slave-IO-Running-：接收master的binlog信息"><a href="#Slave-IO-Running-：接收master的binlog信息" class="headerlink" title="Slave_IO_Running ：接收master的binlog信息"></a>Slave_IO_Running ：接收master的binlog信息</h3><ul><li>Master_Log_File</li><li>Read_Master_Log_Pos<h3 id="Slave-SQL-Running：执行写操作"><a href="#Slave-SQL-Running：执行写操作" class="headerlink" title="Slave_SQL_Running：执行写操作"></a>Slave_SQL_Running：执行写操作</h3></li><li>Relay_Master_Log_File</li><li>Exec_Master_Log_Pos<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stop slave;</span><br><span class="line"><span class="comment"># MASTER_LOG_FILE对应Relay_Master_Log_File,MASTER_LOG_POS对应Exec_Master_Log_Pos</span></span><br><span class="line">CHANGE MASTER TO MASTER_LOG_FILE=<span class="string">&#x27;mysql-bin.000001&#x27;</span>,MASTER_LOG_POS=1609;</span><br><span class="line">start slave;</span><br><span class="line">show slave status\G;</span><br></pre></td></tr></table></figure></li></ul><h2 id="mysql自定义dock镜像"><a href="#mysql自定义dock镜像" class="headerlink" title="mysql自定义dock镜像"></a>mysql自定义dock镜像</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">FROM mysql:5.7</span><br><span class="line">RUN sed -i <span class="string">&quot;s@http://deb.debian.org@http://mirrors.aliyun.com@g&quot;</span> /etc/apt/sources.list \</span><br><span class="line">&amp;&amp; sed -i <span class="string">&quot;s@http://security.debian.org@http://mirrors.aliyun.com@g&quot;</span> /etc/apt/sources.list \</span><br><span class="line">&amp;&amp; <span class="built_in">rm</span> -Rf /var/lib/apt/lists/* \</span><br><span class="line">&amp;&amp; apt-get update \</span><br><span class="line">&amp;&amp; apt-get install vim -y \</span><br><span class="line">&amp;&amp; apt-get install iputils-ping -y \</span><br><span class="line">&amp;&amp; apt-get install net-tools -y \</span><br><span class="line">&amp;&amp; apt-get install ssh -y </span><br></pre></td></tr></table></figure><h2 id="主从复制需要考虑哪些问题？"><a href="#主从复制需要考虑哪些问题？" class="headerlink" title="主从复制需要考虑哪些问题？"></a>主从复制需要考虑哪些问题？</h2><h3 id="主从复制延迟"><a href="#主从复制延迟" class="headerlink" title="主从复制延迟"></a>主从复制延迟</h3><ul><li>升级从库配置</li><li>升级mysql到5.6之后，采用并行复制</li><li>分库</li><li>写一份数据到redis，读从库没有数据时从redis读</li><li>更改读库的方式</li><li>使用事务<h3 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h3>同一个事务的sql发到同个从库</li></ul><h2 id="主从复制有哪些方式？"><a href="#主从复制有哪些方式？" class="headerlink" title="主从复制有哪些方式？"></a>主从复制有哪些方式？</h2><ul><li>半同步复制；防止主库挂掉后数据丢失（半同步复制确保事务提交后binlog至少传输到一个从库，只是传输到从库，不保证从库应用完这个事务的binlog ）</li><li>并行复制；主要解决主从复制延迟问题</li></ul><h2 id="如何查看主从延迟的时间？"><a href="#如何查看主从延迟的时间？" class="headerlink" title="如何查看主从延迟的时间？"></a>如何查看主从延迟的时间？</h2><p>通过在从库执行命令<code>show status</code>，其中<code>Seconds_Behind_Master</code>可以反映延迟时间</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一致性是指多副本中的数据一致性问题,可以分为强一致性,顺序一致性,弱一致性&lt;/p&gt;
&lt;h2 id=&quot;强一致性&quot;&gt;&lt;a href=&quot;#强一致性&quot; class=&quot;headerlink&quot; title=&quot;强一致性&quot;&gt;&lt;/a&gt;强一致性&lt;/h2&gt;&lt;p&gt;在任意时刻，所有节点中的数据是一样</summary>
      
    
    
    
    <category term="MySql" scheme="https://timmy6.github.io/categories/MySql/"/>
    
    
    <category term="数据库优化" scheme="https://timmy6.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>一些常用的命令</title>
    <link href="https://timmy6.github.io/2019/11/16/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/"/>
    <id>https://timmy6.github.io/2019/11/16/%E4%B8%80%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4/</id>
    <published>2019-11-16T14:15:10.000Z</published>
    <updated>2022-05-17T05:44:51.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="一些常用的命令"><a href="#一些常用的命令" class="headerlink" title="一些常用的命令"></a>一些常用的命令</h1><h3 id="查看端口占用情况"><a href="#查看端口占用情况" class="headerlink" title="查看端口占用情况"></a>查看端口占用情况</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp:8989</span><br></pre></td></tr></table></figure><p>eg: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp:80</span><br><span class="line"></span><br><span class="line">COMMAND    PID        USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME</span><br><span class="line">Google     328 mengyueping  181u  IPv4 0x393cc3d704a30853      0t0  TCP bogon:65200-&gt;202.108.249.246:http (ESTABLISHED)</span><br></pre></td></tr></table></figure><h3 id="杀死正在运行的服务"><a href="#杀死正在运行的服务" class="headerlink" title="杀死正在运行的服务"></a>杀死正在运行的服务</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kill -9 应用的pid</span><br><span class="line">kill -9 $(pgrep 应用名字)</span><br></pre></td></tr></table></figure><h3 id="查看某个应用进程的-pid"><a href="#查看某个应用进程的-pid" class="headerlink" title="查看某个应用进程的 pid"></a>查看某个应用进程的 <code>pid</code></h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">echo $(pgrep bee)</span><br><span class="line"># $(pgrep 进程的名字)</span><br><span class="line"></span><br><span class="line">ps -ef | grep 应用名（支持通配符）</span><br></pre></td></tr></table></figure><p>eg: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_3_centos ~]# ps -ef | grep bee</span><br><span class="line">root     16864 16828  0 15:47 pts/0    00:00:00 grep --color=auto bee</span><br><span class="line">root     18955     1  0 6月08 ?       00:00:44 bee run</span><br></pre></td></tr></table></figure><h3 id="查看内存"><a href="#查看内存" class="headerlink" title="查看内存"></a>查看内存</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">free</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:        3881904      861012      469244         480     2551648     2712060</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 单位为 megabytes</span><br><span class="line">free -m</span><br></pre></td></tr></table></figure><blockquote><p><code>total</code> : 总计物理内存大小</p></blockquote><blockquote><p><code>used</code> : 已使用多大</p></blockquote><blockquote><p><code>free</code> : 可用有多少</p></blockquote><blockquote><p><code>shared</code> : 多个进程共享的内存总额</p></blockquote><blockquote><p><code>buff/cache</code> :磁盘缓存的大小</p></blockquote><h3 id="查看磁盘空间"><a href="#查看磁盘空间" class="headerlink" title="查看磁盘空间"></a>查看磁盘空间</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">df</span> -h</span><br><span class="line">文件系统        容量  已用  可用 已用% 挂载点</span><br><span class="line">/dev/vda1        50G  6.6G   41G   15% /</span><br><span class="line">devtmpfs        1.9G     0  1.9G    0% /dev</span><br><span class="line">tmpfs           1.9G   24K  1.9G    1% /dev/shm</span><br><span class="line">tmpfs           1.9G  444K  1.9G    1% /run</span><br><span class="line">tmpfs           1.9G     0  1.9G    0% /sys/fs/cgroup</span><br><span class="line">tmpfs           380M     0  380M    0% /run/user/0</span><br></pre></td></tr></table></figure><ul><li>查看某个目录的大小：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># du -sh [目录名] 返回该目录的大小</span><br><span class="line">du -sh ./src</span><br><span class="line">272M./src</span><br></pre></td></tr></table></figure><ul><li>查看指定文件夹下的所有文件大小（包含子文件夹）：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h ../src/</span><br></pre></td></tr></table></figure><h3 id="查看内核-x2F-操作系统-x2F-CPU信息的linux系统信息命令"><a href="#查看内核-x2F-操作系统-x2F-CPU信息的linux系统信息命令" class="headerlink" title="查看内核&#x2F;操作系统&#x2F;CPU信息的linux系统信息命令"></a>查看内核&#x2F;操作系统&#x2F;CPU信息的linux系统信息命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br><span class="line">Linux VM_0_3_centos 3.10.0-514.26.2.el7.x86_64 #1 SMP Tue Jul 4 15:04:05 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><h3 id="查看环境变量"><a href="#查看环境变量" class="headerlink" title="查看环境变量"></a>查看环境变量</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">env</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;一些常用的命令&quot;&gt;&lt;a href=&quot;#一些常用的命令&quot; class=&quot;headerlink&quot; title=&quot;一些常用的命令&quot;&gt;&lt;/a&gt;一些常用的命令&lt;/h1&gt;&lt;h3 id=&quot;查看端口占用情况&quot;&gt;&lt;a href=&quot;#查看端口占用情况&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="Linux" scheme="https://timmy6.github.io/categories/Linux/"/>
    
    
    <category term="常用命令" scheme="https://timmy6.github.io/tags/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>数据库结构设计</title>
    <link href="https://timmy6.github.io/2019/11/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    <id>https://timmy6.github.io/2019/11/05/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1/</id>
    <published>2019-11-05T14:15:10.000Z</published>
    <updated>2022-05-17T02:16:36.607Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据库结构设计"><a href="#数据库结构设计" class="headerlink" title="数据库结构设计"></a>数据库结构设计</h2><ul><li><p>减少数据冗余</p></li><li><p>尽量避免数据维护中出现更新，插入和删除异常</p><ul><li>插入异常：如果表中的某个实体随着另一个实体而存在</li><li>更新异常：如果更改表中的某个实体的单独属性时，需要对多行进行更新</li><li>删除异常：如果删除表中的某一实体则会导致其他实体的消失</li></ul></li><li><p>节约数据存储空间</p></li><li><p>提高查询效率</p></li></ul><h2 id="数据库结构设计的步骤"><a href="#数据库结构设计的步骤" class="headerlink" title="数据库结构设计的步骤"></a>数据库结构设计的步骤</h2><ul><li><ol><li>需求分析：全面了解产品设计的存储需求</li></ol><ul><li>存储需求</li><li>数据处理需求 </li><li>数据的安全性和完整性</li></ul></li><li><ol start="2"><li>逻辑设计：设计数据的逻辑存储结构</li></ol><ul><li>数据实体之间的逻辑关系，解决数据冗余和数据维护异常</li></ul></li><li><ol start="3"><li>物理设计：根据所使用的数据库特点进行表结构设计</li></ol><ul><li>关系型数据库：Oralce，SQLServer，Mysql，postgresSQL</li><li>非关系型数据库：mongo，Redis，Hadoop</li><li>存储引擎： Innodb</li></ul></li><li><ol start="4"><li>维护优化：根据实际情况对索引，存储结构等进行优化</li></ol></li></ul><h2 id="数据库设计范式"><a href="#数据库设计范式" class="headerlink" title="数据库设计范式"></a>数据库设计范式</h2><p>设计出没有数据冗余和数据维护异常的数据库结构。</p><ul><li>数据库设计的第一范式：<ul><li>数据库表中的所有字段都只具有单一属性</li><li>单一属性的列是由基本的数据类型所构成的</li><li>设计出来的表都是简单的二维表</li></ul></li><li>数据库设计的第二范式：<ul><li>要求一个表中只具有一个业务主键，也就是说符合第二范式的表中不能存在非主键列对只对部分主键的依赖关系。</li></ul></li><li>数据库设计的第三范式：<ul><li>指每一个非主属性既不部分依赖于也不传递依赖于业务主键，也就是在第二范式的基础上消除了非主属性对主键的传递依赖。</li></ul></li></ul><h2 id="物理设计"><a href="#物理设计" class="headerlink" title="物理设计"></a>物理设计</h2><p>根据所选择的关系型数据库的特点，对逻辑模型进行存储结构设计。包括：</p><ul><li>定义数据库、表及字段的命名规范</li><li>选择合适的存储引擎</li><li>为表中的字段选择合适的数据类型</li><li>建立数据库表具体结构</li></ul><h3 id="定义数据库、表及字段的命名规范"><a href="#定义数据库、表及字段的命名规范" class="headerlink" title="定义数据库、表及字段的命名规范"></a>定义数据库、表及字段的命名规范</h3><p>数据库、表及字段的命名要遵守：</p><ul><li>可读性原则</li><li>表意性原则</li><li>长名原则</li></ul><h3 id="选择合适的存储引擎"><a href="#选择合适的存储引擎" class="headerlink" title="选择合适的存储引擎"></a>选择合适的存储引擎</h3><table><thead><tr><th>存储引擎</th><th>事务</th><th>锁粒度</th><th>主要应用</th><th>忌用</th></tr></thead><tbody><tr><td>MyISAM</td><td>不支持</td><td>支持并发插入的表级锁</td><td>select，insert</td><td>读写操作频繁</td></tr><tr><td>MRG_MYISAM</td><td>不支持</td><td>支持并发插入的表级锁</td><td>分段归档，数据仓库</td><td>全局查找过多的场景</td></tr><tr><td>Innodb</td><td>支持</td><td>支持MVCC的行级锁</td><td>事务处理</td><td>无</td></tr><tr><td>Archive</td><td>不支持</td><td>行级锁</td><td>日志记录，只支持insert，select</td><td>需要随机读取，更新，删除</td></tr><tr><td>Ndb cluster</td><td>支持</td><td>行级锁</td><td>高可用性</td><td>大部分应用</td></tr></tbody></table><h3 id="数据类型的选择"><a href="#数据类型的选择" class="headerlink" title="数据类型的选择"></a>数据类型的选择</h3><p>为表中的字段选择合适的数据类型：</p><ul><li>当一个列可以选择多种数据类型时，应该优先考虑数字类型。</li><li>其次是日期或二进制类型</li><li>最后是字符类型。</li><li>对于相同级别的数据类型，应该优先选择占用空间小的数据类型。</li></ul><p>在对数据进行比较（查询条件、Join条件有关联排序时）：字符类型是与排序规则有关系；而数字类型和二进制类型不需要参照这种这种规则，是按照二进制大小进行排序的，同样的数据字符类型处理就比较慢。</p><p>数据库中数据存储是以页为单位的，每一页存储的数据量是一定的，Innodb中是16k，数据的长度越小，在每页中能容纳的数据行数就越多，这样在加载同样的数据时，使用的宽度较小的类型就比宽度较大的类型加载的数据页较少，也就减少了磁盘IO，有利于性能的提升。</p><h4 id="如何选择正确的整数类型"><a href="#如何选择正确的整数类型" class="headerlink" title="如何选择正确的整数类型"></a>如何选择正确的整数类型</h4><table><thead><tr><th>列类型</th><th>存储空间</th><th>取值范围（SIGNED）</th><th>取值范围（UNSIGNED）</th></tr></thead><tbody><tr><td>tinyint</td><td>1个字节</td><td>-128~127 (2^7 ~ 2^7-1)</td><td>0~255</td></tr><tr><td>smallint</td><td>2个字节</td><td>-32768 ~ 32767</td><td>0~65535</td></tr><tr><td>mediumint</td><td>3个字节</td><td>-8388608 ~ 8388607</td><td>0~16777215</td></tr><tr><td>int</td><td>4个字节</td><td>-2147483648 ~ 2147483647</td><td>0~4294967295</td></tr><tr><td>bigint</td><td>8个字节</td><td>-9223372036854775808 ~ 9223372036854775807</td><td>0 ~ 18446744073709551615</td></tr></tbody></table><p>如果只存储两位数，就使用 tinyint 类型，不要使用 int 类型，可以节约空间。</p><h4 id="如何选择正确的实数类型"><a href="#如何选择正确的实数类型" class="headerlink" title="如何选择正确的实数类型"></a>如何选择正确的实数类型</h4><table><thead><tr><th>列类型</th><th>存储空间</th><th>是否精确类型</th></tr></thead><tbody><tr><td>FLOAT</td><td>4个字节</td><td>否</td></tr><tr><td>DOUBLE</td><td>8个字节</td><td>否</td></tr><tr><td>DECIMAL</td><td>每4个字节存9个数字，小数点占一个字节</td><td>是</td></tr></tbody></table><p>DECIMAL(18,9) 需要 9 个字节来存储。</p><h4 id="如何选择-VARCHAR-和-CHAR-类型"><a href="#如何选择-VARCHAR-和-CHAR-类型" class="headerlink" title="如何选择 VARCHAR 和 CHAR 类型"></a>如何选择 VARCHAR 和 CHAR 类型</h4><ul><li><p>VARCHAR 类型的存储特点：</p><ul><li>varchar 用于存储变长字符串，只占用必要的存储空间</li><li>列的最大长度小于255则只占用一个额外字节用于记录字符串长度</li><li>列的最大长度大于255则要占用两个额外字节用于记录字符串长度</li></ul></li><li><p>VARCHAR 长度的选择问题</p><ul><li>使用最小的符合需求的长度</li><li>varchar(5)和varchar(200)存储’Mysql’字符串性能不同<ul><li>mysql 为了更有效的优化查询，在内存中对字符串的使用是固定的宽度，列太长就会消耗更多的内存。</li></ul></li></ul></li><li><p>VARCHAR 的适用场景：</p><ul><li>字符串列的最大长度比平均长度大很多（发挥变长存储的特点）</li><li>字符串列很少被更新（更新，字符串长度会产生变化，可能引起存储页的分裂；还会产生很多存储碎片）</li><li>使用了多字节字符集存储字符串（例如utf8，不同字符存储字节数不同，中文和英文就不同）</li></ul></li><li><p>CHAR 类型的存储特点：</p><ul><li>CHAR 类型是定长的</li><li>字符串存储在 CHAR 类型的列中会删除末尾的空格</li><li>CHAR 类型的最大宽度为 255</li></ul></li><li><p>CHAR 的适用场景：</p><ul><li>CHAR 类型适合存储所有长度近似的值 （eg： md5值，身份证号，手机号）</li><li>CHAR 类型适合存储短字符串</li><li>CHAR 类型适合存储经常更新的字符串列</li></ul></li></ul><h4 id="如何存储日期类型"><a href="#如何存储日期类型" class="headerlink" title="如何存储日期类型"></a>如何存储日期类型</h4><ul><li>DATATIME 类型</li></ul><p>以 <code>YYYY-MM-DD HH:MM:SS[.fraction]</code> 格式存储日期时间</p><p>datetime &#x3D; YYYY-MM-DD HH:MM:SS</p><p>datetime(6) &#x3D; YYYY-MM-DD HH:MM:SS.fraction</p><p>DATATIME类型与时区无关，占用8个字节的存储空间</p><p>时间范围：1000-01-01 00:00:00 到 9999-12-31 23:59:59</p><ul><li>TIMESTAMP 类型</li></ul><p>时间戳，存储了由格林尼治时间1970年1月1日到当前时间的秒数</p><p>以 YYYY-MM-DD HH:MM:SS.[.fraction] 的格式显示，占用4个字节。</p><p>时间范围： 1970-01-01 到 2038-01-19</p><p>timestamp 类型显示依赖于所指定的时区</p><p>在行的数据修改时，可以自动修改 timestamp 列的值。</p><ul><li>date类型</li></ul><blockquote><p>存储用户生日时，只需要存储日期部分</p></blockquote><p>一是把日期部分存储为字符串（至少要8个字节）</p><p>二是使用int类型来存储（4个字节）</p><p>三是使用datetime类型来存储（8个字节）</p><p>date 类型的优点：</p><ol><li><p>占用的字节数比使用字符串、datetime、int存储要少，使用date类型只需要3个字节。</p></li><li><p>使用Date类型还可以利用日期时间函数进行日期之间的计算</p></li></ol><p>date类型用于保存 1000-01-01 到 9999-12-31 之间的日期</p><ul><li>time类型</li></ul><p>time类型用于存储时间数据，格式为：HH:MM:SS </p><ul><li><p>存储日期时间数据的注意事项</p><ul><li>不要使用字符串类型来存储日期时间数据<ul><li>日期时间类型通常比字符串占用的存储空间小</li><li>日期时间类型在进行查找过滤时可以利用日期来进行对比</li><li>日期时间类型还有着丰富的处理函数，可以方便的对时期类型进行日期计算</li></ul></li><li>使用Int存储日期时间不如使用 Timestamp 类型</li></ul></li></ul><h3 id="如何为-Innodb-选择主键"><a href="#如何为-Innodb-选择主键" class="headerlink" title="如何为 Innodb 选择主键"></a>如何为 Innodb 选择主键</h3><ul><li>主键应该尽可能的小</li><li>主键应该是顺序增长的<ul><li>（Innodb 内部的逻辑顺序是和主键顺序相同的，主键的顺序是顺序增长的，那么插入数据就能顺序插入，避免了随机IO的产生，所以这样可以增加数据的插入效率）</li></ul></li><li>Innodb 的主键和业务主键可以不同 （业务主键可以添加唯一索引）</li></ul><p>数据库结构：（查询性能要求、范式化要求）</p><p>从数据库架构方面优化数据库；<br>维护和优化：索引&amp;sql优化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据库结构设计&quot;&gt;&lt;a href=&quot;#数据库结构设计&quot; class=&quot;headerlink&quot; title=&quot;数据库结构设计&quot;&gt;&lt;/a&gt;数据库结构设计&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;减少数据冗余&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;尽量避免数据维护中出现更新，插入和</summary>
      
    
    
    
    <category term="MySql" scheme="https://timmy6.github.io/categories/MySql/"/>
    
    
    <category term="数据库优化" scheme="https://timmy6.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
</feed>
