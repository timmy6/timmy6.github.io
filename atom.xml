<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://timmy6.github.io/atom.xml" rel="self"/>
  
  <link href="https://timmy6.github.io/"/>
  <updated>2022-05-16T09:59:32.770Z</updated>
  <id>https://timmy6.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CentOS参数配置对mysql性能优化</title>
    <link href="https://timmy6.github.io/2019/08/15/CentOS%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E5%AF%B9mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"/>
    <id>https://timmy6.github.io/2019/08/15/CentOS%E5%8F%82%E6%95%B0%E9%85%8D%E7%BD%AE%E5%AF%B9mysql%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</id>
    <published>2019-08-15T13:15:10.000Z</published>
    <updated>2022-05-16T09:59:32.770Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CentOS系统参数优化"><a href="#CentOS系统参数优化" class="headerlink" title="CentOS系统参数优化"></a>CentOS系统参数优化</h2><p>推荐书籍：《Linux性能优化大师》</p><p>内核相关参数( <code>/etc/sysctl.conf</code> )</p><ul><li>查看内核(<code>kernel</code>)参数配置</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -a</span><br></pre></td></tr></table></figure><h4 id="网络性能参数"><a href="#网络性能参数" class="headerlink" title="网络性能参数"></a>网络性能参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">net.core.somaxconn=65535</span><br><span class="line">net.core.netdev_max_backlog=65535</span><br><span class="line">net.ipv4.tcp_max_syn_backlog=65535</span><br></pre></td></tr></table></figure><p>http 请求经过三次握手建立网络连接，处于监听状态的端口，都会有自己的监听队列，参数 <code>net.core.somaxconn</code> 就决定了监听队列大小的长度，负载很大的服务器，就需要把这个参数修改大一些。</p><p><code>net.core.netdev_max_backlog</code> 在每个网络接口接收数据包的速率 比 内核处理数据包的速率快的时候，允许被发送到队列中的数据包的最大数量。</p><p><code>net.ipv4.tcp_max_syn_backlog</code> 还未获得对方连接的请求，可以保存到队列中的最大数目，超过这个数据大小的连接可能就会被抛弃。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#查看有多少个请求由监听变成了链接</span><br><span class="line"></span><br><span class="line">#列出所有的端口，包括监听的和未监听的。</span><br><span class="line">netstat -a</span><br><span class="line"></span><br><span class="line">Active Internet connections (servers and established)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State</span><br><span class="line">tcp        0      0 0.0.0.0:etlservicemgr   0.0.0.0:*               LISTEN</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#列出所有的tcp协议的端口</span><br><span class="line">netstat -t</span><br><span class="line"></span><br><span class="line">#列出所有的UDP协议的端口</span><br><span class="line">netstat -ua</span><br><span class="line"></span><br><span class="line">#找出程序运行的端口</span><br><span class="line">netstat -ap | grep &#x27;程序名&#x27;</span><br><span class="line"></span><br><span class="line">#找出端口的程序名</span><br><span class="line">netstat -ap | grep &#x27;端口号&#x27;</span><br><span class="line"></span><br><span class="line">#显示路由表的信息</span><br><span class="line">netstat -r</span><br><span class="line"></span><br><span class="line">#显示接口信息</span><br><span class="line">netstat -i</span><br><span class="line"></span><br><span class="line">#分类统计各个协议的相关信息</span><br><span class="line">netstat -sa</span><br></pre></td></tr></table></figure><ul><li><code>net.ipv4.tcp_fin_timeout</code> 用于处理 tcp 连接等待状态的时间</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#用于加快 tcp 连接的回收，tcp连接占满就会出现无法连接的状态</span><br><span class="line">net.ipv4.tcp_fin_timeout=10</span><br><span class="line">net.ipv4.tcp_tw_reuse=1</span><br><span class="line">net.ipv4.tcp_tw_recycle=1</span><br></pre></td></tr></table></figure><ul><li>tcp 连接接收和发送缓冲区大小的默认值和最大值（调整的大一些）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">net.core.wmem_default = 87380</span><br><span class="line">net.core.wmem_max = 16777216</span><br><span class="line">net.core.rmem_default=87380</span><br><span class="line">net.core.rmem_max=16777216</span><br></pre></td></tr></table></figure><ul><li>减少失效连接所占用的 tcp 资源的数量，加快资源回收的效率（调整小一些）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#tcp 发送 keepalive 的时间间隔，用户确认tcp连接是否有效，单位秒</span><br><span class="line">net.ipv4.tcp_keepalive_time=120</span><br><span class="line"></span><br><span class="line">#当发送探测点消息没有响应时，重发该消息的时间间隔，单位秒</span><br><span class="line">net.ipv4.tcp_keepalive_intvl=30</span><br><span class="line"></span><br><span class="line">#认定 tcp 连接失效之前，最多发送多少个 keepalive 消息</span><br><span class="line">net.ipv4.tcp_keepalive_probes=3</span><br></pre></td></tr></table></figure><h4 id="内存性能参数"><a href="#内存性能参数" class="headerlink" title="内存性能参数"></a>内存性能参数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kernel.shmmax = 4294967295</span><br></pre></td></tr></table></figure><ul><li>这个参数应该设置的足够大，以便能在一个共享内存段下容纳下整个的 Innodb 缓冲池的大小。（如果太低，就需要创建多个共享内存段，可能导致系统性能下降，原因是当实例启动的时候，多个共享内存段可能会导致当时系统性能轻微的性能下降，其他时候不会有影响）</li><li>这个值的大小对 64 位 linux 系统，可取的最大值为物理内存值-1byte，建议值为大于物理内存的一半，一般取值大于Innodb缓冲池的大小即可，可以取物理内存-1byte。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.swappiness = 0</span><br></pre></td></tr></table></figure><ul><li>这个参数当内存不足时，会对性能产生比较明显的影响</li></ul><p>Linux 系统内存交换区：<br>在Linux系统安装时，都会有一个特殊的磁盘分区，称之为系统交换分区。<br>使用 <code>free -m</code> 在系统中查看，可以看到类似下面的内容，其中 <code>swap</code> 就是交换分区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@VM_0_3_centos ~]# free -m</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           3790        1763         235           0        1791        1732</span><br><span class="line">Swap:             0           0           0</span><br></pre></td></tr></table></figure><p>当操作系统因为没有足够的内存时，就会将一些虚拟内存写到磁盘的交换区中，这样就会发生内存交换。</p><p>在MySQL 服务器上是或否要使用交换分区有一些争议：在MySQL服务所在的Linux系统上完全禁用交换分区。<br>带来的风险：降低操作系统的性能；容易造成内存溢出，崩溃，或都被操作系统kill掉。</p><p>在MySQL服务器上保留交换分区还是很有必要的，但是要控制何时使用交换分区。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.swappiness = 0</span><br></pre></td></tr></table></figure><ul><li>参数告诉Linux内核除非虚拟内存完全满了，否则不要使用交换分区。</li></ul><h4 id="增加资源限制-etc-security-limit-conf"><a href="#增加资源限制-etc-security-limit-conf" class="headerlink" title="增加资源限制 /etc/security/limit.conf"></a>增加资源限制 <code>/etc/security/limit.conf</code></h4><p>这个文件实际上市 Linux PAM 也就是插入式认证模块的配置文件。<br>打开文件数的限制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft nofile 65535</span><br><span class="line">* hard nofile 65535</span><br></pre></td></tr></table></figure><ul><li>用于控制打开文件的数量，加到 limit.conf 文件的末尾即可。 增加到 65535 以保证可以打开足够多的文件句柄。</li><li><ul><li>表示对所有用户有效</li></ul></li><li>soft 指的是当前系统生效的设置</li><li>hard 表明系统中所有设定的最大值</li><li>nofile 表示所限制的资源是打开文件的最大数目</li><li>65536 就是限制的数量</li><li>这个文件修改需要重启系统才能生效。</li></ul><h4 id="磁盘调度策略"><a href="#磁盘调度策略" class="headerlink" title="磁盘调度策略"></a>磁盘调度策略</h4><p><code>/sys/block/devname/queue/scheduler</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /sys/block/vda/queue/scheduler</span><br><span class="line"></span><br><span class="line">cat /sys/block/sda/queue/scheduler</span><br><span class="line">noop anticipatory deadline [cfq]</span><br></pre></td></tr></table></figure><ul><li><p>noop（电梯式调度策略） ：NOOP 实现了一个 FIFO 队列，它像电梯的工作方法一样对 I&#x2F;O 请求进行组织，当有一个新的请求到来时，它将请求合并到最近的请求之后，以此来保证请求同一介质。 NOOP 倾向饿死读而立于写，因此 NOOP 对于闪存设备、RAM及嵌入式系统是最好的选择。</p></li><li><p>deadline（截止时间调度策略）： deadline 确保了一个截止时间内服务请求，这个截止时间是可调整的，而默认读期限短于写期限。 这样就防止了写操作因为不能被读取而饿死的现象， deadline 对数据库类应用是最好的选择。</p></li><li><p>anticipatory （预料I&#x2F;O调度策略）： 本质上与deadline 一样，但在最后一次读操作后，要等待6ms，才能继续进行对其他I&#x2F;O请求进行调度。 它会在每个6ms中插入新的I&#x2F;O操作，而会将一些小写入流合并成一个大写入流，用写入延时换取最大的写入吞吐量。 AS适合于写入较多的环境，比如文件服务器，AS对数据库环境表现很差。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;CentOS系统参数优化&quot;&gt;&lt;a href=&quot;#CentOS系统参数优化&quot; class=&quot;headerlink&quot; title=&quot;CentOS系统参数优化&quot;&gt;&lt;/a&gt;CentOS系统参数优化&lt;/h2&gt;&lt;p&gt;推荐书籍：《Linux性能优化大师》&lt;/p&gt;
&lt;p&gt;内核相关</summary>
      
    
    
    
    <category term="MySql" scheme="https://timmy6.github.io/categories/MySql/"/>
    
    
    <category term="数据库优化" scheme="https://timmy6.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>影响数据库性能的因素</title>
    <link href="https://timmy6.github.io/2019/08/10/%E5%BD%B1%E5%93%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E7%9A%84%E5%9B%A0%E7%B4%A0/"/>
    <id>https://timmy6.github.io/2019/08/10/%E5%BD%B1%E5%93%8D%E6%95%B0%E6%8D%AE%E5%BA%93%E6%80%A7%E8%83%BD%E7%9A%84%E5%9B%A0%E7%B4%A0/</id>
    <published>2019-08-10T15:15:10.000Z</published>
    <updated>2022-05-16T09:56:55.733Z</updated>
    
    <content type="html"><![CDATA[<h2 id="影响数据库性能的因素"><a href="#影响数据库性能的因素" class="headerlink" title="影响数据库性能的因素"></a>影响数据库性能的因素</h2><ul><li>影响数据库性能的因素<ul><li>sql查询速度</li><li>服务器硬件</li><li>网卡流量</li><li>磁盘IO</li><li>网卡流量</li><li>大表</li><li>大事务</li></ul></li></ul><h3 id="QPS-amp-TPS"><a href="#QPS-amp-TPS" class="headerlink" title="QPS &amp; TPS"></a>QPS &amp; TPS</h3><p>QPS：每秒钟处理的查询量</p><ul><li>eg：<ul><li>一个cpu 10ms 处理 1个sql，</li><li>1s 处理 100个sql，那么QPS&lt;&#x3D;100</li><li>一个cpu 100ms处理 1个sql，QPS&lt;&#x3D;10</li></ul></li></ul><p>TPS：</p><ul><li>超高的QPS和TPS带来的风险：效率低下的SQL</li></ul><p>数据库的性能问题大部分都是由于sql的慢查询造成的，大部分问题可以通过对sql的优化得到解决。</p><h3 id="并发量-amp-CPU使用率"><a href="#并发量-amp-CPU使用率" class="headerlink" title="并发量 &amp; CPU使用率"></a>并发量 &amp; CPU使用率</h3><p>并发量：同一时间处理的请求的数量；与同时连接数不同。</p><p>空闲的百分比值越高空闲率越高。</p><ul><li>大量的并发和超高的CPU使用率</li></ul><p>大量的并发：数据库连接数被占满。（max_connections默认100）</p><p>超高的CPU使用率：因cpu资源耗尽而出现宕机。</p><h3 id="磁盘IO"><a href="#磁盘IO" class="headerlink" title="磁盘IO"></a>磁盘IO</h3><p>数据库备份远程同步计划任务会导致IO达到峰值。</p><ul><li>最好不要在主库上数据库备份</li><li>大型活动前取消这类计划</li></ul><p>风险：</p><p>磁盘IO性能突然下降（使用更快的磁盘设备）</p><p>其他大量消耗磁盘性能的计划任务（调整计划任务，做好磁盘维护）</p><ul><li>数据库扩展需要完整性和一致性</li></ul><h3 id="网卡流量"><a href="#网卡流量" class="headerlink" title="网卡流量"></a>网卡流量</h3><p>网卡IO被占满（1000Mb&#x2F;8 约等于 100MB）</p><ul><li>如何避免无法连接数据库的情况：<ul><li>减少从服务器的数量</li><li>进行分级缓存</li><li>避免使用 select * 进行查询</li><li>分离业务网络和服务器网络</li></ul></li></ul><h3 id="大表"><a href="#大表" class="headerlink" title="大表"></a>大表</h3><ul><li><p>记录行数巨大，单标超过千万行</p></li><li><p>表数据文件巨大，表数据文件超过10G</p></li><li><p>第一、 大表对查询的影响：</p><ul><li>慢查询：很难再一定的时间内过滤出所需要的数据。</li><li>查询的维度区分度比较低（只有几个维度，例如三方登录字段：只有微信、qq几个有限的维度，查询的数据量就比较大），会产生大量磁盘IO，降低磁盘效率。</li></ul></li><li><p>第二、大表对DDL操作的影响：</p><ul><li>建立索引需要很长的时间</li><li>Mysql 版本 &lt; 5.5 建立索引会锁表</li><li>Mysql 版本 &gt;&#x3D; 5.5 虽然不会锁表，但会引起主从延迟</li><li>大表对DDL操作的影响：修改表结构需要长时间锁表。</li><li>风险：会造成长时间的主从延迟。影响正常的数据操作。</li></ul></li><li><p>如何处理数据库中的大表：</p><ul><li><ol><li>分库分表把一张大表分成多个小表。</li></ol><ul><li>难点：</li><li>分表主键的选择；分表后跨分区数据的查询和统计。</li></ul></li><li><ol start="2"><li>大表的历史数据归档：</li></ol><ul><li>减少对前后端业务的影响</li><li>难点：归档时间点的选择。如何进行归档操作。</li></ul></li></ul></li></ul><h3 id="大事务"><a href="#大事务" class="headerlink" title="大事务"></a>大事务</h3><ul><li><p>什么是事务？</p><ul><li>事务是数据库系统区别于其他一切文件系统的重要特征之一</li><li>事务是一组具有原子性的sql语句，或是一个独立的工作单元</li></ul></li><li><p>特点：原子性、一致性、隔离性、持久性</p></li><li><p>事务原子性 atomicity：</p><ul><li>一个事务被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说，不可能只执行其中的一部分操作</li><li>银行例子：1. 取钱  2.存钱</li></ul></li><li><p>事务的一致性 consistency：</p><ul><li>一致性是指事务将数据库从一种一致性状态转换到另外一种一致性状态，在事务开始之前和事务结束后数据库中数据的完整性没有被破坏</li></ul></li><li><p>事务的隔离性 isolation： </p><ul><li>隔离性要求一个事务对数据库中数据的修改，在未提交完成前对于其它事务是不可见的</li><li>SQL标准中定义的四种隔离级别：<ul><li>未提交读（READ uncommited）</li><li>已提交读（READ commited）（不可重复读）</li><li>可重复读（repeatable READ）</li><li>可串行化（serializable）</li></ul></li><li>隔离性由低-&gt;高，并发性由高-&gt;低</li></ul></li><li><p>事务的持久性 durability：</p><ul><li>一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，已经提交的修改数据也不会丢失</li></ul></li><li><p>大事务：</p><ul><li>运行时间比较长，操作的数据比较多的事务</li><li>风险：<ul><li>锁定太多的数据，造成大量的阻塞和锁超时</li><li>回滚时所需时间比较长</li><li>执行时间长，容易造成主从延迟</li></ul></li></ul></li><li><p>如何处理大事务：</p><ul><li>避免一次处理太多的数据</li><li>移除不必要在事务中的select操作</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;影响数据库性能的因素&quot;&gt;&lt;a href=&quot;#影响数据库性能的因素&quot; class=&quot;headerlink&quot; title=&quot;影响数据库性能的因素&quot;&gt;&lt;/a&gt;影响数据库性能的因素&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;影响数据库性能的因素&lt;ul&gt;
&lt;li&gt;sql查询速度&lt;/li&gt;
</summary>
      
    
    
    
    <category term="MySql" scheme="https://timmy6.github.io/categories/MySql/"/>
    
    
    <category term="数据库优化" scheme="https://timmy6.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>go interface</title>
    <link href="https://timmy6.github.io/2019/07/25/go-interface/"/>
    <id>https://timmy6.github.io/2019/07/25/go-interface/</id>
    <published>2019-07-25T15:15:10.000Z</published>
    <updated>2022-05-16T09:51:17.074Z</updated>
    
    <content type="html"><![CDATA[<h1 id="interface"><a href="#interface" class="headerlink" title="interface"></a>interface</h1><ul><li><p>接口（interface）无法被实例化.</p></li><li><p>接口类型也算是引用类型。</p></li><li><p>接口是根据方法集合区分的（定义的所有方法）。</p></li><li><p>代表某一类特征（<code>Duck Typing</code>）</p></li></ul><h2 id="接口的使用"><a href="#接口的使用" class="headerlink" title="接口的使用"></a>接口的使用</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Animal interface &#123;</span><br><span class="line">    Eat(foot string)</span><br><span class="line">    Run()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">type Person struct &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">func (p *Person)Eat(foot string) &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line">func (p *Person)Run() &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Person 实现了 <code>Eat(foot string)</code> 方法和 <code>Run()</code> 方法, 也就是说 Person 实现了接口 Animal ，并且这种实现接口的方式是无侵入的.</p></li><li><p>判断一个类型是否实现了某个接口：</p><ul><li>两个方法的签名需要完全一致</li><li>两个方法的名称要一模一样</li></ul></li></ul><h2 id="接口的另一种使用"><a href="#接口的另一种使用" class="headerlink" title="接口的另一种使用"></a>接口的另一种使用</h2><ul><li>可以把实现接口的类型，赋值给对应的接口类型变量</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p Person = &amp;Person&#123;&#125;</span><br><span class="line">var a Animal = p</span><br></pre></td></tr></table></figure><ul><li><p>变量 <code>p</code> 是接口变量 <code>a</code> 的<code>实际值</code>，也叫<code>动态值</code>.</p></li><li><p>变量 <code>p</code> 的类型 <code>Person</code> 叫做接口变量 <code>a</code> 的<code>实际类型</code>，也叫 <code>动态类型</code>.</p></li><li><p>类型 <code>Animal</code> 是接口变量 <code>a</code> 的 <code>静态类型</code>，是永远不会变化的。（相对于动态类型是变化的跟我们的赋值有关）</p></li><li><p>接口类型变量的零值是<code>nil</code>。</p></li><li><p>当给一个接口变量赋值的时候，该变量的动态类型和动态值会一起被存储在一个专用的数据结构中。</p></li><li><p>其实，这个接口变量的值是这个专用数据结构的一个实例，而不是我们赋给改变量的那个实际值。</p></li><li><p>这个专用的数据结构在 Go 语言的 <code>runtime</code> 包中叫 <code>iface</code> 。<code>iface</code>的实例会包含两个指针，一个是指向类型信息的指针，另一个是指向动态值的指针。这里的类型信息是由另一个专用数据结构的实例承载的，其中包含了动态值的类型，以及使它实现了接口的方法和调用他们的途径。</p></li><li><p>使用 <code>==</code> 判断接口变量是否为 <code>nil</code>：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var p Person</span><br><span class="line">var a Animal = p</span><br><span class="line">// p == nil , a != nil</span><br><span class="line">if a == nil &#123;</span><br><span class="line">fmt.Println(&quot;a == nil&quot;)</span><br><span class="line">&#125;else&#123;</span><br><span class="line">fmt.Println(&quot;a != nil&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对一个接口变量只声明不初始化，或者直接给接口变量赋值 <code>nil</code>，这时接口变量值为 <code>nil</code>。</li></ul><h2 id="接口的组合"><a href="#接口的组合" class="headerlink" title="接口的组合"></a>接口的组合</h2><p>接口的组合：接口类型之间的嵌入。</p><p>建议声明小接口，更容易组合接口，扩展性强、比较灵活。</p><p>组合的接口之间有同名的方法（方法签名不同也不行）就会编译报错。</p><p>看Go标准库 <code>io</code> 包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type Reader interface &#123;</span><br><span class="line">Read(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type Writer interface &#123;</span><br><span class="line">Write(p []byte) (n int, err error)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type ReadWriter interface &#123;</span><br><span class="line">Reader</span><br><span class="line">Writer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>同时实现了 <code>Reader</code> 接口和 <code>Writer</code> 接口，就相当于实现了组合接口 <code>ReadWriter</code>。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">type Closer interface &#123;</span><br><span class="line">Close() error</span><br><span class="line">&#125;</span><br><span class="line">type ReadCloser interface &#123;</span><br><span class="line">Reader</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br><span class="line">type WriteCloser interface &#123;</span><br><span class="line">Writer</span><br><span class="line">Closer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="nil-接口变量"><a href="#nil-接口变量" class="headerlink" title="nil 接口变量"></a>nil 接口变量</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var p Person = nil</span><br><span class="line">var a Animal = p</span><br><span class="line">// p == nil , a != nil</span><br></pre></td></tr></table></figure><p>Person 实现了接口，p 是一个nil变量，赋值给接口类型变量 a，a 依然可以调用接口实现的方法。方法接收者必须是指针类型才能调用接口实现的方法。</p><h2 id="Duck-Typing"><a href="#Duck-Typing" class="headerlink" title="Duck Typing"></a>Duck Typing</h2><p><code>Duck Typing</code> ，看起来像鸭子，它就是鸭子。</p><ul><li><p><code>Go</code>语言对象没有继承和多态，只有封装性。</p></li><li><p>协议注重关注方法的实现，而很少关注类型。</p></li><li><p>只要实现了B协议方法的实体，是B协议类型的入参， 都可以作为的传入。</p></li><li><p>变相实现了继承和多态，实现多个协议，就可以是类似多继承。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;interface&quot;&gt;&lt;a href=&quot;#interface&quot; class=&quot;headerlink&quot; title=&quot;interface&quot;&gt;&lt;/a&gt;interface&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;接口（interface）无法被实例化.&lt;/p&gt;
&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>go mod</title>
    <link href="https://timmy6.github.io/2019/07/16/go-mod/"/>
    <id>https://timmy6.github.io/2019/07/16/go-mod/</id>
    <published>2019-07-16T14:15:10.000Z</published>
    <updated>2022-05-16T09:48:42.679Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go-mod"><a href="#go-mod" class="headerlink" title="go mod"></a>go mod</h1><h2 id="go-mod-命令管理包"><a href="#go-mod-命令管理包" class="headerlink" title="go mod 命令管理包"></a><code>go mod</code> 命令管理包</h2><ul><li>在当前目录初始化生成 <code>go.mod</code> 文件</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod init </span><br></pre></td></tr></table></figure><ul><li>下载包依赖到本地缓存</li></ul><p>本地缓存目录：<code>$GOPATH/pkg/mod</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod download</span><br></pre></td></tr></table></figure><ul><li>编辑<code>go.mod</code></li></ul><p>格式化<code>go.mod</code>文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -fmt</span><br></pre></td></tr></table></figure><p>以<code>json</code>的形式查看依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go list -m -json all</span><br><span class="line">go mod edit -json</span><br></pre></td></tr></table></figure><ul><li>打印模块依赖图</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod graph</span><br></pre></td></tr></table></figure><ul><li>拉取缺少的模块，移除不用的模块</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><ul><li>将依赖复制到<code>vendor</code>下</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod vendor</span><br></pre></td></tr></table></figure><ul><li>验证依赖是否正确</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod verify</span><br></pre></td></tr></table></figure><ul><li>需要依赖的原因</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod why</span><br></pre></td></tr></table></figure><h2 id="go-mod-编写"><a href="#go-mod-编写" class="headerlink" title="go.mod 编写"></a><code>go.mod</code> 编写</h2><p>四个命令: </p><ul><li><code>module</code> : 指定包的名字（路径）</li><li><code>require</code>: 指定的依赖项模块</li><li><code>replace</code>: 可以替换依赖项模块</li><li><code>exclude</code>: 可以忽略依赖项模块</li></ul><p>eg:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">module cocktail</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.12</span></span><br><span class="line"></span><br><span class="line">require github.com/gin-gonic/gin v1<span class="number">.4</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">replace (</span><br><span class="line">golang.org/x/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190308221718</span>-c2843e01d9a2 =&gt; github.com/golang/crypto v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190513172903</span><span class="number">-22</span>d7a77e9e5f</span><br><span class="line">golang.org/x/net =&gt; github.com/golang/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190514140710</span><span class="number">-3</span>ec191127204</span><br><span class="line">golang.org/x/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190404232315</span>-eb5bcb51f2a3 =&gt; github.com/golang/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190514140710</span><span class="number">-3</span>ec191127204</span><br><span class="line">golang.org/x/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190503192946</span>-f4e77d36d62c =&gt; github.com/golang/net v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190514140710</span><span class="number">-3</span>ec191127204</span><br><span class="line"></span><br><span class="line">golang.org/x/sync =&gt; github.com/golang/sync v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190423024810</span><span class="number">-112230192</span>c58</span><br><span class="line">golang.org/x/sys v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190222072716</span>-a9d3bda3a223 =&gt; github.com/golang/sys v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190516110030</span><span class="number">-61</span>b9204099cb</span><br><span class="line">golang.org/x/sys v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190412213103</span><span class="number">-97732733099</span>d =&gt; github.com/golang/sys v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190516110030</span><span class="number">-61</span>b9204099cb</span><br><span class="line"></span><br><span class="line">golang.org/x/text v0<span class="number">.3</span><span class="number">.0</span> =&gt; github.com/golang/text v0<span class="number">.3</span><span class="number">.2</span></span><br><span class="line">golang.org/x/tools v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20180917221912</span><span class="number">-90</span>fa682c2a6e =&gt; github.com/golang/tools v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190517183331</span>-d88f79806bbd</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>使用 <code>replace</code> 可以把 <code>golang.rog/</code> 替换成 <code>github/ </code> 。</p><h2 id="一些其他使用"><a href="#一些其他使用" class="headerlink" title="一些其他使用"></a>一些其他使用</h2><ul><li><p>执行 <code>go run server.go</code> 运行代码会发现 <code>go mod</code> 会自动查找依赖自动下载。</p></li><li><p><code>go module</code> 安装 <code>package</code> 的原則是先拉最新的 <code>release tag</code>，若无<code>tag</code>则拉最新的<code>commit</code>。 </p></li><li><p><code>go</code> 会自动生成一个 <code>go.sum</code> 文件来记录 <code>dependency tree</code>。</p></li><li><p>来检查可以升级的 <code>package</code></p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go list -m -u all</span><br></pre></td></tr></table></figure><ul><li>升级依赖版本<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u need-upgrade-package</span><br></pre></td></tr></table></figure></li></ul><p>或者 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u</span><br></pre></td></tr></table></figure><blockquote><p>Modules官方介绍：<a href="https://github.com/golang/go/wiki/Modules">https://github.com/golang/go/wiki/Modules</a></p></blockquote><h2 id="一些遇到的问题"><a href="#一些遇到的问题" class="headerlink" title="一些遇到的问题"></a>一些遇到的问题</h2><ul><li>go 1.10.3 版本Bug。需要升级版本,删除 <code>/usr/local/Cellar/go/</code> 目录下文件，重新安装。</li></ul><p>原因参考：<a href="https://github.com/golang/go/issues?q=milestone:Go1.10.4">https://github.com/golang/go/issues?q=milestone%3AGo1.10.4</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/beego/bee</span><br><span class="line"></span><br><span class="line"><span class="comment"># github.com/beego/bee</span></span><br><span class="line">/usr/local/Cellar/go/1.10.3/libexec/pkg/tool/darwin_amd64/link: /usr/local/Cellar/go/1.10.3/libexec/pkg/tool/darwin_amd64/link: combining dwarf failed: Unknown load <span class="built_in">command</span> 0x32 (50)</span><br></pre></td></tr></table></figure><ul><li>go mod init 报错</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">go mod </span><br><span class="line"></span><br><span class="line">go: modules disabled inside GOPATH/src by GO111MODULE=auto; see &#x27;go help modules&#x27;</span><br><span class="line"></span><br><span class="line"># 设置环境变量解决 GO111MODULE 默认值为auto  其他：on 、off</span><br><span class="line">export GO111MODULE=on</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;go-mod&quot;&gt;&lt;a href=&quot;#go-mod&quot; class=&quot;headerlink&quot; title=&quot;go mod&quot;&gt;&lt;/a&gt;go mod&lt;/h1&gt;&lt;h2 id=&quot;go-mod-命令管理包&quot;&gt;&lt;a href=&quot;#go-mod-命令管理包&quot; class=&quot;head</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Golang不同类型比较</title>
    <link href="https://timmy6.github.io/2019/06/16/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83/"/>
    <id>https://timmy6.github.io/2019/06/16/%E4%B8%8D%E5%90%8C%E7%B1%BB%E5%9E%8B%E6%AF%94%E8%BE%83/</id>
    <published>2019-06-16T14:15:10.000Z</published>
    <updated>2022-05-16T09:39:13.858Z</updated>
    
    <content type="html"><![CDATA[<h1 id="9-13-Golang不同类型比较"><a href="#9-13-Golang不同类型比较" class="headerlink" title="9.13  Golang不同类型比较"></a>9.13  Golang不同类型比较</h1><p>在日常开发过程中难免会遇到各个类型的变量的比较以及运算操作，这里做了一些简单的汇总，希望能给各位同学在开发中带来帮助。</p><p>这里先上一波关系运算符&#x3D;&#x3D;，!&#x3D;，&lt;，&lt;&#x3D;，&gt; 和 &gt;&#x3D;。</p><h3 id="float浮点数比较"><a href="#float浮点数比较" class="headerlink" title="float浮点数比较"></a>float浮点数比较</h3><p>golang 支持两种浮点float32和float64，众所众知，涉及浮点数比较或运算是会遇到精度问题，具体要根据golang实现IEEE 754的情况定。</p><p>默认情况下，float32精度是小数后7位，float64精度是小数点后15位。</p><p>如例1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a float32 = 1.00000001</span><br><span class="line">var b float32 = 1.000000000001</span><br><span class="line">var c float32 = 1.0000001</span><br><span class="line">var d float32 = 1.000000000001</span><br><span class="line"></span><br><span class="line">fmt.Println(a == b) //true</span><br><span class="line">fmt.Println(a &gt; b)  //false</span><br><span class="line">fmt.Println(c == d) //false</span><br><span class="line">fmt.Println(c &gt; d)  //true</span><br></pre></td></tr></table></figure><p>float64</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a float64 = 1.0000000000000001</span><br><span class="line">var b float64 = 1.000000000000000001</span><br><span class="line">var c float64 = 1.000000000000001</span><br><span class="line">var d float64 = 1.0000000000000000001</span><br><span class="line"></span><br><span class="line">fmt.Println(a == b) //true</span><br><span class="line">fmt.Println(a &gt; b)  //false</span><br><span class="line">fmt.Println(c == d) //false</span><br><span class="line">fmt.Println(c &gt; d)  //true</span><br></pre></td></tr></table></figure><p>这里写了一个根据精度进行float比较的简单的类，注意最大精度为小数点后15位，超出会丢失精度。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;math&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Floater struct &#123;</span><br><span class="line">Accuracy float64   //精度,最大为小数点后15位</span><br><span class="line">&#125;</span><br><span class="line">//是否相等</span><br><span class="line">func (f Floater) IsEqual(a, b float64) bool &#123;</span><br><span class="line">return math.Abs(a-b) &lt; f.Accuracy</span><br><span class="line">&#125;</span><br><span class="line">//0为相等 1为a大于b -1为a小于b</span><br><span class="line">func (f Floater) Bccomp(a, b float64) int8 &#123;</span><br><span class="line">if math.Abs(a-b) &lt; f.Accuracy &#123;</span><br><span class="line">return 0</span><br><span class="line">&#125;</span><br><span class="line">if math.Max(a, b) == a &#123;</span><br><span class="line">return 1</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return -1</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">f := Floater&#123;Accuracy: 0.000000000001&#125;</span><br><span class="line">var a float64 = 1.0000000002</span><br><span class="line">var b float64 = 1.0000000001</span><br><span class="line"></span><br><span class="line">fmt.Println(f.Bccomp(a, b)) //1</span><br><span class="line">fmt.Println(f.Bccomp(b, a)) //-1</span><br><span class="line">fmt.Println(f.Bccomp(a, a)) //0</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>顺便讲一下如何实现保留小数点后2位如何实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   //方法1</span><br><span class="line">a := 2.556</span><br><span class="line">v, _ := strconv.ParseFloat(fmt.Sprintf(&quot;%.2f&quot;, a), 64)</span><br><span class="line">fmt.Println(v)   //2.56</span><br><span class="line">   //方法2   </span><br><span class="line">v = math.Trunc(a*1e2+0.5) * 1e-2</span><br><span class="line">fmt.Println(v)   //2.56</span><br><span class="line"></span><br><span class="line">//方法3</span><br><span class="line">n10 := math.Pow10(2)</span><br><span class="line">v = math.Trunc((a+0.5/n10)*n10) / n10</span><br><span class="line">fmt.Println(v)</span><br></pre></td></tr></table></figure><h3 id="指针类型比较"><a href="#指针类型比较" class="headerlink" title="指针类型比较"></a>指针类型比较</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a := &quot;hello&quot;</span><br><span class="line">b := &amp;a</span><br><span class="line">c := &amp;a</span><br><span class="line">fmt.Println(b == c)</span><br></pre></td></tr></table></figure><p>当变量是相同或者都为nil时，指针值相等。</p><h3 id="interface类型比较"><a href="#interface类型比较" class="headerlink" title="interface类型比较"></a>interface类型比较</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">type I1 interface &#123;</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line">type I2 interface &#123;</span><br><span class="line">f()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type S1 struct &#123;</span><br><span class="line">name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s S1) f() &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type S2 struct &#123;</span><br><span class="line">name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (s S2) f() &#123;   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var a, b, c, d I1</span><br><span class="line">var e I2</span><br><span class="line">a = S1&#123;&quot;hello&quot;&#125;</span><br><span class="line">b = S1&#123;&quot;hello&quot;&#125;</span><br><span class="line">c = S1&#123;&quot;world&quot;&#125;</span><br><span class="line">d = S2&#123;&quot;hello&quot;&#125;</span><br><span class="line">fmt.Println(a == b) //true</span><br><span class="line">fmt.Println(a == c) //false</span><br><span class="line">fmt.Println(a == d) //false</span><br><span class="line">fmt.Println(a == e) //false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="比较-slice-x2F-struct-x2F-map"><a href="#比较-slice-x2F-struct-x2F-map" class="headerlink" title="比较 slice&#x2F;struct&#x2F;map"></a>比较 slice&#x2F;struct&#x2F;map</h3><p>这三个都可以用reflect.DeepEqual来判断是否相等</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;reflect&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type S struct &#123;</span><br><span class="line">s string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">s1 := S&#123;s: &quot;hello&quot;&#125;</span><br><span class="line">s2 := S&#123;s: &quot;hello&quot;&#125;</span><br><span class="line">if reflect.DeepEqual(s1, s2) &#123;</span><br><span class="line">fmt.Println(s1, &quot;==&quot;, s2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a1 := []int&#123;1, 2&#125;</span><br><span class="line">a2 := []int&#123;1, 2&#125;</span><br><span class="line">if reflect.DeepEqual(a1, a2) &#123;</span><br><span class="line">fmt.Println(a1, &quot;==&quot;, a2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m1 := map[int]string&#123;1: &quot;a&quot;, 2: &quot;b&quot;&#125;</span><br><span class="line">m2 := map[int]string&#123;1: &quot;a&quot;, 2: &quot;b&quot;&#125;</span><br><span class="line">if reflect.DeepEqual(m1, m2) &#123;</span><br><span class="line">fmt.Println(m1, &quot;==&quot;, m2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;9-13-Golang不同类型比较&quot;&gt;&lt;a href=&quot;#9-13-Golang不同类型比较&quot; class=&quot;headerlink&quot; title=&quot;9.13  Golang不同类型比较&quot;&gt;&lt;/a&gt;9.13  Golang不同类型比较&lt;/h1&gt;&lt;p&gt;在日常开发过程中</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>channel 实现原理分析</title>
    <link href="https://timmy6.github.io/2019/06/08/channel/"/>
    <id>https://timmy6.github.io/2019/06/08/channel/</id>
    <published>2019-06-08T13:05:10.000Z</published>
    <updated>2022-05-16T09:34:29.826Z</updated>
    
    <content type="html"><![CDATA[<p>#channel 实现原理分析</p><p>channel一个类型管道，通过它可以在goroutine之间发送和接收消息。它是Golang在语言层面提供的goroutine间的通信方式。</p><p>众所周知，Go依赖于称为CSP（Communicating Sequential Processes）的并发模型，通过Channel实现这种同步模式。Go并发的核心哲学是不要通过共享内存进行通信; 相反，通过沟通分享记忆。</p><p>下面以简单的示例来演示Go如何通过channel来实现通信。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line">func goRoutineA(a &lt;-chan int) &#123;</span><br><span class="line">val := &lt;-a</span><br><span class="line">fmt.Println(&quot;goRoutineA received the data&quot;, val)</span><br><span class="line">&#125;</span><br><span class="line">func goRoutineB(b chan int) &#123;</span><br><span class="line">val := &lt;-b</span><br><span class="line">fmt.Println(&quot;goRoutineB  received the data&quot;, val)</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">ch := make(chan int, 3)</span><br><span class="line">go goRoutineA(ch)</span><br><span class="line">go goRoutineB(ch)</span><br><span class="line">ch &lt;- 3</span><br><span class="line">time.Sleep(time.Second * 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果为：</p><p>goRoutineA received the data 3</p><p>上面只是个简单的例子，只输出goRoutineA ，没有执行goRoutineB，说明channel仅允许被一个goroutine读写。</p><p>说道channel这里不得不提通道的结构hchan。</p><h3 id="hchan"><a href="#hchan" class="headerlink" title="hchan"></a>hchan</h3><p>源代码在src&#x2F;runtime&#x2F;chan.go</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">type hchan struct &#123;</span><br><span class="line">   qcount   uint           // total data in the queue</span><br><span class="line">   dataqsiz uint           // size of the circular queue</span><br><span class="line">   buf      unsafe.Pointer // points to an array of dataqsiz elements</span><br><span class="line">   elemsize uint16</span><br><span class="line">   closed   uint32</span><br><span class="line">   elemtype *_type // element type</span><br><span class="line">   sendx    uint   // send index</span><br><span class="line">   recvx    uint   // receive index</span><br><span class="line">   recvq    waitq  // list of recv waiters</span><br><span class="line">   sendq    waitq  // list of send waiters</span><br><span class="line"></span><br><span class="line">   // lock protects all fields in hchan, as well as several</span><br><span class="line">   // fields in sudogs blocked on this channel.</span><br><span class="line">   //</span><br><span class="line">   // Do not change another G&#x27;s status while holding this lock</span><br><span class="line">   // (in particular, do not ready a G), as this can deadlock</span><br><span class="line">   // with stack shrinking.</span><br><span class="line">   lock mutex</span><br><span class="line">&#125;</span><br><span class="line">type waitq struct &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><p><strong>qcount</strong>   uint           &#x2F;&#x2F; 当前队列中剩余元素个数<br><strong>dataqsiz</strong> uint           &#x2F;&#x2F; 环形队列长度，即缓冲区的大小，即make（chan T，N），N.<br><strong>buf</strong>      unsafe.Pointer &#x2F;&#x2F; 环形队列指针<br><strong>elemsize</strong> uint16         &#x2F;&#x2F; 每个元素的大小<br><strong>closed</strong>   uint32        &#x2F;&#x2F; 表示当前通道是否处于关闭状态。创建通道后，该字段设置为0，即通道打开; 通过调用close将其设置为1，通道关闭。<br><strong>elemtype</strong> *_type         &#x2F;&#x2F; 元素类型，用于数据传递过程中的赋值；<br><strong>sendx <strong>uint和</strong>recvx</strong> uint是环形缓冲区的状态字段，它指示缓冲区的当前索引 - 支持数组，它可以从中发送数据和接收数据。<br><strong>recvq</strong>    waitq          &#x2F;&#x2F; 等待读消息的goroutine队列<br><strong>sendq</strong>    waitq          &#x2F;&#x2F; 等待写消息的goroutine队列<br><strong>lock</strong> mutex              &#x2F;&#x2F; 互斥锁，为每个读写操作锁定通道，因为发送和接收必须是互斥操作。</p><p>这里<strong>sudog代表goroutine。</strong></p><p>创建channel 有两种，一种是带缓冲的channel，一种是不带缓冲的channel</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 带缓冲</span><br><span class="line">ch := make(chan Task, 3)</span><br><span class="line">// 不带缓冲</span><br><span class="line">ch := make(chan int)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这里我们先讨论带缓冲</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch := make(chan int, 3)</span><br></pre></td></tr></table></figure><p>创建通道后的缓冲通道结构</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">hchan struct &#123;</span><br><span class="line">qcount uint : 0 </span><br><span class="line">dataqsiz uint : 3 </span><br><span class="line">buf unsafe.Pointer : 0xc00007e0e0 </span><br><span class="line">elemsize uint16 : 8 </span><br><span class="line">closed uint32 : 0 </span><br><span class="line">elemtype *runtime._type : &amp;&#123;</span><br><span class="line">size:8 </span><br><span class="line">ptrdata:0 </span><br><span class="line">hash:4149441018 </span><br><span class="line">tflag:7 </span><br><span class="line">align:8 </span><br><span class="line">fieldalign:8 </span><br><span class="line">kind:130 </span><br><span class="line">alg:0x55cdf0 </span><br><span class="line">gcdata:0x4d61b4 </span><br><span class="line">str:1055 </span><br><span class="line">ptrToThis:45152</span><br><span class="line">&#125;</span><br><span class="line">sendx uint : 0 </span><br><span class="line">recvx uint : 0 </span><br><span class="line">recvq runtime.waitq : </span><br><span class="line">&#123;first:&lt;nil&gt; last:&lt;nil&gt;&#125;</span><br><span class="line">sendq runtime.waitq : </span><br><span class="line">&#123;first:&lt;nil&gt; last:&lt;nil&gt;&#125;</span><br><span class="line">lock runtime.mutex : </span><br><span class="line">&#123;key:0&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func makechan(t *chantype, size int) *hchan &#123;</span><br><span class="line"></span><br><span class="line">   elem := t.elem</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们创建一个带buffer的channel，底层的数据模型如下图：</p><p><img src="/images/other/9.9.3.png"></p><h3 id="向channel写入数据"><a href="#向channel写入数据" class="headerlink" title="向channel写入数据"></a>向channel写入数据</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ch &lt;- 3</span><br></pre></td></tr></table></figure><p>底层hchan数据流程如图</p><p><img src="/images/other/9.9.5.png"><br><img src="/images/other/9.9.6.png"></p><p>发送操作概要</p><p>1、锁定整个通道结构。</p><p>2、确定写入。尝试<code>recvq</code>从等待队列中等待goroutine，然后将元素直接写入goroutine。</p><p>3、如果recvq为Empty，则确定缓冲区是否可用。如果可用，从当前goroutine复制数据到缓冲区。</p><p>4、如果缓冲区已满，<strong>则要</strong>写入的元素将保存在当前正在执行的goroutine的结构中，并且当前goroutine将在<strong>sendq中</strong>排队并从运行时挂起。</p><p>5、写入完成释放锁。</p><p>这里我们要注意几个属性buf、sendx、lock的变化。</p><p>流程图</p><p><img src="/images/other/9.9.9.png"></p><h3 id="从channel读取操作"><a href="#从channel读取操作" class="headerlink" title="从channel读取操作"></a>从channel读取操作</h3><p>几乎和写入操作相同</p><p>代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func goRoutineA(a &lt;-chan int) &#123;</span><br><span class="line">   val := &lt;-a</span><br><span class="line">   fmt.Println(&quot;goRoutineA received the data&quot;, val)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>底层hchan数据流程如图</p><p><img src="/images/other/9.9.7.png"></p><p><img src="/images/other/9.9.8.png"></p><p>这里我们要注意几个属性buf、sendx、recvx、lock的变化。</p><p>读取操作概要</p><p>1、先获取channel全局锁</p><p>2、尝试sendq从等待队列中获取等待的goroutine，</p><p>3、 如有等待的goroutine，没有缓冲区，取出goroutine并读取数据，然后唤醒这个goroutine，结束读取释放锁。</p><p>4、如有等待的goroutine，且有缓冲区（此时缓冲区已满），从缓冲区队首取出数据，再从sendq取出一个goroutine，将goroutine中的数据存入buf队尾，结束读取释放锁。</p><p>5、如没有等待的goroutine，且缓冲区有数据，直接读取缓冲区数据，结束读取释放锁。</p><p>6、如没有等待的goroutine，且没有缓冲区或缓冲区为空，将当前的goroutine加入recvq排队，进入睡眠，等待被写goroutine唤醒。结束读取释放锁。</p><p>流程图</p><p><img src="/images/other/9.9.10.png"></p><h3 id="recvq和sendq-结构"><a href="#recvq和sendq-结构" class="headerlink" title="recvq和sendq 结构"></a>recvq和sendq 结构</h3><p>recvq和sendq基本上是链表，看起来基本如下</p><p><img src="/images/other/9.9.11.jpeg"></p><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select就是用来监听和channel有关的IO操作，当 IO 操作发生时，触发相应的动作。</p><p>一个简单的示例如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">   &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func goRoutineD(ch chan int, i int) &#123;</span><br><span class="line">   time.Sleep(time.Second * 3)</span><br><span class="line">   ch &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">func goRoutineE(chs chan string, i string) &#123;</span><br><span class="line">   time.Sleep(time.Second * 3)</span><br><span class="line">   chs &lt;- i</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   ch := make(chan int, 5)</span><br><span class="line">   chs := make(chan string, 5)</span><br><span class="line"></span><br><span class="line">   go goRoutineD(ch, 5)</span><br><span class="line">   go goRoutineE(chs, &quot;ok&quot;)</span><br><span class="line"></span><br><span class="line">select &#123;</span><br><span class="line">case msg := &lt;-ch:</span><br><span class="line">fmt.Println(&quot; received the data &quot;, msg)</span><br><span class="line">case msgs := &lt;-chs:</span><br><span class="line">fmt.Println(&quot; received the data &quot;, msgs)</span><br><span class="line">default:</span><br><span class="line">fmt.Println(&quot;no data received &quot;)</span><br><span class="line">time.Sleep(time.Second * 1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，因为当前时间没有到3s，所以select 选择defult</p><p>no data received </p><p>修改程序，我们注释掉default，并多执行几次结果为</p><p> received the data  5</p><p>received the data  ok</p><p>received the data  ok</p><p>received the data  ok</p><p>select语句会阻塞，直到监测到一个可以执行的IO操作为止，而这里goRoutineD和goRoutineE睡眠时间是相同的，都是3s，从输出可看出，从channel中读出数据的顺序是随机的。</p><p>再修改代码，goRoutineD睡眠时间改成4s</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func goRoutineD(ch chan int, i int) &#123;</span><br><span class="line">   time.Sleep(time.Second * 4)</span><br><span class="line">   ch &lt;- i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此时会先执行goRoutineE，select 选择case msgs :&#x3D; &lt;-chs。</p><h3 id="range"><a href="#range" class="headerlink" title="range"></a>range</h3><p>可以持续从channel读取数据，一直到channel被关闭，当channel中没有数据时会阻塞当前goroutine，与读channel时阻塞处理机制一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">   &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func goRoutineD(ch chan int, i int) &#123;</span><br><span class="line">   for   i := 1; i &lt;= 5; i++&#123;</span><br><span class="line">      ch &lt;- i</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">func chanRange(chanName chan int) &#123;</span><br><span class="line">   for e := range chanName &#123;</span><br><span class="line">      fmt.Printf(&quot;Get element from chan: %d\n&quot;, e)</span><br><span class="line">      if len(chanName) &lt;= 0 &#123; // 如果现有数据量为0，跳出循环</span><br><span class="line">break</span><br><span class="line">  &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">func main() &#123;</span><br><span class="line">   ch := make(chan int, 5)</span><br><span class="line">   go goRoutineD(ch, 5)</span><br><span class="line">   chanRange(ch)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：<br>Get element from chan: 1<br>Get element from chan: 2<br>Get element from chan: 3<br>Get element from chan: 4<br>Get element from chan: 5</p><h3 id="死锁（deadlock）"><a href="#死锁（deadlock）" class="headerlink" title="死锁（deadlock）"></a>死锁（deadlock）</h3><p>指两个或两个以上的协程的执行过程中，由于竞争资源或由于彼此通信而造成的一种阻塞的现象。</p><p>在非缓冲信道若发生只流入不流出，或只流出不流入，就会发生死锁。</p><p>下面是一些死锁的例子</p><p>1、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   ch := make(chan int)</span><br><span class="line">   ch &lt;- 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面情况，向非缓冲通道写数据会发生阻塞，导致死锁。解决办法创建缓冲区 ch :&#x3D; make(chan int，3)</p><p>2、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   ch := make(chan int)</span><br><span class="line">   fmt.Println(&lt;-ch)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>向非缓冲通道读取数据会发生阻塞，导致死锁。 解决办法开启缓冲区，先向channel写入数据。</p><p>3、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   ch := make(chan int, 3)</span><br><span class="line">   ch &lt;- 3</span><br><span class="line">   ch &lt;- 4</span><br><span class="line">   ch &lt;- 5</span><br><span class="line">   ch &lt;- 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>写入数据超过缓冲区数量也会发生死锁。解决办法将写入数据取走。</p><p>死锁的情况有很多这里不再赘述。</p><p>还有一种情况，向关闭的channel写入数据，不会产生死锁，产生panic。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">ch := make(chan int, 3)</span><br><span class="line">ch &lt;- 1</span><br><span class="line">close(ch)</span><br><span class="line">ch &lt;- 2</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>解决办法别向关闭的channel写入数据。</p><p>参考：</p><p><a href="https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8">https://codeburst.io/diving-deep-into-the-golang-channels-549fd4ed21a8</a></p><p><a href="https://speakerdeck.com/kavya719/understanding-channels?slide=14">https://speakerdeck.com/kavya719/understanding-channels?slide=14</a></p><p><a href="https://my.oschina.net/renhc/blog/2246871">https://my.oschina.net/renhc/blog/2246871</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;#channel 实现原理分析&lt;/p&gt;
&lt;p&gt;channel一个类型管道，通过它可以在goroutine之间发送和接收消息。它是Golang在语言层面提供的goroutine间的通信方式。&lt;/p&gt;
&lt;p&gt;众所周知，Go依赖于称为CSP（Communicating Seque</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>匿名函数和闭包</title>
    <link href="https://timmy6.github.io/2019/06/02/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/"/>
    <id>https://timmy6.github.io/2019/06/02/%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0%E5%92%8C%E9%97%AD%E5%8C%85/</id>
    <published>2019-06-02T13:05:10.000Z</published>
    <updated>2022-05-16T07:06:13.501Z</updated>
    
    <content type="html"><![CDATA[<p>匿名函数：顾名思义就是没有名字的函数。很多语言都有如：java，js,php等，其中js最钟情。匿名函数最大的用途是来模拟块级作用域,避免数据污染的。</p><p>今天主要讲一下Golang语言的匿名函数和闭包。 </p><h3 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h3><p>示例：</p><p>1、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">   f:=func()&#123;</span><br><span class="line">      fmt.Println(&quot;hello world&quot;)</span><br><span class="line">   &#125;</span><br><span class="line">   f()//hello world</span><br><span class="line">   fmt.Printf(&quot;%T\n&quot;, f) //打印 func()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2、带参数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line">func main() &#123;</span><br><span class="line">   f:=func(args string)&#123;</span><br><span class="line">      fmt.Println(args)</span><br><span class="line">   &#125;</span><br><span class="line">   f(&quot;hello world&quot;)//hello world</span><br><span class="line">   //或</span><br><span class="line">   (func(args string)&#123;</span><br><span class="line">fmt.Println(args)</span><br><span class="line">&#125;)(&quot;hello world&quot;)//hello world</span><br><span class="line">//或</span><br><span class="line">func(args string) &#123;</span><br><span class="line">fmt.Println(args)</span><br><span class="line">&#125;(&quot;hello world&quot;) //hello world</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3、带返回值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   f:=func()string&#123;</span><br><span class="line">      return &quot;hello world&quot;</span><br><span class="line">   &#125;</span><br><span class="line">   a:=f()</span><br><span class="line">   fmt.Println(a)//hello world</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4、多个匿名函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   f1,f2:=F(1,2)</span><br><span class="line">   fmt.Println(f1(4))//6</span><br><span class="line">   fmt.Println(f2())//6</span><br><span class="line">&#125;</span><br><span class="line">func F(x, y int)(func(int)int,func()int) &#123;</span><br><span class="line">   f1 := func(z int) int &#123;</span><br><span class="line">      return (x + y) * z / 2</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   f2 := func() int &#123;</span><br><span class="line">      return 2 * (x + y)</span><br><span class="line">   &#125;</span><br><span class="line">   return f1,f2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="闭包（closure）"><a href="#闭包（closure）" class="headerlink" title="闭包（closure）"></a>闭包（closure）</h3><p>闭包：说白了就是函数的嵌套，内层的函数可以使用外层函数的所有变量，即使外层函数已经执行完毕。</p><p>示例：</p><p>1、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a := Fun()</span><br><span class="line">b:=a(&quot;hello &quot;)</span><br><span class="line">c:=a(&quot;hello &quot;)</span><br><span class="line">fmt.Println(b)//worldhello </span><br><span class="line">fmt.Println(c)//worldhello hello </span><br><span class="line">&#125;</span><br><span class="line">func Fun() func(string) string &#123;</span><br><span class="line">a := &quot;world&quot;</span><br><span class="line">return func(args string) string &#123;</span><br><span class="line">a += args</span><br><span class="line">return  a</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   a := Fun()</span><br><span class="line">   d := Fun()</span><br><span class="line">   b:=a(&quot;hello &quot;)</span><br><span class="line">   c:=a(&quot;hello &quot;)</span><br><span class="line">   e:=d(&quot;hello &quot;)</span><br><span class="line">   f:=d(&quot;hello &quot;)</span><br><span class="line">   fmt.Println(b)//worldhello </span><br><span class="line">   fmt.Println(c)//worldhello hello</span><br><span class="line">   fmt.Println(e)//worldhello</span><br><span class="line">   fmt.Println(f)//worldhello hello</span><br><span class="line">&#125;</span><br><span class="line">func Fun() func(string) string &#123;</span><br><span class="line">   a := &quot;world&quot;</span><br><span class="line">   return func(args string) string &#123;</span><br><span class="line">      a += args</span><br><span class="line">      return  a</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意两次调用F()，维护的不是同一个a变量。</p><p>3、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   a := F()</span><br><span class="line">   a[0]()//0xc00004c080 3</span><br><span class="line">   a[1]()//0xc00004c080 3</span><br><span class="line">   a[2]()//0xc00004c080 3</span><br><span class="line">&#125;</span><br><span class="line">func F() []func() &#123;</span><br><span class="line">   b := make([]func(), 3, 3)</span><br><span class="line">   for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">      b[i] = func() &#123;</span><br><span class="line">         fmt.Println(&amp;i,i)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>闭包通过引用的方式使用外部函数的变量。例中只调用了一次函数F,构成一个闭包，i 在外部函数B中定义，所以闭包维护该变量 i ，a[0]、a[1]、a[2]中的 i 都是闭包中 i 的引用。因此执行,i 的值已经变为3，故再调用a<a href="">0</a>时的输出是3而不是0。</p><p>4、如何避免上面的BUG ，用下面的方法，注意和上面示例对比。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a := F()</span><br><span class="line">a[0]() //0xc00000a0a8 0</span><br><span class="line">a[1]() //0xc00000a0c0 1</span><br><span class="line">a[2]() //0xc00000a0c8 2</span><br><span class="line">&#125;</span><br><span class="line">func F() []func() &#123;</span><br><span class="line">b := make([]func(), 3, 3)</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">b[i] = (func(j int) func() &#123;</span><br><span class="line">return func() &#123;</span><br><span class="line">fmt.Println(&amp;j, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;)(i)</span><br><span class="line">&#125;</span><br><span class="line">return b</span><br><span class="line">&#125;</span><br><span class="line">或者</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">a := F()</span><br><span class="line">a[0]() //0xc00004c080 0</span><br><span class="line">a[1]() //0xc00004c088 1</span><br><span class="line">a[2]() //0xc00004c090 2</span><br><span class="line">&#125;</span><br><span class="line">func F() []func() &#123;</span><br><span class="line">b := make([]func(), 3, 3)</span><br><span class="line">for i := 0; i &lt; 3; i++ &#123;</span><br><span class="line">j := i</span><br><span class="line">b[i] = func() &#123;</span><br><span class="line">fmt.Println(&amp;j, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return b</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>每次  操作仅将匿名函数放入到数组中，但并未执行，并且引用的变量都是 <code>i</code>，随着 <code>i</code> 的改变匿名函数中的 <code>i</code> 也在改变，所以当执行这些函数时，他们读取的都是环境变量 <code>i</code> 最后一次的值。解决的方法就是每次复制变量 <code>i</code> 然后传到匿名函数中，让闭包的环境变量不相同。</p><p>5、</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   fmt.Println(F())//2</span><br><span class="line">&#125;</span><br><span class="line">func F() (r int) &#123;</span><br><span class="line">   defer func() &#123;</span><br><span class="line">      r++</span><br><span class="line">   &#125;()</span><br><span class="line">   return 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为2，即先执行r&#x3D;1 ,再执行r++。</p><p>6、递归函数</p><p>还有一种情况就是必须用都闭包，就是递归函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func F(i int) int &#123;</span><br><span class="line">   if i &lt;= 1 &#123;</span><br><span class="line">      return 1</span><br><span class="line">   &#125;</span><br><span class="line">   return i * F(i-1)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   var i int = 3</span><br><span class="line">   fmt.Println(i, F(i))// 3 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>7、斐波那契数列(Fibonacci)</p><p>这个数列从第3项开始，每一项都等于前两项之和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func fibonaci(i int) int &#123;</span><br><span class="line">if i == 0 &#123;</span><br><span class="line">return 0</span><br><span class="line">&#125;</span><br><span class="line">if i == 1 &#123;</span><br><span class="line">return 1</span><br><span class="line">&#125;</span><br><span class="line">return fibonaci(i-1) + fibonaci(i-2)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var i int</span><br><span class="line">for i = 0; i &lt; 10; i++ &#123;</span><br><span class="line">fmt.Printf(&quot;%d\n&quot;, fibonaci(i))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小结："><a href="#小结：" class="headerlink" title="小结："></a>小结：</h3><p>匿名函数和闭包其实是一回事儿，匿名函数就是闭包。匿名函数给编程带来灵活性的同时也容易产生bug，在使用过程当中要多注意函数的参数，及可接受的参数的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;匿名函数：顾名思义就是没有名字的函数。很多语言都有如：java，js,php等，其中js最钟情。匿名函数最大的用途是来模拟块级作用域,避免数据污染的。&lt;/p&gt;
&lt;p&gt;今天主要讲一下Golang语言的匿名函数和闭包。 &lt;/p&gt;
&lt;h3 id=&quot;匿名函数&quot;&gt;&lt;a href=&quot;#</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>单例模式</title>
    <link href="https://timmy6.github.io/2019/05/22/single/"/>
    <id>https://timmy6.github.io/2019/05/22/single/</id>
    <published>2019-05-22T13:05:10.000Z</published>
    <updated>2022-05-16T06:49:47.526Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式是常用的模式之一，一般介绍的单例模式有  <code>饿汉式</code> 和 <code>懒汉式</code> 等，不管那种模式最终目的只有一个，就是只实例化一次，仅允许一个实例存在。</p><p>GO语言实现单例模式相对简单，这里考虑到并发，用到了sync.Mutex 和结构体sync.Once。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">   &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">   lock     *sync.Mutex = &amp;sync.Mutex&#123;&#125;</span><br><span class="line">   instance *Singleton</span><br><span class="line">)</span><br><span class="line">type Singleton struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func GetInstance() *Singleton &#123;</span><br><span class="line">   if instance == nil &#123;</span><br><span class="line">      lock.Lock()</span><br><span class="line">      defer lock.Unlock()</span><br><span class="line">      if instance == nil &#123;</span><br><span class="line">         instance = &amp;Singleton&#123;&#125;</span><br><span class="line">         fmt.Println(&quot;instance...&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   var s *Singleton</span><br><span class="line">   s = GetInstance()</span><br><span class="line">   s = GetInstance()</span><br><span class="line">   fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><p>instance…<br>&amp;{}</p><p>通过结果可以看到只输出了一个instance…。</p><p>上面的实现方式还可以通过结构体sync.Once更优雅的实现。</p><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">   &quot;sync&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">   once sync.Once</span><br><span class="line">   instance *Singleton</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type Singleton struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func GetInstance() *Singleton &#123;</span><br><span class="line">once.Do(func() &#123;</span><br><span class="line">instance = &amp;Singleton&#123;&#125;</span><br><span class="line">fmt.Println(&quot;instance...&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">   return instance</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">   var s *Singleton</span><br><span class="line">   s = GetInstance()</span><br><span class="line">   s = GetInstance()</span><br><span class="line">   fmt.Println(s)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><p>instance…<br>&amp;{}</p><p>通过sync.Once的源代码查看它是如何运行的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func (o *Once) Do(f func()) &#123;</span><br><span class="line">   if atomic.LoadUint32(&amp;o.done) == 1 &#123;</span><br><span class="line">      return</span><br><span class="line">   &#125;</span><br><span class="line">   // Slow-path.</span><br><span class="line">   o.m.Lock()</span><br><span class="line">   defer o.m.Unlock()</span><br><span class="line">   if o.done == 0 &#123;</span><br><span class="line">      defer atomic.StoreUint32(&amp;o.done, 1)</span><br><span class="line">      f()</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sync.Once.Do(f func())使用加锁原子操作（代码包sync&#x2F;atomic）来保证函数 f 只执行一次。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;单例模式是常用的模式之一，一般介绍的单例模式有  &lt;code&gt;饿汉式&lt;/code&gt; 和 &lt;code&gt;懒汉式&lt;/code&gt; 等，不管那种模式最终目的只有一个，就是只实例化一次，仅允许一个实例存在。&lt;/p&gt;
&lt;p&gt;GO语言实现单例模式相对简单，这里考虑到并发，用到了sync.M</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>GC垃圾回收机制</title>
    <link href="https://timmy6.github.io/2019/05/15/gc/"/>
    <id>https://timmy6.github.io/2019/05/15/gc/</id>
    <published>2019-05-15T15:05:10.000Z</published>
    <updated>2022-05-16T06:49:11.270Z</updated>
    
    <content type="html"><![CDATA[<p>垃圾回收(Garbage Collection，简称GC)是编程语言中提供的内存管理功能。</p><p>在传统的系统级编程语言（主要指C&#x2F;C++）中，程序员定义了一个变量，就是在内存中开辟了一段相应的空间来存值。由于内存是有限的，所以当程序不再需要使用某个变量的时候，就需要销毁该对象并释放其所占用的内存资源，好重新利用这段空间。在C&#x2F;C++中，释放无用变量内存空间的事情需要由程序员自己来处理。就是说当程序员认为变量没用了，就手动地释放其占用的内存。但是这样显然非常繁琐，如果有所遗漏，就可能造成资源浪费甚至<a href="https://baike.baidu.com/item/%E5%86%85%E5%AD%98%E6%B3%84%E9%9C%B2">内存泄露</a>。当软件系统比较复杂，变量多的时候程序员往往就忘记<a href="https://baike.baidu.com/item/%E9%87%8A%E6%94%BE%E5%86%85%E5%AD%98/10736171">释放内存</a>或者在不该释放的时候释放内存了。这对于程序开发人员是一个比较头痛的问题。</p><p>为了解决这个问题，后来开发出来的几乎所有新语言（java，python，php等等）都引入了语言层面的自动内存管理 – 也就是语言的使用者只用关注内存的申请而不必关心内存的释放，内存释放由虚拟机（virtual machine）或运行时（runtime）来自动进行管理。而这种对不再使用的内存资源进行自动回收的功能就被称为垃圾回收。</p><h3 id="垃圾回收常见的方法"><a href="#垃圾回收常见的方法" class="headerlink" title="垃圾回收常见的方法"></a>垃圾回收常见的方法</h3><p><strong>引用计数（reference counting）</strong></p><p>引用计数通过在对象上增加自己被引用的次数，被其他对象引用时加1，引用自己的对象被回收时减1，引用数为0的对象即为可以被回收的对象。这种算法在内存比较紧张和实时性比较高的系统中使用的比较广泛，如ios cocoa框架，php，python等。</p><p>优点：</p><p>1、方式简单，回收速度快。</p><p>缺点：</p><p>1、需要额外的空间存放计数。</p><p>2、无法处理循环引用（如a.b&#x3D;b;b.a&#x3D;a这种情况）。</p><p>3、频繁更新引用计数降低了性能。</p><p><strong>标记-清除（mark and sweep）</strong></p><p>该方法分为两步，标记从根变量开始迭代得遍历所有被引用的对象，对能够通过应用遍历访问到的对象都进行标记为“被引用”；标记完成后进行清除操作，对没有标记过的内存进行回收（回收同时可能伴有碎片整理操作）。这种方法解决了引用计数的不足，但是也有比较明显的问题：每次启动垃圾回收都会暂停当前所有的正常代码执行，回收是系统响应能力大大降低！当然后续也出现了很多mark&amp;sweep算法的变种（如三色标记法）优化了这个问题。</p><p><strong>复制收集</strong></p><p>复制收集的方式只需要对对象进行一次扫描。准备一个「新的空间」，从根开始，对对象进行扫，如果存在对这个对象的引用，就把它复制到「新空间中」。一次扫描结束之后，所有存在于「新空间」的对象就是所有的非垃圾对象。</p><p>这两种方式各有千秋，标记清除的方式节省内存但是两次扫描需要更多的时间，对于垃圾比例较小的情况占优势。复制收集更快速但是需要额外开辟一块用来复制的内存，对垃圾比例较大的情况占优势。特别的，复制收集有「局部性」的优点。</p><p>在复制收集的过程中，会按照对象被引用的顺序将对象复制到新空间中。于是，关系较近的对象被放在距离较近的内存空间的可能性会提高，这叫做局部性。局部性高的情况下，内存缓存会更有效地运作，程序的性能会提高。</p><p>对于标记清除，有一种标记-压缩算法的衍生算法：</p><p>对于压缩阶段，它的工作就是移动所有的可达对象到堆内存的同一个区域中，使他们紧凑的排列在一起，从而将所有非可达对象释放出来的空闲内存都集中在一起，通过这样的方式来达到减少内存碎片的目的。</p><p><strong>分代收集（generation）</strong></p><p>这种收集方式用了程序的一种特性：大部分对象会从产生开始在很短的时间内变成垃圾，而存在的很长时间的对象往往都有较长的生命周期。</p><p>根据对象的存活周期不同将内存划分为新生代和老年代，存活周期短的为新生代，存活周期长的为老年代。这样就可以根据每块内存的特点采用最适当的收集算法。 </p><p>新创建的对象存放在称为 新生代（young generation）中（一般来说，新生代的大小会比 老年代小很多）。高频对新生成的对象进行回收，称为「小回收」，低频对所有对象回收，称为「大回收」。每一次「小回收」过后，就把存活下来的对象归为老年代，「小回收」的时候，遇到老年代直接跳过。大多数分代回收算法都采用的「复制收集」方法，因为小回收中垃圾的比例较大。</p><p>这种方式存在一个问题：如果在某个新生代的对象中，存在「老生代」的对象对它的引用，它就不是垃圾了，那么怎么制止「小回收」对其回收呢？这里用到了一中叫做写屏障的方式。</p><p>程序对所有涉及修改对象内容的地方进行保护，被称为「写屏障」（Write Barrier）。写屏障不仅用于分代收集，也用于其他GC算法中。</p><p>在此算法的表现是，用一个记录集来记录从新生代到老生代的引用。如果有两个对象A和B，当对A的对象内容进行修改并加入B的引用时，如果①A是「老生代」②B是「新生代」。则将这个引用加入到记录集中。「小回收」的时候，因为记录集中有对B的引用，所以B不再是垃圾。</p><h5 id="三色标记算法"><a href="#三色标记算法" class="headerlink" title="三色标记算法"></a>三色标记算法</h5><p>三色标记算法是对标记阶段的改进，原理如下：</p><ol><li>起初所有对象都是白色。</li><li>从根出发扫描所有可达对象，标记为灰色，放入待处理队列。</li><li>从队列取出灰色对象，将其引用对象标记为灰色放入队列，自身标记为黑色。</li><li>重复 3，直到灰色对象队列为空。此时白色对象即为垃圾，进行回收。</li></ol><p>可视化如下。</p><p><img src="/images/other/9.6.1.gif?raw=true"></p><p>三色标记的一个明显好处是能够让用户程序和 mark 并发的进行，具体可以参考论文：《On-the-fly garbage collection: an exercise in cooperation.》。Golang 的 GC 实现也是基于这篇论文，后面再具体说明。</p><h2 id="GO的垃圾回收器"><a href="#GO的垃圾回收器" class="headerlink" title="GO的垃圾回收器"></a>GO的垃圾回收器</h2><p>go语言垃圾回收总体采用的是经典的mark and sweep算法。</p><ul><li><p>v1.3以前版本 STW（Stop The World）</p><p> golang的垃圾回收算法都非常简陋，然后其性能也广被诟病:go runtime在一定条件下（内存超过阈值或定期如2min），暂停所有任务的执行，进行mark&amp;sweep操作，操作完成后启动所有任务的执行。在内存使用较多的场景下，go程序在进行垃圾回收时会发生非常明显的卡顿现象（Stop The World）。在对响应速度要求较高的后台服务进程中，这种延迟简直是不能忍受的！这个时期国内外很多在生产环境实践go语言的团队都或多或少踩过gc的坑。当时解决这个问题比较常用的方法是尽快控制自动分配内存的内存数量以减少gc负荷，同时采用手动管理内存的方法处理需要大量及高频分配内存的场景。</p></li><li><p>v1.3 Mark STW, Sweep 并行</p><p>1.3版本中，go runtime分离了mark和sweep操作，和以前一样，也是先暂停所有任务执行并启动mark，mark完成后马上就重新启动被暂停的任务了，而是让sweep任务和普通协程任务一样并行的和其他任务一起执行。如果运行在多核处理器上，go会试图将gc任务放到单独的核心上运行而尽量不影响业务代码的执行。go team自己的说法是减少了50%-70%的暂停时间。</p></li><li><p>v1.5 三色标记法</p><p>go 1.5正在实现的垃圾回收器是“非分代的、非移动的、并发的、三色的标记清除垃圾收集器”。引入了上文介绍的三色标记法，这种方法的mark操作是可以渐进执行的而不需每次都扫描整个内存空间，可以减少stop the world的时间。 由此可以看到，一路走来直到1.5版本，go的垃圾回收性能也是一直在提升，但是相对成熟的垃圾回收系统（如java jvm和javascript v8），go需要优化的路径还很长（但是相信未来一定是美好的~）。</p></li><li><p>v1.8 混合写屏障（hybrid write barrier）</p><p>这个版本的 GC 代码相比之前改动还是挺大的，采用一种混合的 write barrier 方式 （Yuasa-style deletion write barrier [Yuasa ‘90] 和 Dijkstra-style insertion write barrier [Dijkstra ‘78]）来避免 堆栈重新扫描。</p><p>混合屏障的优势在于它允许堆栈扫描永久地使堆栈变黑（没有STW并且没有写入堆栈的障碍），这完全消除了堆栈重新扫描的需要，从而消除了对堆栈屏障的需求。重新扫描列表。特别是堆栈障碍在整个运行时引入了显着的复杂性，并且干扰了来自外部工具（如GDB和基于内核的分析器）的堆栈遍历。</p><p>此外，与Dijkstra风格的写屏障一样，混合屏障不需要读屏障，因此指针读取是常规的内存读取; 它确保了进步，因为物体单调地从白色到灰色再到黑色。</p><p>混合屏障的缺点很小。它可能会导致更多的浮动垃圾，因为它会在标记阶段的任何时刻保留从根（堆栈除外）可到达的所有内容。然而，在实践中，当前的Dijkstra障碍可能几乎保留不变。混合屏障还禁止某些优化：特别是，如果Go编译器可以静态地显示指针是nil，则Go编译器当前省略写屏障，但是在这种情况下混合屏障需要写屏障。这可能会略微增加二进制大小。</p></li></ul><p><strong>小结：</strong></p><p>通过go team多年对gc的不断改进和忧化，GC的卡顿问题在1.8 版本基本上可以做到 1 毫秒以下的 GC 级别。 实际上，gc低延迟是有代价的，其中最大的是吞吐量的下降。由于需要实现并行处理，线程间同步和多余的数据生成复制都会占用实际逻辑业务代码运行的时间。GHC的全局停止GC对于实现高吞吐量来说是十分合适的，而Go则更擅长与低延迟。<br>并行GC的第二个代价是不可预测的堆空间扩大。程序在GC的运行期间仍能不断分配任意大小的堆空间，因此我们需要在到达最大的堆空间之前实行一次GC，但是过早实行GC会造成不必要的GC扫描，这也是需要衡量利弊的。因此在使用Go时，需要自行保证程序有足够的内存空间。</p><p>垃圾收集是一个难题，没有所谓十全十美的方案，通常是为了适应应用场景做出的一种取舍。</p><p>相信GO未来会更好。</p><p>参考：</p><p><a href="https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md">https://github.com/golang/proposal/blob/master/design/17503-eliminate-rescan.md</a></p><p><a href="http://legendtkl.com/2017/04/28/golang-gc/">http://legendtkl.com/2017/04/28/golang-gc/</a></p><p><a href="https://blog.twitch.tv/gos-march-to-low-latency-gc-a6fa96f06eb7">https://blog.twitch.tv/gos-march-to-low-latency-gc-a6fa96f06eb7</a></p><p><a href="https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e">https://blog.plan99.net/modern-garbage-collection-911ef4f8bd8e</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;垃圾回收(Garbage Collection，简称GC)是编程语言中提供的内存管理功能。&lt;/p&gt;
&lt;p&gt;在传统的系统级编程语言（主要指C&amp;#x2F;C++）中，程序员定义了一个变量，就是在内存中开辟了一段相应的空间来存值。由于内存是有限的，所以当程序不再需要使用某个变量的</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>redis连接池</title>
    <link href="https://timmy6.github.io/2019/05/09/redis/"/>
    <id>https://timmy6.github.io/2019/05/09/redis/</id>
    <published>2019-05-09T15:05:10.000Z</published>
    <updated>2022-05-16T06:12:38.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go-Redis连接池"><a href="#Go-Redis连接池" class="headerlink" title="Go Redis连接池"></a>Go Redis连接池</h1><p>官方包  <a href="https://github.com/gomodule/redigo">https://github.com/gomodule/redigo</a></p><p><strong>1、创建配置文件</strong></p><p>存放在conf配置文件夹，可以跟你的需要存在相应。</p><p>redis.go</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package conf</span><br><span class="line"></span><br><span class="line">var RedisConf = map[string]string&#123;</span><br><span class="line">   &quot;name&quot;:    &quot;redis&quot;,</span><br><span class="line">   &quot;type&quot;:    &quot;tcp&quot;,</span><br><span class="line">   &quot;address&quot;: &quot;127.0.0.1:6379&quot;,</span><br><span class="line">   &quot;auth&quot;:    &quot;123456&quot;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、redis连接池"><a href="#2、redis连接池" class="headerlink" title="2、redis连接池"></a>2、redis连接池</h3><p>redispool.go  连接池实现</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">package redis</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   . &quot;example/example/conf&quot;   //改成你自己配置目录</span><br><span class="line">   &quot;github.com/garyburd/redigo/redis&quot;</span><br><span class="line">   &quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var RedisClient *redis.Pool</span><br><span class="line"></span><br><span class="line">func init() &#123;</span><br><span class="line">   // 建立连接池</span><br><span class="line">   RedisClient = &amp;redis.Pool&#123;</span><br><span class="line">      // 从配置文件获取maxidle以及maxactive，取不到则用后面的默认值</span><br><span class="line">      MaxIdle: 16, //最初的连接数量</span><br><span class="line">      // MaxActive:1000000,    //最大连接数量</span><br><span class="line">      MaxActive:   0,                 //连接池最大连接数量,不确定可以用0（0表示自动定义），按需分配</span><br><span class="line">      IdleTimeout: 300 * time.Second, //连接关闭时间 300秒 （300秒不使用自动关闭）</span><br><span class="line">      Dial: func() (redis.Conn, error) &#123; //要连接的redis数据库</span><br><span class="line">         c, err := redis.Dial(RedisConf[&quot;type&quot;], RedisConf[&quot;address&quot;])</span><br><span class="line">         if err != nil &#123;</span><br><span class="line">            return nil, err</span><br><span class="line">         &#125;</span><br><span class="line">         if _, err := c.Do(&quot;AUTH&quot;, RedisConf[&quot;auth&quot;]); err != nil &#123;</span><br><span class="line">            _=c.Close()</span><br><span class="line">            return nil, err</span><br><span class="line">         &#125;</span><br><span class="line">         return c, nil</span><br><span class="line">      &#125;,</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用示例："><a href="#使用示例：" class="headerlink" title="使用示例："></a>使用示例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">   &quot;example/example/public/redispool&quot;  //改成你自己的redispool.go(redis连接池实现文件)的目录</span><br><span class="line">   &quot;fmt&quot;</span><br><span class="line">   &quot;github.com/gomodule/redigo/redis&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var RedisExpire = 3600 //缓存有效期</span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">   // 从池里获取连接</span><br><span class="line">   rc := redispool.RedisClient.Get()</span><br><span class="line">   // 用完后将连接放回连接池</span><br><span class="line">   defer rc.Close()</span><br><span class="line">   key := &quot;redis.cache&quot;</span><br><span class="line">   _, err := rc.Do(&quot;Set&quot;, key, &quot;1&quot;, &quot;EX&quot;, RedisExpire)</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">      return</span><br><span class="line">   &#125;</span><br><span class="line">   val, err := redis.String(rc.Do(&quot;Get&quot;, key))</span><br><span class="line">   if err != nil &#123;</span><br><span class="line">      fmt.Println(err)</span><br><span class="line">   &#125;</span><br><span class="line">   fmt.Println(val)</span><br><span class="line">   //删除</span><br><span class="line">   rc.Do(&quot;Del&quot;, key)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go-Redis连接池&quot;&gt;&lt;a href=&quot;#Go-Redis连接池&quot; class=&quot;headerlink&quot; title=&quot;Go Redis连接池&quot;&gt;&lt;/a&gt;Go Redis连接池&lt;/h1&gt;&lt;p&gt;官方包  &lt;a href=&quot;https://github.com/g</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="redis" scheme="https://timmy6.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>路由中间件 - 签名验证</title>
    <link href="https://timmy6.github.io/2019/04/25/sign/"/>
    <id>https://timmy6.github.io/2019/04/25/sign/</id>
    <published>2019-04-25T15:05:10.000Z</published>
    <updated>2022-05-16T02:56:50.147Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>首先同步下项目概况：</p><p><img src="/images/gin/7_api_1.png"></p><p>上篇文章分享了，路由中间件 - Jaeger 链路追踪（实战篇），文章反响真是出乎意料， 「Go中国」 公众号也转发了，有很多朋友加我好友交流，直呼我大神，其实我哪是什么大神，只不过在本地实践了而已，对于 Go 语言的使用，我还是个新人，在这里感谢大家的厚爱！</p><p><img src="/images/gin/7_api_2.gif"></p><p>这篇文章咱们分享：路由中间件 - 签名验证。</p><p>为什么使用签名验证？</p><p>这个就不用多说了吧，主要是为了保证接口安全和识别调用方身份，基于这两点，咱们一起设计下签名。</p><p>调用方需要申请 App Key 和 App Secret，App Key 用来识别调用方身份，App Secret 用来加密生成签名使用。</p><p>当然生成的签名还需要满足以下几点：</p><ul><li>可变性：每次的签名必须是不一样的。</li><li>时效性：每次请求的时效性，过期作废。</li><li>唯一性：每次的签名是唯一的。</li><li>完整性：能够对传入数据进行验证，防止篡改。</li></ul><p>举个例子：</p><p><code>/api?param_1=xxx&amp;param_2=xxx</code>，其中 param_1 和 param_2 是两个参数。</p><p>如果增加了签名验证，需要再传递几个参数：</p><ul><li>ak 表示App Key，用来识别调用方身份。</li><li>ts 表示时间戳，用来验证接口的时效性。</li><li>sn 表示签名加密串，用来验证数据的完整性，防止数据篡改。</li></ul><p>sn 是通过 App Secret 和 传递的参数 进行加密的。</p><p>最终传递的参数如下：</p><p><code>/api?param_1=xxx&amp;param_2=xxx&amp;ak=xxx&amp;ts=xxx&amp;sn=xxx</code></p><p>在这要说一个调试技巧，ts 和 sn 参数每次都手动生成太麻烦了，当传递 <code>debug=1</code> 的时候，会返回 ts 和 sn , 具体看下代码就清楚了。</p><p>这篇文章分享三种实现签名的方式，分别是：MD5 组合加密、AES 对称加密、RSA 非对称加密。</p><p>废话不多说，进入主题。</p><h2 id="MD5-组合"><a href="#MD5-组合" class="headerlink" title="MD5 组合"></a>MD5 组合</h2><h4 id="生成签名"><a href="#生成签名" class="headerlink" title="生成签名"></a>生成签名</h4><p>首先，封装一个 Go 的 MD5 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func MD5(str string) string &#123;</span><br><span class="line">s := md5.New()</span><br><span class="line">s.Write([]byte(str))</span><br><span class="line">return hex.EncodeToString(s.Sum(nil))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行加密：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">appKey     = &quot;demo&quot;</span><br><span class="line">appSecret  = &quot;xxx&quot;</span><br><span class="line">encryptStr = &quot;param_1=xxx&amp;param_2=xxx&amp;ak=&quot;+appKey+&quot;&amp;ts=xxx&quot;</span><br><span class="line"></span><br><span class="line">// 自定义验证规则</span><br><span class="line">sn = MD5(appSecret + encryptStr + appSecret)</span><br></pre></td></tr></table></figure><h4 id="验证签名"><a href="#验证签名" class="headerlink" title="验证签名"></a>验证签名</h4><p>通过传递参数，再次生成签名，如果将传递的签名与生成的签名进行对比。</p><p>相同，表示签名验证成功。</p><p>不同，表示签名验证失败。</p><h4 id="中间件-代码实现"><a href="#中间件-代码实现" class="headerlink" title="中间件 - 代码实现"></a>中间件 - 代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">var AppSecret string</span><br><span class="line"></span><br><span class="line">// MD5 组合加密</span><br><span class="line">func SetUp() gin.HandlerFunc &#123;</span><br><span class="line"></span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line">utilGin := util.Gin&#123;Ctx: c&#125;</span><br><span class="line"></span><br><span class="line">sign, err := verifySign(c)</span><br><span class="line"></span><br><span class="line">if sign != nil &#123;</span><br><span class="line">utilGin.Response(-1, &quot;Debug Sign&quot;, sign)</span><br><span class="line">c.Abort()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">utilGin.Response(-1, err.Error(), sign)</span><br><span class="line">c.Abort()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.Next()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证签名</span><br><span class="line">func verifySign(c *gin.Context) (map[string]string, error) &#123;</span><br><span class="line">_ = c.Request.ParseForm()</span><br><span class="line">req   := c.Request.Form</span><br><span class="line">debug := strings.Join(c.Request.Form[&quot;debug&quot;], &quot;&quot;)</span><br><span class="line">ak    := strings.Join(c.Request.Form[&quot;ak&quot;], &quot;&quot;)</span><br><span class="line">sn    := strings.Join(c.Request.Form[&quot;sn&quot;], &quot;&quot;)</span><br><span class="line">ts    := strings.Join(c.Request.Form[&quot;ts&quot;], &quot;&quot;)</span><br><span class="line"></span><br><span class="line">// 验证来源</span><br><span class="line">value, ok := config.ApiAuthConfig[ak]</span><br><span class="line">if ok &#123;</span><br><span class="line">AppSecret = value[&quot;md5&quot;]</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return nil, errors.New(&quot;ak Error&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if debug == &quot;1&quot; &#123;</span><br><span class="line">currentUnix := util.GetCurrentUnix()</span><br><span class="line">req.Set(&quot;ts&quot;, strconv.FormatInt(currentUnix, 10))</span><br><span class="line">res := map[string]string&#123;</span><br><span class="line">&quot;ts&quot;: strconv.FormatInt(currentUnix, 10),</span><br><span class="line">&quot;sn&quot;: createSign(req),</span><br><span class="line">&#125;</span><br><span class="line">return res, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证过期时间</span><br><span class="line">timestamp := time.Now().Unix()</span><br><span class="line">exp, _    := strconv.ParseInt(config.AppSignExpiry, 10, 64)</span><br><span class="line">tsInt, _  := strconv.ParseInt(ts, 10, 64)</span><br><span class="line">if tsInt &gt; timestamp || timestamp - tsInt &gt;= exp &#123;</span><br><span class="line">return nil, errors.New(&quot;ts Error&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证签名</span><br><span class="line">if sn == &quot;&quot; || sn != createSign(req) &#123;</span><br><span class="line">return nil, errors.New(&quot;sn Error&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return nil, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建签名</span><br><span class="line">func createSign(params url.Values) string &#123;</span><br><span class="line">// 自定义 MD5 组合</span><br><span class="line">return util.MD5(AppSecret + createEncryptStr(params) + AppSecret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createEncryptStr(params url.Values) string &#123;</span><br><span class="line">var key []string</span><br><span class="line">var str = &quot;&quot;</span><br><span class="line">for k := range params &#123;</span><br><span class="line">if k != &quot;sn&quot; &amp;&amp; k != &quot;debug&quot; &#123;</span><br><span class="line">key = append(key, k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(key)</span><br><span class="line">for i := 0; i &lt; len(key); i++ &#123;</span><br><span class="line">if i == 0 &#123;</span><br><span class="line">str = fmt.Sprintf(&quot;%v=%v&quot;, key[i], params.Get(key[i]))</span><br><span class="line">&#125; else &#123;</span><br><span class="line">str = str + fmt.Sprintf(&quot;&amp;%v=%v&quot;, key[i], params.Get(key[i]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="AES-对称加密"><a href="#AES-对称加密" class="headerlink" title="AES 对称加密"></a>AES 对称加密</h2><p>在使用前，咱们先了解下什么是对称加密？</p><p>对称加密就是使用同一个密钥即可以加密也可以解密，这种方法称为对称加密。</p><p>常用算法：DES、AES。</p><p>其中 AES 是 DES 的升级版，密钥长度更长，选择更多，也更灵活，安全性更高，速度更快，咱们直接上手 AES 加密。</p><p><strong>优点</strong></p><p>算法公开、计算量小、加密速度快、加密效率高。</p><p><strong>缺点</strong></p><p>发送方和接收方必须商定好密钥，然后使双方都能保存好密钥，密钥管理成为双方的负担。</p><p><strong>应用场景</strong></p><p>相对大一点的数据量或关键数据的加密。</p><h4 id="生成签名-1"><a href="#生成签名-1" class="headerlink" title="生成签名"></a>生成签名</h4><p>首先，封装 Go 的 AesEncrypt 加密方法 和 AesDecrypt 解密方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">// 加密 aes_128_cbc</span><br><span class="line">func AesEncrypt (encryptStr string, key []byte, iv string) (string, error) &#123;</span><br><span class="line">encryptBytes := []byte(encryptStr)</span><br><span class="line">block, err   := aes.NewCipher(key)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return &quot;&quot;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blockSize := block.BlockSize()</span><br><span class="line">encryptBytes = pkcs5Padding(encryptBytes, blockSize)</span><br><span class="line"></span><br><span class="line">blockMode := cipher.NewCBCEncrypter(block, []byte(iv))</span><br><span class="line">encrypted := make([]byte, len(encryptBytes))</span><br><span class="line">blockMode.CryptBlocks(encrypted, encryptBytes)</span><br><span class="line">return base64.URLEncoding.EncodeToString(encrypted), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 解密</span><br><span class="line">func AesDecrypt (decryptStr string, key []byte, iv string) (string, error) &#123;</span><br><span class="line">decryptBytes, err := base64.URLEncoding.DecodeString(decryptStr)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return &quot;&quot;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">block, err := aes.NewCipher(key)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return &quot;&quot;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">blockMode := cipher.NewCBCDecrypter(block, []byte(iv))</span><br><span class="line">decrypted := make([]byte, len(decryptBytes))</span><br><span class="line"></span><br><span class="line">blockMode.CryptBlocks(decrypted, decryptBytes)</span><br><span class="line">decrypted = pkcs5UnPadding(decrypted)</span><br><span class="line">return string(decrypted), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func pkcs5Padding (cipherText []byte, blockSize int) []byte &#123;</span><br><span class="line">padding := blockSize - len(cipherText)%blockSize</span><br><span class="line">padText := bytes.Repeat([]byte&#123;byte(padding)&#125;, padding)</span><br><span class="line">return append(cipherText, padText...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func pkcs5UnPadding (decrypted []byte) []byte &#123;</span><br><span class="line">length := len(decrypted)</span><br><span class="line">unPadding := int(decrypted[length-1])</span><br><span class="line">return decrypted[:(length - unPadding)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进行加密：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appKey     = &quot;demo&quot;</span><br><span class="line">appSecret  = &quot;xxx&quot;</span><br><span class="line">encryptStr = &quot;param_1=xxx&amp;param_2=xxx&amp;ak=&quot;+appKey+&quot;&amp;ts=xxx&quot;</span><br><span class="line"></span><br><span class="line">sn = AesEncrypt(encryptStr, appSecret)</span><br></pre></td></tr></table></figure><h4 id="验证签名-1"><a href="#验证签名-1" class="headerlink" title="验证签名"></a>验证签名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decryptStr = AesDecrypt(sn, app_secret)</span><br></pre></td></tr></table></figure><p>将加密前的字符串与解密后的字符串做个对比。</p><p>相同，表示签名验证成功。</p><p>不同，表示签名验证失败。</p><h4 id="中间件-代码实现-1"><a href="#中间件-代码实现-1" class="headerlink" title="中间件 - 代码实现"></a>中间件 - 代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">var AppSecret string</span><br><span class="line"></span><br><span class="line">// AES 对称加密</span><br><span class="line">func SetUp() gin.HandlerFunc &#123;</span><br><span class="line"></span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line">utilGin := util.Gin&#123;Ctx: c&#125;</span><br><span class="line"></span><br><span class="line">sign, err := verifySign(c)</span><br><span class="line"></span><br><span class="line">if sign != nil &#123;</span><br><span class="line">utilGin.Response(-1, &quot;Debug Sign&quot;, sign)</span><br><span class="line">c.Abort()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">utilGin.Response(-1, err.Error(), sign)</span><br><span class="line">c.Abort()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.Next()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证签名</span><br><span class="line">func verifySign(c *gin.Context) (map[string]string, error) &#123;</span><br><span class="line">_ = c.Request.ParseForm()</span><br><span class="line">req   := c.Request.Form</span><br><span class="line">debug := strings.Join(c.Request.Form[&quot;debug&quot;], &quot;&quot;)</span><br><span class="line">ak    := strings.Join(c.Request.Form[&quot;ak&quot;], &quot;&quot;)</span><br><span class="line">sn    := strings.Join(c.Request.Form[&quot;sn&quot;], &quot;&quot;)</span><br><span class="line">ts    := strings.Join(c.Request.Form[&quot;ts&quot;], &quot;&quot;)</span><br><span class="line"></span><br><span class="line">// 验证来源</span><br><span class="line">value, ok := config.ApiAuthConfig[ak]</span><br><span class="line">if ok &#123;</span><br><span class="line">AppSecret = value[&quot;aes&quot;]</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return nil, errors.New(&quot;ak Error&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if debug == &quot;1&quot; &#123;</span><br><span class="line">currentUnix := util.GetCurrentUnix()</span><br><span class="line">req.Set(&quot;ts&quot;, strconv.FormatInt(currentUnix, 10))</span><br><span class="line"></span><br><span class="line">sn, err := createSign(req)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil, errors.New(&quot;sn Exception&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res := map[string]string&#123;</span><br><span class="line">&quot;ts&quot;: strconv.FormatInt(currentUnix, 10),</span><br><span class="line">&quot;sn&quot;: sn,</span><br><span class="line">&#125;</span><br><span class="line">return res, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证过期时间</span><br><span class="line">timestamp := time.Now().Unix()</span><br><span class="line">exp, _    := strconv.ParseInt(config.AppSignExpiry, 10, 64)</span><br><span class="line">tsInt, _  := strconv.ParseInt(ts, 10, 64)</span><br><span class="line">if tsInt &gt; timestamp || timestamp - tsInt &gt;= exp &#123;</span><br><span class="line">return nil, errors.New(&quot;ts Error&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证签名</span><br><span class="line">if sn == &quot;&quot; &#123;</span><br><span class="line">return nil, errors.New(&quot;sn Error&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">decryptStr, decryptErr := util.AesDecrypt(sn, []byte(AppSecret), AppSecret)</span><br><span class="line">if decryptErr != nil &#123;</span><br><span class="line">return nil, errors.New(decryptErr.Error())</span><br><span class="line">&#125;</span><br><span class="line">if decryptStr != createEncryptStr(req) &#123;</span><br><span class="line">return nil, errors.New(&quot;sn Error&quot;)</span><br><span class="line">&#125;</span><br><span class="line">return nil, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建签名</span><br><span class="line">func createSign(params url.Values) (string, error) &#123;</span><br><span class="line">return util.AesEncrypt(createEncryptStr(params), []byte(AppSecret), AppSecret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createEncryptStr(params url.Values) string &#123;</span><br><span class="line">var key []string</span><br><span class="line">var str = &quot;&quot;</span><br><span class="line">for k := range params &#123;</span><br><span class="line">if k != &quot;sn&quot; &amp;&amp; k != &quot;debug&quot; &#123;</span><br><span class="line">key = append(key, k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(key)</span><br><span class="line">for i := 0; i &lt; len(key); i++ &#123;</span><br><span class="line">if i == 0 &#123;</span><br><span class="line">str = fmt.Sprintf(&quot;%v=%v&quot;, key[i], params.Get(key[i]))</span><br><span class="line">&#125; else &#123;</span><br><span class="line">str = str + fmt.Sprintf(&quot;&amp;%v=%v&quot;, key[i], params.Get(key[i]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RSA-非对称加密"><a href="#RSA-非对称加密" class="headerlink" title="RSA 非对称加密"></a>RSA 非对称加密</h2><p>和上面一样，在使用前，咱们先了解下什么是非对称加密？</p><p>非对称加密就是需要两个密钥来进行加密和解密，这两个秘钥分别是公钥（public key）和私钥（private key），这种方法称为非对称加密。</p><p>常用算法：RSA。</p><p><strong>优点</strong></p><p>与对称加密相比，安全性更好，加解密需要不同的密钥，公钥和私钥都可进行相互的加解密。</p><p><strong>缺点</strong></p><p>加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p><p><strong>应用场景</strong></p><p>适合于对安全性要求很高的场景，适合加密少量数据，比如支付数据、登录数据等。</p><h4 id="创建签名"><a href="#创建签名" class="headerlink" title="创建签名"></a>创建签名</h4><p>首先，封装 Go 的 RsaPublicEncrypt 公钥加密方法 和 RsaPrivateDecrypt 解密方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">// 公钥加密</span><br><span class="line">func RsaPublicEncrypt(encryptStr string, path string) (string, error) &#123;</span><br><span class="line">// 打开文件</span><br><span class="line">file, err := os.Open(path)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return &quot;&quot;, err</span><br><span class="line">&#125;</span><br><span class="line">defer file.Close()</span><br><span class="line"></span><br><span class="line">// 读取文件内容</span><br><span class="line">info, _ := file.Stat()</span><br><span class="line">buf := make([]byte,info.Size())</span><br><span class="line">file.Read(buf)</span><br><span class="line"></span><br><span class="line">// pem 解码</span><br><span class="line">block, _ := pem.Decode(buf)</span><br><span class="line"></span><br><span class="line">// x509 解码</span><br><span class="line">publicKeyInterface, err := x509.ParsePKIXPublicKey(block.Bytes)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return &quot;&quot;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类型断言</span><br><span class="line">publicKey := publicKeyInterface.(*rsa.PublicKey)</span><br><span class="line"></span><br><span class="line">//对明文进行加密</span><br><span class="line">encryptedStr, err := rsa.EncryptPKCS1v15(rand.Reader, publicKey, []byte(encryptStr))</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return &quot;&quot;, err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//返回密文</span><br><span class="line">return base64.URLEncoding.EncodeToString(encryptedStr), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 私钥解密</span><br><span class="line">func RsaPrivateDecrypt(decryptStr string, path string) (string, error) &#123;</span><br><span class="line">// 打开文件</span><br><span class="line">file, err := os.Open(path)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return &quot;&quot;, err</span><br><span class="line">&#125;</span><br><span class="line">defer file.Close()</span><br><span class="line"></span><br><span class="line">// 获取文件内容</span><br><span class="line">info, _ := file.Stat()</span><br><span class="line">buf := make([]byte,info.Size())</span><br><span class="line">file.Read(buf)</span><br><span class="line"></span><br><span class="line">// pem 解码</span><br><span class="line">block, _ := pem.Decode(buf)</span><br><span class="line"></span><br><span class="line">// X509 解码</span><br><span class="line">privateKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return &quot;&quot;, err</span><br><span class="line">&#125;</span><br><span class="line">decryptBytes, err := base64.URLEncoding.DecodeString(decryptStr)</span><br><span class="line"></span><br><span class="line">//对密文进行解密</span><br><span class="line">decrypted, _ := rsa.DecryptPKCS1v15(rand.Reader,privateKey,decryptBytes)</span><br><span class="line"></span><br><span class="line">//返回明文</span><br><span class="line">return string(decrypted), nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>调用方 申请 公钥（public key），然后进行加密：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">appKey     = &quot;demo&quot;</span><br><span class="line">appSecret  = &quot;公钥&quot;</span><br><span class="line">encryptStr = &quot;param_1=xxx&amp;param_2=xxx&amp;ak=&quot;+appKey+&quot;&amp;ts=xxx&quot;</span><br><span class="line"></span><br><span class="line">sn = RsaPublicEncrypt(encryptStr, appSecret)</span><br></pre></td></tr></table></figure><h4 id="验证签名-2"><a href="#验证签名-2" class="headerlink" title="验证签名"></a>验证签名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">decryptStr = RsaPrivateDecrypt(sn, app_secret)</span><br></pre></td></tr></table></figure><p>将加密前的字符串与解密后的字符串做个对比。</p><p>相同，表示签名验证成功。</p><p>不同，表示签名验证失败。</p><h4 id="中间件-代码实现-2"><a href="#中间件-代码实现-2" class="headerlink" title="中间件 - 代码实现"></a>中间件 - 代码实现</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">var AppSecret string</span><br><span class="line"></span><br><span class="line">// RSA 非对称加密</span><br><span class="line">func SetUp() gin.HandlerFunc &#123;</span><br><span class="line"></span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line">utilGin := util.Gin&#123;Ctx: c&#125;</span><br><span class="line"></span><br><span class="line">sign, err := verifySign(c)</span><br><span class="line"></span><br><span class="line">if sign != nil &#123;</span><br><span class="line">utilGin.Response(-1, &quot;Debug Sign&quot;, sign)</span><br><span class="line">c.Abort()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">utilGin.Response(-1, err.Error(), sign)</span><br><span class="line">c.Abort()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.Next()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证签名</span><br><span class="line">func verifySign(c *gin.Context) (map[string]string, error) &#123;</span><br><span class="line">_ = c.Request.ParseForm()</span><br><span class="line">req   := c.Request.Form</span><br><span class="line">debug := strings.Join(c.Request.Form[&quot;debug&quot;], &quot;&quot;)</span><br><span class="line">ak    := strings.Join(c.Request.Form[&quot;ak&quot;], &quot;&quot;)</span><br><span class="line">sn    := strings.Join(c.Request.Form[&quot;sn&quot;], &quot;&quot;)</span><br><span class="line">ts    := strings.Join(c.Request.Form[&quot;ts&quot;], &quot;&quot;)</span><br><span class="line"></span><br><span class="line">// 验证来源</span><br><span class="line">value, ok := config.ApiAuthConfig[ak]</span><br><span class="line">if ok &#123;</span><br><span class="line">AppSecret = value[&quot;rsa&quot;]</span><br><span class="line">&#125; else &#123;</span><br><span class="line">return nil, errors.New(&quot;ak Error&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if debug == &quot;1&quot; &#123;</span><br><span class="line">currentUnix := util.GetCurrentUnix()</span><br><span class="line">req.Set(&quot;ts&quot;, strconv.FormatInt(currentUnix, 10))</span><br><span class="line"></span><br><span class="line">sn, err := createSign(req)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">return nil, errors.New(&quot;sn Exception&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res := map[string]string&#123;</span><br><span class="line">&quot;ts&quot;: strconv.FormatInt(currentUnix, 10),</span><br><span class="line">&quot;sn&quot;: sn,</span><br><span class="line">&#125;</span><br><span class="line">return res, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证过期时间</span><br><span class="line">timestamp := time.Now().Unix()</span><br><span class="line">exp, _    := strconv.ParseInt(config.AppSignExpiry, 10, 64)</span><br><span class="line">tsInt, _  := strconv.ParseInt(ts, 10, 64)</span><br><span class="line">if tsInt &gt; timestamp || timestamp - tsInt &gt;= exp &#123;</span><br><span class="line">return nil, errors.New(&quot;ts Error&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证签名</span><br><span class="line">if sn == &quot;&quot; &#123;</span><br><span class="line">return nil, errors.New(&quot;sn Error&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">decryptStr, decryptErr := util.RsaPrivateDecrypt(sn, config.AppRsaPrivateFile)</span><br><span class="line">if decryptErr != nil &#123;</span><br><span class="line">return nil, errors.New(decryptErr.Error())</span><br><span class="line">&#125;</span><br><span class="line">if decryptStr != createEncryptStr(req) &#123;</span><br><span class="line">return nil, errors.New(&quot;sn Error&quot;)</span><br><span class="line">&#125;</span><br><span class="line">return nil, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 创建签名</span><br><span class="line">func createSign(params url.Values) (string, error) &#123;</span><br><span class="line">return util.RsaPublicEncrypt(createEncryptStr(params), AppSecret)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func createEncryptStr(params url.Values) string &#123;</span><br><span class="line">var key []string</span><br><span class="line">var str = &quot;&quot;</span><br><span class="line">for k := range params &#123;</span><br><span class="line">if k != &quot;sn&quot; &amp;&amp; k != &quot;debug&quot; &#123;</span><br><span class="line">key = append(key, k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(key)</span><br><span class="line">for i := 0; i &lt; len(key); i++ &#123;</span><br><span class="line">if i == 0 &#123;</span><br><span class="line">str = fmt.Sprintf(&quot;%v=%v&quot;, key[i], params.Get(key[i]))</span><br><span class="line">&#125; else &#123;</span><br><span class="line">str = str + fmt.Sprintf(&quot;&amp;%v=%v&quot;, key[i], params.Get(key[i]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return str</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何调用？"><a href="#如何调用？" class="headerlink" title="如何调用？"></a>如何调用？</h2><p>与其他中间件调用方式一样，根据自己的需求自由选择。</p><p>比如，使用 MD5 组合：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.Use(sign_md5.SetUp())</span><br></pre></td></tr></table></figure><p>使用 AES 对称加密：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.Use(sign_aes.SetUp())</span><br></pre></td></tr></table></figure><p>使用 RSA 非对称加密：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.Use(sign_rsa.SetUp())</span><br></pre></td></tr></table></figure><h2 id="性能测试"><a href="#性能测试" class="headerlink" title="性能测试"></a>性能测试</h2><p>既然 RSA 非对称加密，最安全，那么统一都使用它吧。</p><p>NO！NO！NO！绝对不行！</p><p>为什么我要激动，因为我以前遇到过这个坑呀，都是血泪的教训呀…</p><p>咱们挨个测试下性能：</p><h4 id="MD5"><a href="#MD5" class="headerlink" title="MD5"></a>MD5</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func Md5Test(c *gin.Context) &#123;</span><br><span class="line">startTime  := time.Now()</span><br><span class="line">appSecret  := &quot;IgkibX71IEf382PT&quot;</span><br><span class="line">encryptStr := &quot;param_1=xxx&amp;param_2=xxx&amp;ak=xxx&amp;ts=1111111111&quot;</span><br><span class="line">count      := 1000000</span><br><span class="line">for i := 0; i &lt; count; i++ &#123;</span><br><span class="line">// 生成签名</span><br><span class="line">util.MD5(appSecret + encryptStr + appSecret)</span><br><span class="line"></span><br><span class="line">// 验证签名</span><br><span class="line">util.MD5(appSecret + encryptStr + appSecret)</span><br><span class="line">&#125;</span><br><span class="line">utilGin := util.Gin&#123;Ctx: c&#125;</span><br><span class="line">utilGin.Response(1, fmt.Sprintf(&quot;%v次 - %v&quot;, count, time.Since(startTime)), nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟 一百万 次请求，大概执行时长在 1.1s ~ 1.2s 左右。</p><h4 id="AES"><a href="#AES" class="headerlink" title="AES"></a>AES</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func AesTest(c *gin.Context) &#123;</span><br><span class="line">startTime  := time.Now()</span><br><span class="line">appSecret  := &quot;IgkibX71IEf382PT&quot;</span><br><span class="line">encryptStr := &quot;param_1=xxx&amp;param_2=xxx&amp;ak=xxx&amp;ts=1111111111&quot;</span><br><span class="line">count      := 1000000</span><br><span class="line">for i := 0; i &lt; count; i++ &#123;</span><br><span class="line">// 生成签名</span><br><span class="line">sn, _ := util.AesEncrypt(encryptStr, []byte(appSecret), appSecret)</span><br><span class="line"></span><br><span class="line">// 验证签名</span><br><span class="line">util.AesDecrypt(sn, []byte(appSecret), appSecret)</span><br><span class="line">&#125;</span><br><span class="line">utilGin := util.Gin&#123;Ctx: c&#125;</span><br><span class="line">utilGin.Response(1, fmt.Sprintf(&quot;%v次 - %v&quot;, count, time.Since(startTime)), nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>模拟 一百万 次请求，大概执行时长在 1.8s ~ 1.9s 左右。</p><h4 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func RsaTest(c *gin.Context) &#123;</span><br><span class="line">startTime  := time.Now()</span><br><span class="line">encryptStr := &quot;param_1=xxx&amp;param_2=xxx&amp;ak=xxx&amp;ts=1111111111&quot;</span><br><span class="line">count      := 500</span><br><span class="line">for i := 0; i &lt; count; i++ &#123;</span><br><span class="line">// 生成签名</span><br><span class="line">sn, _ := util.RsaPublicEncrypt(encryptStr, &quot;rsa/public.pem&quot;)</span><br><span class="line"></span><br><span class="line">// 验证签名</span><br><span class="line">util.RsaPrivateDecrypt(sn, &quot;rsa/private.pem&quot;)</span><br><span class="line">&#125;</span><br><span class="line">utilGin := util.Gin&#123;Ctx: c&#125;</span><br><span class="line">utilGin.Response(1, fmt.Sprintf(&quot;%v次 - %v&quot;, count, time.Since(startTime)), nil)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我不敢模拟 一百万 次请求，还不知道啥时候能搞定呢，咱们模拟 500 次试试。</p><p>模拟 500 次请求，大概执行时长在 1s 左右。</p><p>上面就是我本地的执行效果，大家可以质疑我的电脑性能差，封装的方法有问题…</p><p>你们也可以试试，看看性能差距是不是这么大。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概览&quot;&gt;&lt;a href=&quot;#概览&quot; class=&quot;headerlink&quot; title=&quot;概览&quot;&gt;&lt;/a&gt;概览&lt;/h2&gt;&lt;p&gt;首先同步下项目概况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/gin/7_api_1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上篇文章分享了，路</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="gin框架" scheme="https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>路由中间件 - Jaeger实战</title>
    <link href="https://timmy6.github.io/2019/04/19/gin-jaeger-demo/"/>
    <id>https://timmy6.github.io/2019/04/19/gin-jaeger-demo/</id>
    <published>2019-04-19T14:25:10.000Z</published>
    <updated>2022-05-16T02:49:35.743Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先同步下项目概况：</p><p><img src="/images/gin/6_api_1.png"></p><p>上篇文章分享了，路由中间件 - Jaeger 链路追踪（理论篇），这篇文章咱们接着分享：路由中间件 - Jaeger 链路追踪（实战篇）。</p><p>这篇文章，确实让大家久等了，主要是里面有一些技术点都是刚刚研究的，没有存货。</p><p><img src="/images/gin/6_api_6.png"></p><p>先看下咱们要实现的东西：</p><p><img src="/images/gin/6_api_2.png"></p><p>API 调用了 5 个服务，其中 4 个 gRPC 服务，1 个 HTTP 服务，服务与服务之间又相互调用：</p><ul><li>Speak 服务，又调用了 Listen 服务 和 Sing 服务。</li><li>Read 服务，又调用了 Listen 服务 和 Sing 服务。</li><li>Write 服务，又调用了 Listen 服务 和 Sing 服务。</li></ul><p>咱们要实现的就是查看 API 调用的链路。</p><p>关于一些理论的东西，大家可以去看看上篇文章或查阅一些资料，这篇文章就是实现怎么用。</p><p>OK，开整。</p><h2 id="Jaeger-部署"><a href="#Jaeger-部署" class="headerlink" title="Jaeger 部署"></a>Jaeger 部署</h2><p>咱们使用 All in one 的方式，进行本地部署。</p><p>下载地址：<a href="https://www.jaegertracing.io/download/">https://www.jaegertracing.io/download/</a></p><p>我的电脑是 macOS 选择 -&gt; Binaries -&gt; macOS</p><p>下载后并解压，会发现以下文件：</p><ul><li>example-hotrod</li><li>jaeger-agent</li><li>jaeger-all-in-one</li><li>jaeger-collector</li><li>jaeger-ingester</li><li>jaeger-query</li></ul><p>进入到解压后的目录执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./jaeger-all-in-one</span><br></pre></td></tr></table></figure><p>目测启动后，访问地址：</p><p><a href="http://127.0.0.1:16686/">http://127.0.0.1:16686/</a></p><p><img src="/images/gin/6_api_3.png"></p><p>到这，Jaeger 已经部署成功了。</p><h2 id="准备测试服务"><a href="#准备测试服务" class="headerlink" title="准备测试服务"></a>准备测试服务</h2><p>准备的五个测试服务如下：</p><h4 id="听（listen）"><a href="#听（listen）" class="headerlink" title="听（listen）"></a>听（listen）</h4><ul><li>端口：9901</li><li>通讯：gRPC</li></ul><h4 id="说（speak）"><a href="#说（speak）" class="headerlink" title="说（speak）"></a>说（speak）</h4><ul><li>端口：9902</li><li>通讯：gRPC</li></ul><h4 id="读（read）"><a href="#读（read）" class="headerlink" title="读（read）"></a>读（read）</h4><ul><li>端口：9903</li><li>通讯：gRPC</li></ul><h4 id="写（write）"><a href="#写（write）" class="headerlink" title="写（write）"></a>写（write）</h4><ul><li>端口：9904</li><li>通讯：gRPC</li></ul><h4 id="唱（sing）"><a href="#唱（sing）" class="headerlink" title="唱（sing）"></a>唱（sing）</h4><ul><li>端口：9905</li><li>通讯：HTTP</li></ul><p>听、说、读、写、唱，想这几个服务的名称就花了好久 ~ </p><p>我默认大家都会写 grpc 服务，如果不会写的，可以查看下我原来的文章《<a href="https://timmy6.github.io/2018/09/20/grpc1/">Go gRPC Hello World</a>》。</p><h2 id="应用示例"><a href="#应用示例" class="headerlink" title="应用示例"></a>应用示例</h2><h4 id="实例化-Tracer"><a href="#实例化-Tracer" class="headerlink" title="实例化 Tracer"></a>实例化 Tracer</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">func NewJaegerTracer(serviceName string, jaegerHostPort string) (opentracing.Tracer, io.Closer, error) &#123;</span><br><span class="line"></span><br><span class="line">cfg := &amp;jaegerConfig.Configuration &#123;</span><br><span class="line">Sampler: &amp;jaegerConfig.SamplerConfig&#123;</span><br><span class="line">Type  : &quot;const&quot;, //固定采样</span><br><span class="line">Param : 1,       //1=全采样、0=不采样</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">Reporter: &amp;jaegerConfig.ReporterConfig&#123;</span><br><span class="line">LogSpans           : true,</span><br><span class="line">LocalAgentHostPort : jaegerHostPort,</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">ServiceName: serviceName,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tracer, closer, err := cfg.NewTracer(jaegerConfig.Logger(jaeger.StdLogger))</span><br><span class="line">if err != nil &#123;</span><br><span class="line">panic(fmt.Sprintf(&quot;ERROR: cannot init Jaeger: %v\n&quot;, err))</span><br><span class="line">&#125;</span><br><span class="line">opentracing.SetGlobalTracer(tracer)</span><br><span class="line">return tracer, closer, err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HTTP-注入"><a href="#HTTP-注入" class="headerlink" title="HTTP 注入"></a>HTTP 注入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">injectErr := jaeger.Tracer.Inject(span.Context(), opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(req.Header))</span><br><span class="line">if injectErr != nil &#123;</span><br><span class="line">log.Fatalf(&quot;%s: Couldn&#x27;t inject headers&quot;, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HTTP-拦截"><a href="#HTTP-拦截" class="headerlink" title="HTTP 拦截"></a>HTTP 拦截</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">spCtx, err := opentracing.GlobalTracer().Extract(opentracing.HTTPHeaders, opentracing.HTTPHeadersCarrier(c.Request.Header))</span><br><span class="line">if err != nil &#123;</span><br><span class="line">ParentSpan = Tracer.StartSpan(c.Request.URL.Path)</span><br><span class="line">defer ParentSpan.Finish()</span><br><span class="line">&#125; else &#123;</span><br><span class="line">ParentSpan = opentracing.StartSpan(</span><br><span class="line">c.Request.URL.Path,</span><br><span class="line">opentracing.ChildOf(spCtx),</span><br><span class="line">opentracing.Tag&#123;Key: string(ext.Component), Value: &quot;HTTP&quot;&#125;,</span><br><span class="line">ext.SpanKindRPCServer,</span><br><span class="line">)</span><br><span class="line">defer ParentSpan.Finish()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="gRPC-注入"><a href="#gRPC-注入" class="headerlink" title="gRPC 注入"></a>gRPC 注入</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">func ClientInterceptor(tracer opentracing.Tracer, spanContext opentracing.SpanContext) grpc.UnaryClientInterceptor &#123;</span><br><span class="line">return func(ctx context.Context, method string,</span><br><span class="line">req, reply interface&#123;&#125;, cc *grpc.ClientConn,</span><br><span class="line">invoker grpc.UnaryInvoker, opts ...grpc.CallOption) error &#123;</span><br><span class="line"></span><br><span class="line">span := opentracing.StartSpan(</span><br><span class="line">&quot;call gRPC&quot;,</span><br><span class="line">opentracing.ChildOf(spanContext),</span><br><span class="line">opentracing.Tag&#123;Key: string(ext.Component), Value: &quot;gRPC&quot;&#125;,</span><br><span class="line">ext.SpanKindRPCClient,</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">defer span.Finish()</span><br><span class="line"></span><br><span class="line">md, ok := metadata.FromOutgoingContext(ctx)</span><br><span class="line">if !ok &#123;</span><br><span class="line">md = metadata.New(nil)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">md = md.Copy()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err := tracer.Inject(span.Context(), opentracing.TextMap, MDReaderWriter&#123;md&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">span.LogFields(log.String(&quot;inject-error&quot;, err.Error()))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">newCtx := metadata.NewOutgoingContext(ctx, md)</span><br><span class="line">err = invoker(newCtx, method, req, reply, cc, opts...)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">span.LogFields(log.String(&quot;call-error&quot;, err.Error()))</span><br><span class="line">&#125;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="gRPC-拦截"><a href="#gRPC-拦截" class="headerlink" title="gRPC 拦截"></a>gRPC 拦截</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func serverInterceptor(tracer opentracing.Tracer) grpc.UnaryServerInterceptor &#123;</span><br><span class="line">return func(ctx context.Context,</span><br><span class="line">req interface&#123;&#125;,</span><br><span class="line">info *grpc.UnaryServerInfo,</span><br><span class="line">handler grpc.UnaryHandler) (resp interface&#123;&#125;, err error) &#123;</span><br><span class="line"></span><br><span class="line">md, ok := metadata.FromIncomingContext(ctx)</span><br><span class="line">if !ok &#123;</span><br><span class="line">md = metadata.New(nil)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">spanContext, err := tracer.Extract(opentracing.TextMap, MDReaderWriter&#123;md&#125;)</span><br><span class="line">if err != nil &amp;&amp; err != opentracing.ErrSpanContextNotFound &#123;</span><br><span class="line">grpclog.Errorf(&quot;extract from metadata err: %v&quot;, err)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">span := tracer.StartSpan(</span><br><span class="line">info.FullMethod,</span><br><span class="line">ext.RPCServerOption(spanContext),</span><br><span class="line">opentracing.Tag&#123;Key: string(ext.Component), Value: &quot;gRPC&quot;&#125;,</span><br><span class="line">ext.SpanKindRPCServer,</span><br><span class="line">)</span><br><span class="line">defer span.Finish()</span><br><span class="line"></span><br><span class="line">ParentContext = opentracing.ContextWithSpan(ctx, span)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return handler(ParentContext, req)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面是一些核心的代码，涉及到的全部代码我都会上传到 github，供下载。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// 启动 Listen 服务</span><br><span class="line">cd listen &amp;&amp; go run main.go</span><br><span class="line"></span><br><span class="line">// 启动 Speak 服务</span><br><span class="line">cd speak &amp;&amp; go run main.go</span><br><span class="line"></span><br><span class="line">// 启动 Read 服务</span><br><span class="line">cd read &amp;&amp; go run main.go</span><br><span class="line"></span><br><span class="line">// 启动 Write 服务</span><br><span class="line">cd write &amp;&amp; go run main.go</span><br><span class="line"></span><br><span class="line">// 启动 Sing 服务</span><br><span class="line">cd sing &amp;&amp; go run main.go</span><br><span class="line"></span><br><span class="line">// 启动 go-gin-api 服务</span><br><span class="line">cd go-gin-api &amp;&amp; go run main.go</span><br></pre></td></tr></table></figure><h4 id="访问路由"><a href="#访问路由" class="headerlink" title="访问路由"></a>访问路由</h4><p><a href="http://127.0.0.1:9999/jaeger_test">http://127.0.0.1:9999/jaeger_test</a></p><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/images/gin/6_api_4.png"></p><p><img src="/images/gin/6_api_5.png"></p><p>就到这吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先同步下项目概况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/gin/6_api_1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上篇文章分享了，路</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="gin框架" scheme="https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>路由中间件 - 链路追踪</title>
    <link href="https://timmy6.github.io/2019/04/09/gin-jaeger/"/>
    <id>https://timmy6.github.io/2019/04/09/gin-jaeger/</id>
    <published>2019-04-09T14:15:20.000Z</published>
    <updated>2022-05-16T02:44:05.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先同步下项目概况：</p><p><img src="/images/gin/5_api_1.png"></p><p>上篇文章分享了，路由中间件 - 捕获异常，这篇文章咱们分享：路由中间件 - Jaeger 链路追踪。</p><p>啥是链路追踪？</p><p>我理解链路追踪其实是为微服务架构提供服务的，当一个请求中，请求了多个服务单元，如果请求出现了错误或异常，很难去定位是哪个服务出了问题，这时就需要链路追踪。</p><p>咱们先看一张图：</p><p><img src="/images/gin/5_api_2.png"></p><p>这张图的调用链还比较清晰，咱们想象一下，随着服务的越来越多，服务与服务之间调用关系也越来越多，可能就会发展成下图的情况。</p><p><img src="/images/gin/5_api_3.png"></p><p>这调用关系真的是… 看到这，我的内心是崩溃的。</p><p><img src="/images/gin/5_api_4.jpeg"></p><p>那么问题来了，这种情况下怎么快速定位问题？</p><h2 id="如何设计日志记录？"><a href="#如何设计日志记录？" class="headerlink" title="如何设计日志记录？"></a>如何设计日志记录？</h2><p>我们自己也可以设计一个链路追踪，比如当发生一个请求，咱们记录它的：</p><ul><li>请求的唯一标识</li><li>请求了哪些服务？</li><li>请求的服务依次顺序？</li><li>请求的 Request 和 Response 日志？</li><li>对日志进行收集、整理，并友好展示</li></ul><p>怎么去实现请求的唯一标识？</p><p><strong>以 Go 为例</strong> 写一个中间件，在每次请求的 Header 中包含：X-Request-Id，代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func SetUp() gin.HandlerFunc &#123;</span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line">requestId := c.Request.Header.Get(&quot;X-Request-Id&quot;)</span><br><span class="line">if requestId == &quot;&quot; &#123;</span><br><span class="line">requestId = util.GenUUID()</span><br><span class="line">&#125;</span><br><span class="line">c.Set(&quot;X-Request-Id&quot;, requestId)</span><br><span class="line">c.Writer.Header().Set(&quot;X-Request-Id&quot;, requestId)</span><br><span class="line">c.Next()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个 Request 和 Response 日志中都要包含 X-Request-Id。</p><p>问题又来了，每次调用都记录日志，当调用的服务过多时，频繁的记录日志，就会有性能问题呀，肿么办？</p><p><img src="/images/gin/5_api_5.jpeg"></p><p>哎，这么麻烦，看看市面上有没有一些开源工具呢？</p><h2 id="开源工具"><a href="#开源工具" class="headerlink" title="开源工具"></a>开源工具</h2><ul><li>Jaeger：<a href="https://www.jaegertracing.io/">https://www.jaegertracing.io</a></li><li>Zipkin：<a href="https://zipkin.io/">https://zipkin.io/</a></li><li>Appdash：<a href="https://about.sourcegraph.com/">https://about.sourcegraph.com/</a></li></ul><p>这个就不多做介绍了，基本上都能满足需求，至于优缺点，大家可以挨个去瞅瞅，喜欢哪个就用哪个？</p><p><strong>我为什么选择 Jaeger</strong> ？</p><p>因为我目前只会用这个，其他还不会 … </p><p>咱们一起看下 Jaeger 是怎么回事吧。</p><h2 id="Jaeger-架构图"><a href="#Jaeger-架构图" class="headerlink" title="Jaeger 架构图"></a>Jaeger 架构图</h2><p><img src="/images/gin/5_api_6.png"></p><p>图片来源于官网。</p><p>简单介绍下上图三个关键组件：</p><p><strong>Agent</strong></p><p>Agent是一个网络守护进程，监听通过UDP发送过来的Span，它会将其批量发送给collector。按照设计，Agent要被部署到所有主机上，作为基础设施。Agent将collector和客户端之间的路由与发现机制抽象了出来。</p><p><strong>Collector</strong></p><p>Collector从Jaeger Agent接收Trace，并通过一个处理管道对其进行处理。目前的管道会校验Trace、建立索引、执行转换并最终进行存储。存储是一个可插入的组件，现在支持Cassandra和elasticsearch。</p><p><strong>Query</strong></p><p>Query服务会从存储中检索Trace并通过UI界面进行展现，该UI界面通过React技术实现，其页面UI如下图所示，展现了一条Trace的详细信息。</p><p>其他组件，大家可以了解下并选择性使用。</p><h2 id="Jaeger-Span"><a href="#Jaeger-Span" class="headerlink" title="Jaeger Span"></a>Jaeger Span</h2><p><img src="/images/gin/5_api_7.png"></p><p>图片来源于官网。</p><p>怎么操作 Span 呢？Span 有哪些可以调用的 API ？</p><p><img src="/images/gin/5_api_8.png"></p><h2 id="Jaeger-部署"><a href="#Jaeger-部署" class="headerlink" title="Jaeger 部署"></a>Jaeger 部署</h2><p><strong>All in one</strong></p><p>为了方便大家快速使用，Jaeger 直接提供一个 All in one 包，我们可以直接执行，启动一套完整的 Jaeger tracing 系统。</p><p>启动成功后，访问 <a href="http://localhost:16686/">http://localhost:16686</a> 就可以看到 Jaeger UI。</p><p><strong>独立部署</strong></p><ul><li>jaeger-agent</li><li>jaeger-collector</li><li>jaeger-query</li><li>jaeger-ingester</li><li>jaeger-operator</li><li>jaeger-cassandra-schema</li><li>jaeger-es-index-cleaner</li><li>spark-dependencies</li></ul><p>可以自由搭配，组合使用。</p><h2 id="Jaeger-端口"><a href="#Jaeger-端口" class="headerlink" title="Jaeger 端口"></a>Jaeger 端口</h2><ul><li><p>端口：6831 </p></li><li><p>协议：UDP </p></li><li><p>所属模块：Agent</p></li><li><p>功能：通过兼容性 Thrift 协议，接收 Jaeger thrift 类型数据</p></li><li><p>端口：14267 </p></li><li><p>协议：HTTP </p></li><li><p>所属模块：Collector</p></li><li><p>功能：接收客户端 Jaeger thrift 类型数据</p></li><li><p>端口：16686 </p></li><li><p>协议：HTTP </p></li><li><p>所属模块：Query</p></li><li><p>功能：客户端前端界面展示端口</p></li></ul><h2 id="Jaeger-采样率"><a href="#Jaeger-采样率" class="headerlink" title="Jaeger 采样率"></a>Jaeger 采样率</h2><p>分布式追踪系统本身也会造成一定的性能低损耗，如果完整记录每次请求，对于生产环境可能会有极大的性能损耗，一般需要进行采样设置。</p><p><strong>固定采样</strong></p><p>（sampler.type&#x3D;const）</p><ul><li>sampler.param&#x3D;1 全采样， </li><li>sampler.param&#x3D;0 不采样；</li></ul><p><strong>按百分比采样</strong></p><p>（sampler.type&#x3D;probabilistic）</p><ul><li>sampler.param&#x3D;0.1 则随机采十分之一的样本；</li></ul><p><strong>采样速度限制</strong></p><p>（sampler.type&#x3D;ratelimiting）</p><ul><li>sampler.param&#x3D;2.0 每秒采样两个traces；</li></ul><p><strong>动态获取采样率</strong> </p><p>（sampler.type&#x3D;remote）</p><ul><li>这个是默认配置，可以通过配置从 Agent 中获取采样率的动态设置。</li></ul><h2 id="Jaeger-缺点"><a href="#Jaeger-缺点" class="headerlink" title="Jaeger 缺点"></a>Jaeger 缺点</h2><ul><li>接入过程有一定的侵入性；</li><li>本身缺少监控和报警机制，需要结合第三方工具来实现，比如配合Grafana 和 Prometheus实现；</li></ul><p>看到这，说的都是理论，大家的心里话可能是：</p><p><img src="/images/gin/5_api_9.jpg"></p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><ul><li>Jaeger 部署</li><li>Jaeger 在 Gin 中使用</li><li>Jaeger 在 gRPC 中使用</li></ul><p><img src="/images/gin/5_api_10.jpeg"></p><p>关于实战的分享，我准备整理出 4 个服务，然后实现服务与服务之间进行相互调用，目前 Demo 还没写完…</p><p>下篇文章再给大家分享。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先同步下项目概况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/gin/5_api_1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上篇文章分享了，路</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="gin框架" scheme="https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>路由中间件 - 捕获异常</title>
    <link href="https://timmy6.github.io/2019/03/25/catch-error/"/>
    <id>https://timmy6.github.io/2019/03/25/catch-error/</id>
    <published>2019-03-25T13:25:20.000Z</published>
    <updated>2022-05-13T09:46:42.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先同步下项目概况：</p><p><img src="/images/gin/4_api_1.png"></p><p>上篇文章分享了，路由中间件 - 日志记录，这篇文章咱们分享：路由中间件 - 捕获异常。当系统发生异常时，提示 “系统异常，请联系管理员！”，同时并发送 panic 告警邮件。</p><p><img src="/images/gin/4_api_2.png"></p><h2 id="什么是异常？"><a href="#什么是异常？" class="headerlink" title="什么是异常？"></a>什么是异常？</h2><p>在 Go 中异常就是 panic，它是在程序运行的时候抛出的，当 panic 抛出之后，如果在程序里没有添加任何保护措施的话，控制台就会在打印出 panic 的详细情况，然后终止运行。</p><p>我们可以将 panic 分为两种：</p><p>一种是有意抛出的，比如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic(&quot;自定义的 panic 信息&quot;)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019/09/10 20:25:27 http: panic serving [::1]:61547: 自定义的 panic 信息</span><br><span class="line">goroutine 8 [running]:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一种是无意抛出的，写程序马虎造成，比如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var slice = [] int &#123;1, 2, 3, 4, 5&#125;</span><br><span class="line"></span><br><span class="line">slice[6] = 6</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019/09/10 15:27:05 http: panic serving [::1]:61616: runtime error: index out of range</span><br><span class="line">goroutine 6 [running]:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>想象一下，如果在线上环境出现了 panic，命令行输出的，因为咱们无法捕获就无法定位问题呀，想想都可怕，那么问题来了，怎么捕获异常？</p><h2 id="怎么捕获异常？"><a href="#怎么捕获异常？" class="headerlink" title="怎么捕获异常？"></a>怎么捕获异常？</h2><p>当程序发生 panic 后，在 defer(延迟函数) 内部可以调用 recover 进行捕获。</p><p>不多说，直接上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defer func() &#123;</span><br><span class="line">if err := recover(); err != nil &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>在运行一下 “无意抛出的 panic ”，输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime error: index out of range</span><br></pre></td></tr></table></figure><p>OK，错误捕获到了，这时我们可以进行做文章了。</p><p>做啥文章，大家应该都知道了吧：</p><ul><li>获取运行时的调用栈（debug.Stack()）</li><li>获取当时的 Request 数据</li><li>组装数据，进行发邮件</li></ul><p>那么，Go 怎么发邮件呀，有没有开源包呀？</p><p>当然有，请往下看。</p><h2 id="封装发邮件方法"><a href="#封装发邮件方法" class="headerlink" title="封装发邮件方法"></a>封装发邮件方法</h2><p>使用包：<code>gopkg.in/gomail.v2</code></p><p>直接上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func SendMail(mailTo string, subject string, body string) error &#123;</span><br><span class="line"></span><br><span class="line">if config.ErrorNotifyOpen != 1 &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m := gomail.NewMessage()</span><br><span class="line"></span><br><span class="line">//设置发件人</span><br><span class="line">m.SetHeader(&quot;From&quot;, config.SystemEmailUser)</span><br><span class="line"></span><br><span class="line">//设置发送给多个用户</span><br><span class="line">mailArrTo := strings.Split(mailTo, &quot;,&quot;)</span><br><span class="line">m.SetHeader(&quot;To&quot;, mailArrTo...)</span><br><span class="line"></span><br><span class="line">//设置邮件主题</span><br><span class="line">m.SetHeader(&quot;Subject&quot;, subject)</span><br><span class="line"></span><br><span class="line">//设置邮件正文</span><br><span class="line">m.SetBody(&quot;text/html&quot;, body)</span><br><span class="line"></span><br><span class="line">d := gomail.NewDialer(config.SystemEmailHost, config.SystemEmailPort, config.SystemEmailUser, config.SystemEmailPass)</span><br><span class="line"></span><br><span class="line">err := d.DialAndSend(m)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这块我加了一个开关，想开想关，您随意。</p><p>现在会发送邮件了，再整个邮件模板就完美了。</p><h2 id="自定义邮件模板"><a href="#自定义邮件模板" class="headerlink" title="自定义邮件模板"></a>自定义邮件模板</h2><p>如图：</p><p><img src="/images/gin/4_api_3.png"></p><p>这就是告警邮件的模板，还不错吧，大家还想记录什么，可以自定义去修改。</p><h2 id="封装一个中间件"><a href="#封装一个中间件" class="headerlink" title="封装一个中间件"></a>封装一个中间件</h2><p>最后，封装一下。</p><p>直接上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func SetUp() gin.HandlerFunc &#123;</span><br><span class="line"></span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">if err := recover(); err != nil &#123;</span><br><span class="line"></span><br><span class="line">DebugStack := &quot;&quot;</span><br><span class="line">for _, v := range strings.Split(string(debug.Stack()), &quot;\n&quot;) &#123;</span><br><span class="line">DebugStack += v + &quot;&lt;br&gt;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject := fmt.Sprintf(&quot;【重要错误】%s 项目出错了！&quot;, config.AppName)</span><br><span class="line"></span><br><span class="line">body := strings.ReplaceAll(MailTemplate, &quot;&#123;ErrorMsg&#125;&quot;, fmt.Sprintf(&quot;%s&quot;, err))</span><br><span class="line">body  = strings.ReplaceAll(body, &quot;&#123;RequestTime&#125;&quot;, util.GetCurrentDate())</span><br><span class="line">body  = strings.ReplaceAll(body, &quot;&#123;RequestURL&#125;&quot;, c.Request.Method + &quot;  &quot; + c.Request.Host + c.Request.RequestURI)</span><br><span class="line">body  = strings.ReplaceAll(body, &quot;&#123;RequestUA&#125;&quot;, c.Request.UserAgent())</span><br><span class="line">body  = strings.ReplaceAll(body, &quot;&#123;RequestIP&#125;&quot;, c.ClientIP())</span><br><span class="line">body  = strings.ReplaceAll(body, &quot;&#123;DebugStack&#125;&quot;, DebugStack)</span><br><span class="line"></span><br><span class="line">_ = util.SendMail(config.ErrorNotifyUser, subject, body)</span><br><span class="line"></span><br><span class="line">utilGin := util.Gin&#123;Ctx: c&#125;</span><br><span class="line">utilGin.Response(500, &quot;系统异常，请联系管理员！&quot;, nil)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">c.Next()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当发生 panic 异常时，输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 500,</span><br><span class="line">    &quot;msg&quot;: &quot;系统异常，请联系管理员！&quot;,</span><br><span class="line">    &quot;data&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，还会收到一封 panic 告警邮件。</p><p><img src="/images/gin/4_api_4.png"></p><p>便于截图，DebugStack 删减了一些信息。</p><p>到这，就结束了。</p><p><img src="/images/gin/4_api_5.jpeg"></p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul><li>发邮件的地方，可以调整为异步发送。</li><li>文章中仅贴了部分代码，相关代码请查阅 github。</li><li>测试发邮件时，一定要配置邮箱信息。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先同步下项目概况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/gin/4_api_1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上篇文章分享了，路</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="gin框架" scheme="https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>路由中间件 - 日志记录</title>
    <link href="https://timmy6.github.io/2019/03/10/gin-log-1/"/>
    <id>https://timmy6.github.io/2019/03/10/gin-log-1/</id>
    <published>2019-03-10T11:22:20.000Z</published>
    <updated>2022-05-13T09:40:47.454Z</updated>
    
    <content type="html"><![CDATA[<p>首先同步下项目概况：</p><p><img src="/images/gin/3_api_1.png"></p><p>上篇文章分享了，规划项目目录和参数验证，其中参数验证使用的是 validator.v8 版本，现已更新到 validator.v9 版本，最新代码查看 github 即可。</p><p>这篇文章咱们分享：路由中间件 - 日志记录。</p><p>日志是特别重要的一个东西，方便我们对问题进行排查，这篇文章我们实现将日志记录到文本文件中。</p><p>这是我规划的，需要记录的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- request 请求数据</span><br><span class="line">    - request_time</span><br><span class="line">    - request_method</span><br><span class="line">    - request_uri</span><br><span class="line">    - request_proto</span><br><span class="line">    - request_ua</span><br><span class="line">    - request_referer</span><br><span class="line">    - request_post_data</span><br><span class="line">    - request_client_ip</span><br><span class="line">    </span><br><span class="line">- response 返回数据</span><br><span class="line">    - response_time</span><br><span class="line">    - response_code</span><br><span class="line">    - response_msg</span><br><span class="line">    - response_data</span><br><span class="line">    </span><br><span class="line">- cost_time 花费时间</span><br></pre></td></tr></table></figure><p>Gin 框架中自带 Logger 中间件，我们了解下框架中自带的 Logger 中间件是否满足我们的需求？</p><h2 id="gin-Logger"><a href="#gin-Logger" class="headerlink" title="gin.Logger()"></a>gin.Logger()</h2><p>我们先使用 gin.Logger() 看看效果。</p><p>在 route.go SetupRouter 方法中增加代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine.Use(gin.Logger())</span><br></pre></td></tr></table></figure><p>运行后多请求几次，日志输出在命令行中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GIN] 2019/08/30 - 21:24:16 | 200 |     178.072µs |             ::1 | GET      /ping</span><br><span class="line">[GIN] 2019/08/30 - 21:24:27 | 200 |     367.997µs |             ::1 | POST     /product</span><br><span class="line">[GIN] 2019/08/30 - 21:24:28 | 200 |    2.521592ms |             ::1 | POST     /product</span><br></pre></td></tr></table></figure><p>先解决第一个问题，怎么将日志输出到文本中？</p><p>在 route.go SetupRouter 方法中增加代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f, _ := os.Create(config.AppAccessLogName)</span><br><span class="line">gin.DefaultWriter = io.MultiWriter(f)</span><br><span class="line">engine.Use(gin.Logger())</span><br></pre></td></tr></table></figure><p>运行后多请求几次，日志输出在文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GIN] 2019/08/30 - 21:36:07 | 200 |     369.023µs |             ::1 | GET      /ping</span><br><span class="line">[GIN] 2019/08/30 - 21:36:08 | 200 |      27.585µs |             ::1 | GET      /ping</span><br><span class="line">[GIN] 2019/08/30 - 21:36:10 | 200 |      14.302µs |             ::1 | POST     /product</span><br></pre></td></tr></table></figure><p>虽然记录到文件成功了，但是记录的参数不是我们想要的样子。</p><p>怎么办呢？</p><p>我们需要自定义一个日志中间件，按照我们需要的参数进行记录。</p><h2 id="自定义-Logger"><a href="#自定义-Logger" class="headerlink" title="自定义 Logger()"></a>自定义 Logger()</h2><p><strong>middleware&#x2F;logger&#x2F;logger.go</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">package logger</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;bytes&quot;</span><br><span class="line">&quot;encoding/json&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">&quot;go-gin-api/app/config&quot;</span><br><span class="line">&quot;go-gin-api/app/util&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type bodyLogWriter struct &#123;</span><br><span class="line">gin.ResponseWriter</span><br><span class="line">body *bytes.Buffer</span><br><span class="line">&#125;</span><br><span class="line">func (w bodyLogWriter) Write(b []byte) (int, error) &#123;</span><br><span class="line">w.body.Write(b)</span><br><span class="line">return w.ResponseWriter.Write(b)</span><br><span class="line">&#125;</span><br><span class="line">func (w bodyLogWriter) WriteString(s string) (int, error) &#123;</span><br><span class="line">w.body.WriteString(s)</span><br><span class="line">return w.ResponseWriter.WriteString(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func SetUp() gin.HandlerFunc &#123;</span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line">bodyLogWriter := &amp;bodyLogWriter&#123;body: bytes.NewBufferString(&quot;&quot;), ResponseWriter: c.Writer&#125;</span><br><span class="line">c.Writer = bodyLogWriter</span><br><span class="line"></span><br><span class="line">//开始时间</span><br><span class="line">startTime := util.GetCurrentMilliTime()</span><br><span class="line"></span><br><span class="line">//处理请求</span><br><span class="line">c.Next()</span><br><span class="line"></span><br><span class="line">responseBody := bodyLogWriter.body.String()</span><br><span class="line"></span><br><span class="line">var responseCode int</span><br><span class="line">var responseMsg  string</span><br><span class="line">var responseData interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">if responseBody != &quot;&quot; &#123;</span><br><span class="line">response := util.Response&#123;&#125;</span><br><span class="line">err := json.Unmarshal([]byte(responseBody), &amp;response)</span><br><span class="line">if err == nil &#123;</span><br><span class="line">responseCode = response.Code</span><br><span class="line">responseMsg  = response.Message</span><br><span class="line">responseData = response.Data</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//结束时间</span><br><span class="line">endTime := util.GetCurrentMilliTime()</span><br><span class="line"></span><br><span class="line">if c.Request.Method == &quot;POST&quot; &#123;</span><br><span class="line">c.Request.ParseForm()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//日志格式</span><br><span class="line">accessLogMap := make(map[string]interface&#123;&#125;)</span><br><span class="line"></span><br><span class="line">accessLogMap[&quot;request_time&quot;]      = startTime</span><br><span class="line">accessLogMap[&quot;request_method&quot;]    = c.Request.Method</span><br><span class="line">accessLogMap[&quot;request_uri&quot;]       = c.Request.RequestURI</span><br><span class="line">accessLogMap[&quot;request_proto&quot;]     = c.Request.Proto</span><br><span class="line">accessLogMap[&quot;request_ua&quot;]        = c.Request.UserAgent()</span><br><span class="line">accessLogMap[&quot;request_referer&quot;]   = c.Request.Referer()</span><br><span class="line">accessLogMap[&quot;request_post_data&quot;] = c.Request.PostForm.Encode()</span><br><span class="line">accessLogMap[&quot;request_client_ip&quot;] = c.ClientIP()</span><br><span class="line"></span><br><span class="line">accessLogMap[&quot;response_time&quot;] = endTime</span><br><span class="line">accessLogMap[&quot;response_code&quot;] = responseCode</span><br><span class="line">accessLogMap[&quot;response_msg&quot;]  = responseMsg</span><br><span class="line">accessLogMap[&quot;response_data&quot;] = responseData</span><br><span class="line"></span><br><span class="line">accessLogMap[&quot;cost_time&quot;] = fmt.Sprintf(&quot;%vms&quot;, endTime - startTime)</span><br><span class="line"></span><br><span class="line">accessLogJson, _ := util.JsonEncode(accessLogMap)</span><br><span class="line"></span><br><span class="line">if f, err := os.OpenFile(config.AppAccessLogName, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0666); err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">f.WriteString(accessLogJson + &quot;\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后多请求几次，日志输出在文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;cost_time&quot;:&quot;0ms&quot;,&quot;request_client_ip&quot;:&quot;::1&quot;,&quot;request_method&quot;:&quot;GET&quot;,&quot;request_post_data&quot;:&quot;&quot;,&quot;request_proto&quot;:&quot;HTTP/1.1&quot;,&quot;request_referer&quot;:&quot;&quot;,&quot;request_time&quot;:1567172568233,&quot;request_ua&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36&quot;,&quot;request_uri&quot;:&quot;/ping&quot;,&quot;response_code&quot;:1,&quot;response_data&quot;:null,&quot;response_msg&quot;:&quot;pong&quot;,&quot;response_time&quot;:1567172568233&#125;</span><br><span class="line">&#123;&quot;cost_time&quot;:&quot;0ms&quot;,&quot;request_client_ip&quot;:&quot;::1&quot;,&quot;request_method&quot;:&quot;GET&quot;,&quot;request_post_data&quot;:&quot;&quot;,&quot;request_proto&quot;:&quot;HTTP/1.1&quot;,&quot;request_referer&quot;:&quot;&quot;,&quot;request_time&quot;:1567172569158,&quot;request_ua&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36&quot;,&quot;request_uri&quot;:&quot;/ping&quot;,&quot;response_code&quot;:1,&quot;response_data&quot;:null,&quot;response_msg&quot;:&quot;pong&quot;,&quot;response_time&quot;:1567172569158&#125;</span><br><span class="line">&#123;&quot;cost_time&quot;:&quot;0ms&quot;,&quot;request_client_ip&quot;:&quot;::1&quot;,&quot;request_method&quot;:&quot;POST&quot;,&quot;request_post_data&quot;:&quot;name=admin&quot;,&quot;request_proto&quot;:&quot;HTTP/1.1&quot;,&quot;request_referer&quot;:&quot;&quot;,&quot;request_time&quot;:1567172629565,&quot;request_ua&quot;:&quot;PostmanRuntime/7.6.0&quot;,&quot;request_uri&quot;:&quot;/product&quot;,&quot;response_code&quot;:-1,&quot;response_data&quot;:null,&quot;response_msg&quot;:&quot;Key: &#x27;ProductAdd.Name&#x27; Error:Field validation for &#x27;Name&#x27; failed on the &#x27;NameValid&#x27; tag&quot;,&quot;response_time&quot;:1567172629565&#125;</span><br></pre></td></tr></table></figure><p>OK，咱们想要的所有参数全都记录了！</p><p>抛出几个问题吧：</p><p>1、有没有开源的日志记录工具？</p><p>当然有，其中 logrus 是用的最多的，这个工具功能强大。</p><p>2、为什么将日志记录到文本中？</p><p>因为，日志平台可以使用的是 ELK。</p><p>使用 Logstash 进行收集文本文件，使用 Elasticsearch 引擎进行搜索分析，最终在 Kibana 平台展示出来。</p><p>3、当大量请求过来时，写入文件会不会出问题？</p><p>可能会，这块可以使用异步，咱们可以用下 go 的 chan。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先同步下项目概况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/gin/3_api_1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上篇文章分享了，规划项目目录和参数验证，其中参数验证使用的是 validator.v8 版本，现已更新到 validator.v9 版本，最新代码查看 </summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="gin框架" scheme="https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>规划项目目录和参数验证</title>
    <link href="https://timmy6.github.io/2019/02/25/gin-modules2/"/>
    <id>https://timmy6.github.io/2019/02/25/gin-modules2/</id>
    <published>2019-02-25T11:22:20.000Z</published>
    <updated>2022-05-13T07:48:43.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先同步下项目概况：</p><p><img src="/images/gin/2_api_1.png"></p><p>上篇文章分享了，使用 go modules 初始化项目，这篇文章咱们分享：</p><ul><li>规划目录结构</li><li>模型绑定和验证</li><li>自定义验证器</li><li>制定 API 返回结构</li></ul><p>废话不多说，咱们开始吧。</p><h2 id="规划目录结构"><a href="#规划目录结构" class="headerlink" title="规划目录结构"></a>规划目录结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">├─ go-gin-api</span><br><span class="line">│  ├─ app</span><br><span class="line">│     ├─ config           //配置文件</span><br><span class="line">│        ├─ config.go</span><br><span class="line">│     ├─ controller       //控制器层</span><br><span class="line">│        ├─ param_bind</span><br><span class="line">│        ├─ param_verify</span><br><span class="line">│        ├─ ...</span><br><span class="line">│     ├─ model            //数据库ORM</span><br><span class="line">│        ├─ proto</span><br><span class="line">│        ├─ ...</span><br><span class="line">│     ├─ repository       //数据库操作层</span><br><span class="line">│        ├─ ...</span><br><span class="line">│     ├─ route            //路由</span><br><span class="line">│        ├─ middleware</span><br><span class="line">│        ├─ route.go</span><br><span class="line">│     ├─ service          //业务层</span><br><span class="line">│        ├─ ...</span><br><span class="line">│     ├─ util             //工具包</span><br><span class="line">│        ├─ ...</span><br><span class="line">│  ├─ vendor  //依赖包</span><br><span class="line">│     ├─ ...</span><br><span class="line">│  ├─ go.mod</span><br><span class="line">│  ├─ go.sum</span><br><span class="line">│  ├─ main.go //入口文件</span><br></pre></td></tr></table></figure><p>上面的目录结构是我自定义的，大家也可以根据自己的习惯去定义。</p><p>controller 控制器层主要对提交过来的数据进行验证，然后将验证完成的数据传递给 service 处理。</p><p>在 gin 框架中，参数验证有两种：</p><p>1、模型绑定和验证。</p><p>2、自定义验证器。</p><p>其中目录 <code>param_bind</code>，存储的是参数绑定的数据，目录<code>param_verify</code> 存储的是自定义验证器。</p><p>接下来，让咱们进行简单实现。</p><h2 id="模型绑定和验证"><a href="#模型绑定和验证" class="headerlink" title="模型绑定和验证"></a>模型绑定和验证</h2><p>比如，有一个创建商品的接口，商品名称不能为空。</p><p>配置路由(route.go)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ProductRouter := engine.Group(&quot;&quot;)</span><br><span class="line">&#123;</span><br><span class="line">// 新增产品</span><br><span class="line">ProductRouter.POST(&quot;/product&quot;, product.Add)</span><br><span class="line"></span><br><span class="line">// 更新产品</span><br><span class="line">ProductRouter.PUT(&quot;/product/:id&quot;, product.Edit)</span><br><span class="line"></span><br><span class="line">// 删除产品</span><br><span class="line">ProductRouter.DELETE(&quot;/product/:id&quot;, product.Delete)</span><br><span class="line"></span><br><span class="line">// 获取产品详情</span><br><span class="line">ProductRouter.GET(&quot;/product/:id&quot;, product.Detail)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数绑定(param_bind&#x2F;product.go)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type ProductAdd struct &#123;</span><br><span class="line">Name string `form:&quot;name&quot; json:&quot;name&quot; binding:&quot;required&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器调用(controller&#x2F;product.go)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if err := c.ShouldBind(&amp;param_bind.ProductAdd&#123;&#125;); err != nil &#123;</span><br><span class="line">utilGin.Response(-1, err.Error(), nil)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咱们用 Postman 模拟 post 请求时，name 参数不传或传递为空，会出现：</p><p>Key: ‘ProductAdd.Name’ Error:Field validation for ‘Name’ failed on the ‘required’ tag</p><p>这就使用到了参数设置的 <code>binding:&quot;required&quot;</code>。</p><p>那么还能使用 binding 哪些参数，有文档吗？</p><p>有。Gin 使用 go-playground&#x2F;validator.v8 进行验证，相关文档：</p><p><a href="https://godoc.org/gopkg.in/go-playground/validator.v8">https://godoc.org/gopkg.in/go-playground/validator.v8</a></p><p>接下来，咱们实现一下自定义验证器。</p><h2 id="自定义验证器"><a href="#自定义验证器" class="headerlink" title="自定义验证器"></a>自定义验证器</h2><p>比如，有一个创建商品的接口，商品名称不能为空并且参数名称不能等于 admin。</p><p>类似于这种业务需求，无法 binding 现成的方法，需要我们自己写验证方法，才能实现。</p><p>自定义验证方法(param_verify&#x2F;product.go)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func NameValid (</span><br><span class="line">v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value,</span><br><span class="line">field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string,</span><br><span class="line">) bool &#123;</span><br><span class="line">if s, ok := field.Interface().(string); ok &#123;</span><br><span class="line">if s == &quot;admin&quot; &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数绑定(param_bind&#x2F;product.go)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type ProductAdd struct &#123;</span><br><span class="line">Name string `form:&quot;name&quot; json:&quot;name&quot; binding:&quot;required,NameValid&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时还要绑定验证器:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 绑定验证器</span><br><span class="line">if v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;</span><br><span class="line">v.RegisterValidation(&quot;NameValid&quot;, param_verify.NameValid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咱们用 Postman 模拟 post 请求时，name 参数不传或传递为空，会出现：</p><p>Key: ‘ProductAdd.Name’ Error:Field validation for ‘Name’ failed on the ‘required’ tag</p><p>name&#x3D;admin 时：</p><p>Key: ‘ProductAdd.Name’ Error:Field validation for ‘Name’ failed on the ‘NameValid’ tag</p><p>OK，上面两个验证都生效了！</p><p>上面的输出都是在控制台，能不能返回一个 Json 结构的数据呀？</p><p>能。接下来咱们制定 API 返回结构。</p><h2 id="制定-API-返回结构"><a href="#制定-API-返回结构" class="headerlink" title="制定 API 返回结构"></a>制定 API 返回结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 1,</span><br><span class="line">    &quot;msg&quot;: &quot;&quot;,</span><br><span class="line">    &quot;data&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>API 接口的返回的结构基本都是这三个字段。</p><p>比如 code&#x3D;1 表示成功，code&#x3D;-1 表示失败。</p><p>msg 表示提示信息。</p><p>data 表示要返回的数据。</p><p>那么，我们怎么在 gin 框架中实现它，其实很简单 基于 <code>c.JSON()</code> 方法进行封装即可，直接看代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package util</span><br><span class="line"></span><br><span class="line">import &quot;github.com/gin-gonic/gin&quot;</span><br><span class="line"></span><br><span class="line">type Gin struct &#123;</span><br><span class="line">Ctx *gin.Context</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type response struct &#123;</span><br><span class="line">Code     int         `json:&quot;code&quot;`</span><br><span class="line">Message  string      `json:&quot;msg&quot;`</span><br><span class="line">Data     interface&#123;&#125; `json:&quot;data&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (g *Gin)Response(code int, msg string, data interface&#123;&#125;) &#123;</span><br><span class="line">g.Ctx.JSON(200, response&#123;</span><br><span class="line">Code    : code,</span><br><span class="line">Message : msg,</span><br><span class="line">Data    : data,</span><br><span class="line">&#125;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器调用(controller&#x2F;product.go)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">utilGin := util.Gin&#123;Ctx:c&#125;</span><br><span class="line">if err := c.ShouldBind(&amp;param_bind.ProductAdd&#123;&#125;); err != nil &#123;</span><br><span class="line">utilGin.Response(-1, err.Error(), nil)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咱们用 Postman 模拟 post 请求时，name 参数不传或传递为空，会出现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: -1,</span><br><span class="line">    &quot;msg&quot;: &quot;Key: &#x27;ProductAdd.Name&#x27; Error:Field validation for &#x27;Name&#x27; failed on the &#x27;required&#x27; tag&quot;,</span><br><span class="line">    &quot;data&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>name&#x3D;admin 时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: -1,</span><br><span class="line">    &quot;msg&quot;: &quot;Key: &#x27;ProductAdd.Name&#x27; Error:Field validation for &#x27;Name&#x27; failed on the &#x27;NameValid&#x27; tag&quot;,</span><br><span class="line">    &quot;data&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，上面两个验证都生效了！</p><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p><a href="https://github.com/xinliangnote/go-gin-api">https://github.com/xinliangnote/go-gin-api</a></p><h2 id="go-gin-api-系列文章"><a href="#go-gin-api-系列文章" class="headerlink" title="go-gin-api 系列文章"></a>go-gin-api 系列文章</h2><ul><li><a href="https://mp.weixin.qq.com/s/1XNTEgZ0XGZZdxFOfR5f_A">1. 使用 go modules 初始化项目</a></li></ul><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p><strong>Gin 模型验证 Validator 升级：validator.v8 升级为 validator.v9，已提交到 github !!!</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先同步下项目概况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/gin/2_api_1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上篇文章分享了，使</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="gin框架" scheme="https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>使用 go modules 初始化项目</title>
    <link href="https://timmy6.github.io/2019/02/15/gin-modules/"/>
    <id>https://timmy6.github.io/2019/02/15/gin-modules/</id>
    <published>2019-02-15T13:12:50.000Z</published>
    <updated>2022-05-13T07:42:06.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我想实现一个开箱即用的 API 框架的轮子，这个轮子是基于 Gin 基础上开发的。</p><p>为什么是开箱即用，它会集成哪些功能？</p><p><img src="/images/gin/1_api_1.png"></p><p>以上功能点，都是常用的，后期可能还会增加。</p><p>废话不多说，咱们开始吧。</p><p>创建一个项目，咱们首先要考虑一个依赖包的管理工具。</p><p>常见的包管理有，dep、go vendor、glide、go modules 等。</p><p>最开始，使用过 dep，当时被朋友 diss 了，推荐我使用 go modules 。</p><p>现在来说一下 go modules ，这个是随着 Go 1.11 的发布和我们见面的，这是官方提倡的新的包管理。</p><p>说一个环境变量：GO111MODULE，默认值为 auto 。</p><p>当项目中有 go.mod 时，使用 go modules 管理，反之使用 旧的 GOPATH 和 vendor机制。</p><p>如果就想使用 go modules ，可以将 GO111MODULE 设置为 on 。</p><p>直接上手吧。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>咱们在 GOPATH 之外的地方，新建一个空文件夹 <code>go-gin-api</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd go-gin-api &amp;&amp; go mod init go-gin-api</span><br></pre></td></tr></table></figure><p>输出：</p><p>go: creating new go.mod: module go-gin-api</p><p>这时目录中多一个 go.mod 文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module go-gin-api</span><br><span class="line"></span><br><span class="line">go 1.12</span><br></pre></td></tr></table></figure><p>到这，go mod 初始化就完成，接下来添加依赖包 - gin。</p><h2 id="添加依赖包"><a href="#添加依赖包" class="headerlink" title="添加依赖包"></a>添加依赖包</h2><p>在目录中创建一个 <code>main.go</code> 的文件，放上如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;github.com/gin-gonic/gin&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">r.GET(&quot;/ping&quot;, func(c *gin.Context) &#123;</span><br><span class="line">c.JSON(200, gin.H&#123;</span><br><span class="line">&quot;message&quot;: &quot;pong&quot;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run() // listen and serve on 0.0.0.0:8080</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这代码没什么特别的，就是官方的入门Demo。</p><p>接下来，开始下载依赖包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><p>执行完成后，看一下 <code>go.mod</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module go-gin-api</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require github.com/gin-gonic/gin v1.4.0</span><br></pre></td></tr></table></figure><p>这时，看到新增一个 gin v1.4.0 的包。</p><p>还生成了一个 go.sum 的文件，这个文件可以暂时先不管。</p><p>这时发现了 2 个问题。</p><p>1、目录中没发现 gin 包，包下载到哪了？</p><p>下载到了 GOPATH&#x2F;pkg&#x2F;mod 目录中。</p><p>2、GoLand 编辑器中关于 Gin 的引用变红了？</p><p>在这里编辑器需要设置一下，如图：</p><p><img src="/images/gin/1_api_2.png"></p><p>点击 Apply 和 OK 即可。</p><p>如果这招不灵，还可以执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod vendor</span><br></pre></td></tr></table></figure><p>这个命令是将项目依赖的包，放到项目的 vendor 目录中，这肯定就可以了。</p><h2 id="go-mod-命令"><a href="#go-mod-命令" class="headerlink" title="go mod 命令"></a>go mod 命令</h2><p><strong>go mod tidy</strong></p><p>拉取缺少的模块，移除不用的模块。</p><p>我常用这个命令。</p><p><strong>go mod vendor</strong></p><p>将依赖复制到vendor下。</p><p>我常用这个命令。</p><p><strong>go mod download</strong></p><p>下载依赖包。</p><p><strong>go mod verify</strong></p><p>检验依赖。</p><p><strong>go mod graph</strong></p><p>打印模块依赖图。</p><p>其他命令，可以执行 <code>go mod</code> ，查看即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章，分享了 go modules 的使用。</p><ul><li>使用 go modules 从零搭建一个项目。</li><li>GoLand 编辑器使用 go modules。</li></ul><p>今天就到这了，下一篇文章开始搭建 API 项目了，写参数验证。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;我想实现一个开箱即用的 API 框架的轮子，这个轮子是基于 Gin 基础上开发的。&lt;/p&gt;
&lt;p&gt;为什么是开箱即用，它会集成哪些功能？&lt;/p</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="gin框架" scheme="https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>gRPC 工具</title>
    <link href="https://timmy6.github.io/2019/02/10/grpc-tools/"/>
    <id>https://timmy6.github.io/2019/02/10/grpc-tools/</id>
    <published>2019-02-10T14:22:50.000Z</published>
    <updated>2022-05-13T07:37:45.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当我们在写 HTTP 接口的时候，使用的是 Postman 进行接口调试，那么在写 gRPC 接口的时候，有没有类似于 Postman 的调试工具呢？</p><p><img src="/images/grpc/2_grpc_1.gif"></p><p>这是有的。</p><p>咱们一起看下 <code>grpcui</code>，源码地址：</p><p><a href="https://github.com/fullstorydev/grpcui">https://github.com/fullstorydev/grpcui</a></p><p>看下官方描述：</p><blockquote><p>grpcui is a command-line tool that lets you interact with gRPC servers via a browser. It’s sort of like Postman, but for gRPC APIs instead of REST.</p></blockquote><h2 id="写一个-gRPC-API"><a href="#写一个-gRPC-API" class="headerlink" title="写一个 gRPC API"></a>写一个 gRPC API</h2><p>端口：9901</p><p><code>.proto</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;; // 指定 proto 版本</span><br><span class="line"></span><br><span class="line">package listen;     // 指定包名</span><br><span class="line"></span><br><span class="line">// 定义服务</span><br><span class="line">service Listen &#123;</span><br><span class="line"></span><br><span class="line">// 定义方法</span><br><span class="line">rpc ListenData(Request) returns (Response) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Request 请求结构</span><br><span class="line">message Request &#123;</span><br><span class="line">string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Response 响应结构</span><br><span class="line">message Response &#123;</span><br><span class="line">    string message = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，这个大家一看就知道了。</p><ul><li>Service name 为 listen.Listen</li><li>Method name 为 ListenData</li></ul><p>再看下 ListenData 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (l *ListenController) ListenData(ctx context.Context, in *listen.Request) (*listen.Response, error) &#123;</span><br><span class="line">return &amp;listen.Response&#123;Message : fmt.Sprintf(&quot;[%s]&quot;, in.Name)&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这表示，将 <code>Name</code> 直接返回。</p><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd listen &amp;&amp; go run main.go</span><br></pre></td></tr></table></figure><p>服务启动成功后，等待使用。</p><h2 id="grpcui-使用"><a href="#grpcui-使用" class="headerlink" title="grpcui 使用"></a>grpcui 使用</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>根据官方 <code>README.md</code> 文档安装即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/fullstorydev/grpcui</span><br><span class="line">go install github.com/fullstorydev/grpcui/cmd/grpcui</span><br></pre></td></tr></table></figure><p>这时，在 <code>$GOPATH/bin</code> 目录下，生成一个 <code>grpcui</code> 可执行文件。</p><p>执行个命令，验证下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grpcui -help</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">grpcui [flags] [address]</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>表示安装成功了。</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grpcui -plaintext 127.0.0.1:9901</span><br><span class="line"></span><br><span class="line">Failed to compute set of methods to expose: server does not support the reflection API</span><br></pre></td></tr></table></figure><p>这种情况下，加个反射就可以了，在 listen 的 main.go 新增如下代码即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflection.Register(s)</span><br></pre></td></tr></table></figure><p>在运行一次试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grpcui -plaintext 127.0.0.1:9901</span><br><span class="line">gRPC Web UI available at http://127.0.0.1:63027/</span><br></pre></td></tr></table></figure><p>在浏览器中访问：<code>http://127.0.0.1:63027/</code></p><p><img src="/images/grpc/2_grpc_2.gif"></p><p>到这，我们看到 Service name、Method name 都出来了，传输参数直接在页面上进行操作即可。</p><p>当发起 Request “Tom”，也能获得 Response “Tom”。</p><p>当然，如果这个服务下面有多个 Service name，多个 Method name 也都会显示出来的，去试试吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;当我们在写 HTTP 接口的时候，使用的是 Postman 进行接口调试，那么在写 gRPC 接口的时候，有没有类似于 Postman 的调</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="gRPC" scheme="https://timmy6.github.io/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>gRPC Hello World</title>
    <link href="https://timmy6.github.io/2019/01/25/grpc-hello/"/>
    <id>https://timmy6.github.io/2019/01/25/grpc-hello/</id>
    <published>2019-01-25T13:22:50.000Z</published>
    <updated>2022-05-13T07:26:13.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>开始 gRPC 了，这篇文章学习使用 gRPC，输出一个 Hello World。</p><ul><li>用 Go 实现 gRPC 的服务端。</li><li>用 Go 实现 gRPC 的客户端。</li></ul><p>gRPC 支持 4 类服务方法，咱们这次实现 单项 RPC 和 服务端流式 RPC。</p><h2 id="四类服务方法"><a href="#四类服务方法" class="headerlink" title="四类服务方法"></a>四类服务方法</h2><p><strong>单项 RPC</strong></p><p>服务端发送一个请求给服务端，从服务端获取一个应答，就像一次普通的函数调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc SayHello(HelloRequest) returns (HelloResponse)&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>服务端流式 RPC</strong></p><p>客户端发送一个请求给服务端，可获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse)&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端流式 RPC</strong></p><p>客户端用提供的一个数据流写入并发送一系列消息给服务端。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse) &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>双向流式 RPC</strong></p><p>两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务端能按其希望的任意顺序读写，例如：服务端可以在写应答前等待所有的客户端消息，或者它可以先读一个消息再写一个消息，或者是读写相结合的其他方式。每个数据流里消息的顺序会被保持。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc BidiHello(stream HelloRequest) returns (stream HelloResponse)&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>安装 protobuf 编译器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install protobuf</span><br></pre></td></tr></table></figure><p>验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protoc --version</span><br><span class="line"></span><br><span class="line">//输出：libprotoc 3.7.1</span><br></pre></td></tr></table></figure><p><strong>安装 Go protobuf 插件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/golang/protobuf/proto</span><br><span class="line"></span><br><span class="line">go get -u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure><p><strong>安装 grpc-go</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u google.golang.org/grpc</span><br></pre></td></tr></table></figure><h2 id="写个-Hello-World-服务"><a href="#写个-Hello-World-服务" class="headerlink" title="写个 Hello World 服务"></a>写个 Hello World 服务</h2><ul><li>编写服务端 <code>.proto</code> 文件</li><li>生成服务端 <code>.pb.go</code> 文件并同步给客户端</li><li>编写服务端提供接口的代码</li><li>编写客户端调用接口的代码</li></ul><p><strong>目录结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">├─ hello  -- 代码根目录</span><br><span class="line">│  ├─ go_client</span><br><span class="line">│     ├── main.go</span><br><span class="line">│     ├── proto</span><br><span class="line">│         ├── hello</span><br><span class="line">│            ├── hello.pb.go</span><br><span class="line">│  ├─ go_server</span><br><span class="line">│     ├── main.go</span><br><span class="line">│     ├── controller</span><br><span class="line">│         ├── hello_controller</span><br><span class="line">│            ├── hello_server.go</span><br><span class="line">│     ├── proto</span><br><span class="line">│         ├── hello</span><br><span class="line">│            ├── hello.pb.go</span><br><span class="line">│            ├── hello.proto</span><br></pre></td></tr></table></figure><p>这样创建目录是为了 go_client 和 go_server 后期可以拆成两个项目。</p><p><strong>编写服务端 hello.proto 文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;; // 指定 proto 版本</span><br><span class="line"></span><br><span class="line">package hello;     // 指定包名</span><br><span class="line"></span><br><span class="line">// 定义 Hello 服务</span><br><span class="line">service Hello &#123;</span><br><span class="line"></span><br><span class="line">// 定义 SayHello 方法</span><br><span class="line">rpc SayHello(HelloRequest) returns (HelloResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 定义 LotsOfReplies 方法</span><br><span class="line">rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// HelloRequest 请求结构</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// HelloResponse 响应结构</span><br><span class="line">message HelloResponse &#123;</span><br><span class="line">    string message = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>了解更多 Protobuf 语法，请查看：</p><p><a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p><p><strong>生成服务端 <code>.pb.go</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I . --go_out=plugins=grpc:. ./hello.proto</span><br></pre></td></tr></table></figure><p>同时将生成的 <code>hello.pb.go</code> 复制到客户端一份。</p><p>查看更多命令参数，执行 protoc，查看 OPTION 。</p><p><strong>编写服务端提供接口的代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// hello_server.go</span><br><span class="line">package hello_controller</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;golang.org/x/net/context&quot;</span><br><span class="line">&quot;hello/go_server/proto/hello&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type HelloController struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (h *HelloController) SayHello(ctx context.Context, in *hello.HelloRequest) (*hello.HelloResponse, error) &#123;</span><br><span class="line">return &amp;hello.HelloResponse&#123;Message : fmt.Sprintf(&quot;%s&quot;, in.Name)&#125;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *HelloController) LotsOfReplies(in *hello.HelloRequest, stream hello.Hello_LotsOfRepliesServer)  error &#123;</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">stream.Send(&amp;hello.HelloResponse&#123;Message : fmt.Sprintf(&quot;%s %s %d&quot;, in.Name, &quot;Reply&quot;, i)&#125;)</span><br><span class="line">&#125;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;net&quot;</span><br><span class="line">&quot;hello/go_server/proto/hello&quot;</span><br><span class="line">&quot;hello/go_server/controller/hello_controller&quot;</span><br><span class="line">&quot;google.golang.org/grpc&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">Address = &quot;0.0.0.0:9090&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">listen, err := net.Listen(&quot;tcp&quot;, Address)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalf(&quot;Failed to listen: %v&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s := grpc.NewServer()</span><br><span class="line"></span><br><span class="line">// 服务注册</span><br><span class="line">hello.RegisterHelloServer(s, &amp;hello_controller.HelloController&#123;&#125;)</span><br><span class="line"></span><br><span class="line">log.Println(&quot;Listen on &quot; + Address)</span><br><span class="line"></span><br><span class="line">if err := s.Serve(listen); err != nil &#123;</span><br><span class="line">log.Fatalf(&quot;Failed to serve: %v&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line">2019/07/28 17:51:20 Listen on 0.0.0.0:9090</span><br></pre></td></tr></table></figure><p><strong>编写客户端请求接口的代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;hello/go_client/proto/hello&quot;</span><br><span class="line">&quot;io&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;golang.org/x/net/context&quot;</span><br><span class="line">&quot;google.golang.org/grpc&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">// gRPC 服务地址</span><br><span class="line">Address = &quot;0.0.0.0:9090&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">conn, err := grpc.Dial(Address, grpc.WithInsecure())</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">defer conn.Close()</span><br><span class="line"></span><br><span class="line">// 初始化客户端</span><br><span class="line">c := hello.NewHelloClient(conn)</span><br><span class="line"></span><br><span class="line">// 调用 SayHello 方法</span><br><span class="line">res, err := c.SayHello(context.Background(), &amp;hello.HelloRequest&#123;Name: &quot;Hello World&quot;&#125;)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(res.Message)</span><br><span class="line"></span><br><span class="line">// 调用 LotsOfReplies 方法</span><br><span class="line">stream, err := c.LotsOfReplies(context.Background(),&amp;hello.HelloRequest&#123;Name: &quot;Hello World&quot;&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">res, err := stream.Recv()</span><br><span class="line">if err == io.EOF &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Printf(&quot;stream.Recv: %v&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(&quot;%s&quot;, res.Message)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line">2019/07/28 17:58:13 Hello World</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 0</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 1</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 2</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 3</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 4</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 5</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 6</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 7</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 8</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 9</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;开始 gRPC 了，这篇文章学习使用 gRPC，输出一个 Hello World。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用 Go 实现 gRPC 的服</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="gRPC" scheme="https://timmy6.github.io/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>统一定义API错误码</title>
    <link href="https://timmy6.github.io/2019/01/15/error-code/"/>
    <id>https://timmy6.github.io/2019/01/15/error-code/</id>
    <published>2019-01-15T13:22:50.000Z</published>
    <updated>2022-05-13T07:22:22.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="改之前"><a href="#改之前" class="headerlink" title="改之前"></a>改之前</h2><p>在使用 <code>gin</code> 开发接口的时候，返回接口数据是这样写的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type response struct &#123;</span><br><span class="line">Code int         `json:&quot;code&quot;`</span><br><span class="line">Msg  string      `json:&quot;msg&quot;`</span><br><span class="line">Data interface&#123;&#125; `json:&quot;data&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// always return http.StatusOK</span><br><span class="line">c.JSON(http.StatusOK, response&#123;</span><br><span class="line">Code: 20101,</span><br><span class="line">Msg:  &quot;用户手机号不合法&quot;,</span><br><span class="line">Data: nil,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这种写法 <code>code</code>、<code>msg</code> 都是在哪需要返回在哪定义，没有进行统一管理。</p><h2 id="改之后"><a href="#改之后" class="headerlink" title="改之后"></a>改之后</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 比如，返回“用户手机号不合法”错误</span><br><span class="line">c.JSON(http.StatusOK, errno.ErrUserPhone.WithID(c.GetString(&quot;trace-id&quot;)))</span><br><span class="line"></span><br><span class="line">// 正确返回</span><br><span class="line">c.JSON(http.StatusOK, errno.OK.WithData(data).WithID(c.GetString(&quot;trace-id&quot;)))</span><br></pre></td></tr></table></figure><p><code>errno.ErrUserPhone</code>、<code>errno.OK</code> 表示自定义的错误码，下面会看到定义的地方。</p><p><code>.WithID()</code> 设置当前请求的唯一ID，也可以理解为链路ID，忽略也可以。</p><p><code>.WithData()</code> 设置成功时返回的数据。</p><p>下面分享下编写的 <code>errno</code> 包源码，非常简单，希望大家不要介意。</p><h2 id="errno-包源码"><a href="#errno-包源码" class="headerlink" title="errno 包源码"></a>errno 包源码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// errno/errno.go</span><br><span class="line"></span><br><span class="line">package errno</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;encoding/json&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var _ Error = (*err)(nil)</span><br><span class="line"></span><br><span class="line">type Error interface &#123;</span><br><span class="line">// i 为了避免被其他包实现</span><br><span class="line">i()</span><br><span class="line">// WithData 设置成功时返回的数据</span><br><span class="line">WithData(data interface&#123;&#125;) Error</span><br><span class="line">// WithID 设置当前请求的唯一ID</span><br><span class="line">WithID(id string) Error</span><br><span class="line">// ToString 返回 JSON 格式的错误详情</span><br><span class="line">ToString() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type err struct &#123;</span><br><span class="line">Code int         `json:&quot;code&quot;`         // 业务编码</span><br><span class="line">Msg  string      `json:&quot;msg&quot;`          // 错误描述</span><br><span class="line">Data interface&#123;&#125; `json:&quot;data&quot;`         // 成功时返回的数据</span><br><span class="line">ID   string      `json:&quot;id,omitempty&quot;` // 当前请求的唯一ID，便于问题定位，忽略也可以</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewError(code int, msg string) Error &#123;</span><br><span class="line">return &amp;err&#123;</span><br><span class="line">Code: code,</span><br><span class="line">Msg:  msg,</span><br><span class="line">Data: nil,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *err) i() &#123;&#125;</span><br><span class="line"></span><br><span class="line">func (e *err) WithData(data interface&#123;&#125;) Error &#123;</span><br><span class="line">e.Data = data</span><br><span class="line">return e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *err) WithID(id string) Error &#123;</span><br><span class="line">e.ID = id</span><br><span class="line">return e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ToString 返回 JSON 格式的错误详情</span><br><span class="line">func (e *err) ToString() string &#123;</span><br><span class="line">err := &amp;struct &#123;</span><br><span class="line">Code int         `json:&quot;code&quot;`</span><br><span class="line">Msg  string      `json:&quot;msg&quot;`</span><br><span class="line">Data interface&#123;&#125; `json:&quot;data&quot;`</span><br><span class="line">ID   string      `json:&quot;id,omitempty&quot;`</span><br><span class="line">&#125;&#123;</span><br><span class="line">Code: e.Code,</span><br><span class="line">Msg:  e.Msg,</span><br><span class="line">Data: e.Data,</span><br><span class="line">ID:   e.ID,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">raw, _ := json.Marshal(err)</span><br><span class="line">return string(raw)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// errno/code.go</span><br><span class="line"></span><br><span class="line">package errno</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">// OK</span><br><span class="line">OK = NewError(0, &quot;OK&quot;)</span><br><span class="line"></span><br><span class="line">// 服务级错误码</span><br><span class="line">ErrServer    = NewError(10001, &quot;服务异常，请联系管理员&quot;)</span><br><span class="line">ErrParam     = NewError(10002, &quot;参数有误&quot;)</span><br><span class="line">ErrSignParam = NewError(10003, &quot;签名参数有误&quot;)</span><br><span class="line"></span><br><span class="line">// 模块级错误码 - 用户模块</span><br><span class="line">ErrUserPhone   = NewError(20101, &quot;用户手机号不合法&quot;)</span><br><span class="line">ErrUserCaptcha = NewError(20102, &quot;用户验证码有误&quot;)</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="错误码规则"><a href="#错误码规则" class="headerlink" title="错误码规则"></a>错误码规则</h2><ul><li>错误码需在 <code>code.go</code> 文件中定义。</li><li>错误码需为 &gt; 0 的数，反之表示正确。</li></ul><h4 id="错误码为-5-位数"><a href="#错误码为-5-位数" class="headerlink" title="错误码为 5 位数"></a>错误码为 5 位数</h4><table><thead><tr><th align="left">1</th><th align="left">01</th><th align="left">01</th></tr></thead><tbody><tr><td align="left">服务级错误码</td><td align="left">模块级错误码</td><td align="left">具体错误码</td></tr></tbody></table><ul><li>服务级别错误码：1 位数进行表示，比如 1 为系统级错误；2 为普通错误，通常是由用户非法操作引起。</li><li>模块级错误码：2 位数进行表示，比如 01 为用户模块；02 为订单模块。</li><li>具体错误码：2 位数进行表示，比如 01 为手机号不合法；02 为验证码输入错误。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;改之前&quot;&gt;&lt;a href=&quot;#改之前&quot; class=&quot;headerlink&quot; title=&quot;改之前&quot;&gt;&lt;/a&gt;改之前&lt;/h2&gt;&lt;p&gt;在使用 &lt;code&gt;gin&lt;/code&gt; 开发接口的时候，返回接口数据是这样写的。&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="gin框架" scheme="https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
