<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://github.com/atom.xml" rel="self"/>
  
  <link href="https://github.com/"/>
  <updated>2022-05-11T09:47:16.798Z</updated>
  <id>https://github.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>gin日志记录</title>
    <link href="https://github.com/2019/01/05/gin-log/"/>
    <id>https://github.com/2019/01/05/gin-log/</id>
    <published>2019-01-05T13:22:50.000Z</published>
    <updated>2022-05-11T09:47:16.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>上篇文章分享了 Gin 框架的路由配置，这篇文章分享日志记录。</p><p>查了很多资料，Go 的日志记录用的最多的还是 <code>github.com/sirupsen/logrus</code>。</p><blockquote><p>Logrus is a structured logger for Go (golang), completely API compatible with the standard library logger.</p></blockquote><p>Gin 框架的日志默认只会在控制台输出，咱们利用 <code>Logrus</code> 封装一个中间件，将日志记录到文件中。</p><p>这篇文章就是学习和使用 <code>Logrus</code> 。</p><h2 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h2><p>比如，我们约定日志格式为 Text，包含字段如下：</p><p><code>请求时间</code>、<code>日志级别</code>、<code>状态码</code>、<code>执行时间</code>、<code>请求IP</code>、<code>请求方式</code>、<code>请求路由</code>。</p><p>接下来，咱们利用 <code>Logrus</code> 实现它。</p><h2 id="Logrus-使用"><a href="#Logrus-使用" class="headerlink" title="Logrus 使用"></a>Logrus 使用</h2><p>用 <code>dep</code> 方式进行安装。</p><p>在 <code>Gopkg.toml</code> 文件新增：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[constraint]]</span><br><span class="line">  name = &quot;github.com/sirupsen/logrus&quot;</span><br><span class="line">  version = &quot;1.4.2&quot;</span><br></pre></td></tr></table></figure><p>在项目中导入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;github.com/sirupsen/logrus&quot;</span><br></pre></td></tr></table></figure><p>在项目命令行执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dep ensure</span><br></pre></td></tr></table></figure><p>这时，在 <code>vendor/github.com/</code> 目录中就会看到 <code>sirupsen</code> 目录。</p><p>准备上手用了，上手之前咱们先规划一下，将这个功能设置成一个中间件，比如：<code>logger.go</code>。</p><p>日志可以记录到 File 中，定义一个 <code>LoggerToFile</code> 方法。</p><p>日志可以记录到 MongoDB 中，定义一个 <code>LoggerToMongo</code> 方法。</p><p>日志可以记录到 ES 中，定义一个 <code>LoggerToES</code> 方法。</p><p>日志可以记录到 MQ 中，定义一个 <code>LoggerToMQ</code> 方法。</p><p>…</p><p>这次咱们先实现记录到文件， 实现 <code>LoggerToFile</code> 方法，其他的可以根据自己的需求进行实现。</p><p>这个 <code>logger</code> 中间件，创建好了，可以任意在其他项目中进行迁移使用。</p><p>废话不多说，直接看代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package middleware</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;ginDemo/config&quot;</span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">&quot;github.com/sirupsen/logrus&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;path&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 日志记录到文件</span><br><span class="line">func LoggerToFile() gin.HandlerFunc &#123;</span><br><span class="line"></span><br><span class="line">logFilePath := config.Log_FILE_PATH</span><br><span class="line">logFileName := config.LOG_FILE_NAME</span><br><span class="line"></span><br><span class="line">//日志文件</span><br><span class="line">fileName := path.Join(logFilePath, logFileName)</span><br><span class="line"></span><br><span class="line">//写入文件</span><br><span class="line">src, err := os.OpenFile(fileName, os.O_APPEND|os.O_WRONLY, os.ModeAppend)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;err&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实例化</span><br><span class="line">logger := logrus.New()</span><br><span class="line"></span><br><span class="line">//设置输出</span><br><span class="line">logger.Out = src</span><br><span class="line"></span><br><span class="line">//设置日志级别</span><br><span class="line">logger.SetLevel(logrus.DebugLevel)</span><br><span class="line"></span><br><span class="line">//设置日志格式</span><br><span class="line">logger.SetFormatter(&amp;logrus.TextFormatter&#123;&#125;)</span><br><span class="line"></span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line">// 开始时间</span><br><span class="line">startTime := time.Now()</span><br><span class="line"></span><br><span class="line">// 处理请求</span><br><span class="line">c.Next()</span><br><span class="line"></span><br><span class="line">// 结束时间</span><br><span class="line">endTime := time.Now()</span><br><span class="line"></span><br><span class="line">// 执行时间</span><br><span class="line">latencyTime := endTime.Sub(startTime)</span><br><span class="line"></span><br><span class="line">// 请求方式</span><br><span class="line">reqMethod := c.Request.Method</span><br><span class="line"></span><br><span class="line">// 请求路由</span><br><span class="line">reqUri := c.Request.RequestURI</span><br><span class="line"></span><br><span class="line">// 状态码</span><br><span class="line">statusCode := c.Writer.Status()</span><br><span class="line"></span><br><span class="line">// 请求IP</span><br><span class="line">clientIP := c.ClientIP()</span><br><span class="line"></span><br><span class="line">// 日志格式</span><br><span class="line">logger.Infof(&quot;| %3d | %13v | %15s | %s | %s |&quot;,</span><br><span class="line">statusCode,</span><br><span class="line">latencyTime,</span><br><span class="line">clientIP,</span><br><span class="line">reqMethod,</span><br><span class="line">reqUri,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 日志记录到 MongoDB</span><br><span class="line">func LoggerToMongo() gin.HandlerFunc &#123;</span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 日志记录到 ES</span><br><span class="line">func LoggerToES() gin.HandlerFunc &#123;</span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 日志记录到 MQ</span><br><span class="line">func LoggerToMQ() gin.HandlerFunc &#123;</span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志中间件写好了，怎么调用呢？</p><p>只需在 main.go 中新增：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">engine := gin.Default() //在这行后新增</span><br><span class="line">engine.Use(middleware.LoggerToFile())</span><br></pre></td></tr></table></figure><p>运行一下，看看日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time=&quot;2019-07-17T22:10:45+08:00&quot; level=info msg=&quot;| 200 |      27.698µs |             ::1 | GET | /v1/product/add?name=a&amp;price=10 |&quot;</span><br><span class="line">time=&quot;2019-07-17T22:10:46+08:00&quot; level=info msg=&quot;| 200 |      27.239µs |             ::1 | GET | /v1/product/add?name=a&amp;price=10 |&quot;</span><br></pre></td></tr></table></figure><p><strong>这个 <code>time=&quot;2019-07-17T22:10:45+08:00&quot;</code>  ，这个时间格式不是咱们想要的，怎么办？</strong></p><p>时间需要格式化一下，修改 <code>logger.SetFormatter</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置日志格式</span><br><span class="line">logger.SetFormatter(&amp;logrus.TextFormatter&#123;</span><br><span class="line">TimestampFormat:&quot;2006-01-02 15:04:05&quot;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行以下，再看日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time=&quot;2019-07-17 22:15:57&quot; level=info msg=&quot;| 200 |     185.027µs |             ::1 | GET | /v1/product/add?name=a&amp;price=10 |&quot;</span><br><span class="line">time=&quot;2019-07-17 22:15:58&quot; level=info msg=&quot;| 200 |      56.989µs |             ::1 | GET | /v1/product/add?name=a&amp;price=10 |&quot;</span><br></pre></td></tr></table></figure><p>时间变得正常了。</p><p><strong>我不喜欢文本格式，喜欢 JSON 格式，怎么办？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置日志格式</span><br><span class="line">logger.SetFormatter(&amp;logrus.JSONFormatter&#123;</span><br><span class="line">TimestampFormat:&quot;2006-01-02 15:04:05&quot;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行以下，再看日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;| 200 |       24.78µs |             ::1 | GET | /v1/product/add?name=a\u0026price=10 |&quot;,&quot;time&quot;:&quot;2019-07-17 22:23:55&quot;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;| 200 |      26.946µs |             ::1 | GET | /v1/product/add?name=a\u0026price=10 |&quot;,&quot;time&quot;:&quot;2019-07-17 22:23:56&quot;&#125;</span><br></pre></td></tr></table></figure><p><strong>msg 信息太多，不方便看，怎么办？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 日志格式</span><br><span class="line">logger.WithFields(logrus.Fields&#123;</span><br><span class="line">&quot;status_code&quot;  : statusCode,</span><br><span class="line">&quot;latency_time&quot; : latencyTime,</span><br><span class="line">&quot;client_ip&quot;    : clientIP,</span><br><span class="line">&quot;req_method&quot;   : reqMethod,</span><br><span class="line">&quot;req_uri&quot;      : reqUri,</span><br><span class="line">&#125;).Info()</span><br></pre></td></tr></table></figure><p>执行以下，再看日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;client_ip&quot;:&quot;::1&quot;,&quot;latency_time&quot;:26681,&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;&quot;,&quot;req_method&quot;:&quot;GET&quot;,&quot;req_uri&quot;:&quot;/v1/product/add?name=a\u0026price=10&quot;,&quot;status_code&quot;:200,&quot;time&quot;:&quot;2019-07-17 22:37:54&quot;&#125;</span><br><span class="line">&#123;&quot;client_ip&quot;:&quot;::1&quot;,&quot;latency_time&quot;:24315,&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;&quot;,&quot;req_method&quot;:&quot;GET&quot;,&quot;req_uri&quot;:&quot;/v1/product/add?name=a\u0026price=10&quot;,&quot;status_code&quot;:200,&quot;time&quot;:&quot;2019-07-17 22:37:55&quot;&#125;</span><br></pre></td></tr></table></figure><p>说明一下：<code>time</code>、<code>msg</code>、<code>level</code> 这些参数是 logrus 自动加上的。</p><p><strong>logrus 支持输出文件名和行号吗？</strong></p><p>不支持，作者的回复是太耗性能。</p><p>不过网上也有人通过 Hook 的方式实现了，选择在生产环境使用的时候，记得做性能测试。</p><p><strong>logrus 支持日志分割吗？</strong></p><p>不支持，但有办法实现它。</p><p>1、可以利用 <code>Linux logrotate</code>，统一由运维进行处理。</p><p>2、可以利用 <code>file-rotatelogs</code> 实现。</p><p>需要导入包：</p><p><code>github.com/lestrrat-go/file-rotatelogs</code></p><p><code>github.com/rifflock/lfshook</code></p><p>奉上完整代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">package middleware</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;ginDemo/config&quot;</span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">rotatelogs &quot;github.com/lestrrat-go/file-rotatelogs&quot;</span><br><span class="line">&quot;github.com/rifflock/lfshook&quot;</span><br><span class="line">&quot;github.com/sirupsen/logrus&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;path&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 日志记录到文件</span><br><span class="line">func LoggerToFile() gin.HandlerFunc &#123;</span><br><span class="line"></span><br><span class="line">logFilePath := config.Log_FILE_PATH</span><br><span class="line">logFileName := config.LOG_FILE_NAME</span><br><span class="line"></span><br><span class="line">// 日志文件</span><br><span class="line">fileName := path.Join(logFilePath, logFileName)</span><br><span class="line"></span><br><span class="line">// 写入文件</span><br><span class="line">src, err := os.OpenFile(fileName, os.O_APPEND|os.O_WRONLY, os.ModeAppend)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;err&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实例化</span><br><span class="line">logger := logrus.New()</span><br><span class="line"></span><br><span class="line">// 设置输出</span><br><span class="line">logger.Out = src</span><br><span class="line"></span><br><span class="line">// 设置日志级别</span><br><span class="line">logger.SetLevel(logrus.DebugLevel)</span><br><span class="line"></span><br><span class="line">// 设置 rotatelogs</span><br><span class="line">logWriter, err := rotatelogs.New(</span><br><span class="line">// 分割后的文件名称</span><br><span class="line">fileName + &quot;.%Y%m%d.log&quot;,</span><br><span class="line"></span><br><span class="line">// 生成软链，指向最新日志文件</span><br><span class="line">rotatelogs.WithLinkName(fileName),</span><br><span class="line"></span><br><span class="line">// 设置最大保存时间(7天)</span><br><span class="line">rotatelogs.WithMaxAge(7*24*time.Hour),</span><br><span class="line"></span><br><span class="line">// 设置日志切割时间间隔(1天)</span><br><span class="line">rotatelogs.WithRotationTime(24*time.Hour),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">writeMap := lfshook.WriterMap&#123;</span><br><span class="line">logrus.InfoLevel:  logWriter,</span><br><span class="line">logrus.FatalLevel: logWriter,</span><br><span class="line">logrus.DebugLevel: logWriter,</span><br><span class="line">logrus.WarnLevel:  logWriter,</span><br><span class="line">logrus.ErrorLevel: logWriter,</span><br><span class="line">logrus.PanicLevel: logWriter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lfHook := lfshook.NewHook(writeMap, &amp;logrus.JSONFormatter&#123;</span><br><span class="line">TimestampFormat:&quot;2006-01-02 15:04:05&quot;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 新增 Hook</span><br><span class="line">logger.AddHook(lfHook)</span><br><span class="line"></span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line">// 开始时间</span><br><span class="line">startTime := time.Now()</span><br><span class="line"></span><br><span class="line">// 处理请求</span><br><span class="line">c.Next()</span><br><span class="line"></span><br><span class="line">// 结束时间</span><br><span class="line">endTime := time.Now()</span><br><span class="line"></span><br><span class="line">// 执行时间</span><br><span class="line">latencyTime := endTime.Sub(startTime)</span><br><span class="line"></span><br><span class="line">// 请求方式</span><br><span class="line">reqMethod := c.Request.Method</span><br><span class="line"></span><br><span class="line">// 请求路由</span><br><span class="line">reqUri := c.Request.RequestURI</span><br><span class="line"></span><br><span class="line">// 状态码</span><br><span class="line">statusCode := c.Writer.Status()</span><br><span class="line"></span><br><span class="line">// 请求IP</span><br><span class="line">clientIP := c.ClientIP()</span><br><span class="line"></span><br><span class="line">// 日志格式</span><br><span class="line">logger.WithFields(logrus.Fields&#123;</span><br><span class="line">&quot;status_code&quot;  : statusCode,</span><br><span class="line">&quot;latency_time&quot; : latencyTime,</span><br><span class="line">&quot;client_ip&quot;    : clientIP,</span><br><span class="line">&quot;req_method&quot;   : reqMethod,</span><br><span class="line">&quot;req_uri&quot;      : reqUri,</span><br><span class="line">&#125;).Info()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 日志记录到 MongoDB</span><br><span class="line">func LoggerToMongo() gin.HandlerFunc &#123;</span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 日志记录到 ES</span><br><span class="line">func LoggerToES() gin.HandlerFunc &#123;</span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 日志记录到 MQ</span><br><span class="line">func LoggerToMQ() gin.HandlerFunc &#123;</span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时会新生成一个文件 <code>system.log.20190717.log</code>，日志内容与上面的格式一致。</p><p>最后，<code>logrus</code> 可扩展的 Hook 很多，大家可以去网上查找。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;上篇文章分享了 Gin 框架的路由配置，这篇文章分享日志记录。&lt;/p&gt;
&lt;p&gt;查了很多资料，Go 的日志记录用的最多的还是 &lt;code&gt;gi</summary>
      
    
    
    
    <category term="Go开发" scheme="https://github.com/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://github.com/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>路由配置</title>
    <link href="https://github.com/2018/12/20/gin-router/"/>
    <id>https://github.com/2018/12/20/gin-router/</id>
    <published>2018-12-20T12:22:50.000Z</published>
    <updated>2022-05-11T09:47:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这篇文章分享 Gin 的路由配置，主要包含的功能点如下：</p><ul><li>实现了，路由分组 v1版本、v2版本。</li><li>实现了，生成签名和验证验证。</li><li>实现了，在配置文件中读取配置。</li></ul><h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><p>比如我们的接口地址是这样的：</p><ul><li><code>/v1/product/add</code></li><li><code>/v1/member/add</code></li><li><code>/v2/product/add</code></li><li><code>/v2/member/add</code></li></ul><p>假设需求是这样的，接口支持多种请求方式，v1 不需签名验证，v2 需要签名验证，路由文件应该这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package router</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;ginDemo/common&quot;</span><br><span class="line">&quot;ginDemo/controller/v1&quot;</span><br><span class="line">&quot;ginDemo/controller/v2&quot;</span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">&quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func InitRouter(r *gin.Engine)  &#123;</span><br><span class="line"></span><br><span class="line">r.GET(&quot;/sn&quot;, SignDemo)</span><br><span class="line"></span><br><span class="line">// v1 版本</span><br><span class="line">GroupV1 := r.Group(&quot;/v1&quot;)</span><br><span class="line">&#123;</span><br><span class="line">GroupV1.Any(&quot;/product/add&quot;, v1.AddProduct)</span><br><span class="line">GroupV1.Any(&quot;/member/add&quot;, v1.AddMember)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// v2 版本</span><br><span class="line">GroupV2 := r.Group(&quot;/v2&quot;, common.VerifySign)</span><br><span class="line">&#123;</span><br><span class="line">GroupV2.Any(&quot;/product/add&quot;, v2.AddProduct)</span><br><span class="line">GroupV2.Any(&quot;/member/add&quot;, v2.AddMember)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func SignDemo(c *gin.Context) &#123;</span><br><span class="line">ts := strconv.FormatInt(common.GetTimeUnix(), 10)</span><br><span class="line">res := map[string]interface&#123;&#125;&#123;&#125;</span><br><span class="line">params := url.Values&#123;</span><br><span class="line">&quot;name&quot;  : []string&#123;&quot;a&quot;&#125;,</span><br><span class="line">&quot;price&quot; : []string&#123;&quot;10&quot;&#125;,</span><br><span class="line">&quot;ts&quot;    : []string&#123;ts&#125;,</span><br><span class="line">&#125;</span><br><span class="line">res[&quot;sn&quot;] = common.CreateSign(params)</span><br><span class="line">res[&quot;ts&quot;] = ts</span><br><span class="line">common.RetJson(&quot;200&quot;, &quot;&quot;, res, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>.Any</code> 表示支持多种请求方式。</p><p><code>controller/v1</code> 表示 v1 版本的文件。</p><p><code>controller/v2</code> 表示 v2 版本的文件。</p><p><code>SignDemo</code> 表示生成签名的Demo。</p><p>接下来，给出一些代码片段：</p><p>验证签名方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 验证签名</span><br><span class="line">func VerifySign(c *gin.Context) &#123;</span><br><span class="line">var method = c.Request.Method</span><br><span class="line">var ts int64</span><br><span class="line">var sn string</span><br><span class="line">var req url.Values</span><br><span class="line"></span><br><span class="line">if method == &quot;GET&quot; &#123;</span><br><span class="line">req = c.Request.URL.Query()</span><br><span class="line">sn = c.Query(&quot;sn&quot;)</span><br><span class="line">ts, _  = strconv.ParseInt(c.Query(&quot;ts&quot;), 10, 64)</span><br><span class="line"></span><br><span class="line">&#125; else if method == &quot;POST&quot; &#123;</span><br><span class="line">req = c.Request.PostForm</span><br><span class="line">sn = c.PostForm(&quot;sn&quot;)</span><br><span class="line">ts, _  = strconv.ParseInt(c.PostForm(&quot;ts&quot;), 10, 64)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">RetJson(&quot;500&quot;, &quot;Illegal requests&quot;, &quot;&quot;, c)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exp, _ := strconv.ParseInt(config.API_EXPIRY, 10, 64)</span><br><span class="line"></span><br><span class="line">// 验证过期时间</span><br><span class="line">if ts &gt; GetTimeUnix() || GetTimeUnix() - ts &gt;= exp &#123;</span><br><span class="line">RetJson(&quot;500&quot;, &quot;Ts Error&quot;, &quot;&quot;, c)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证签名</span><br><span class="line">if sn == &quot;&quot; || sn != CreateSign(req) &#123;</span><br><span class="line">RetJson(&quot;500&quot;, &quot;Sn Error&quot;, &quot;&quot;, c)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成签名的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 生成签名</span><br><span class="line">func CreateSign(params url.Values) string &#123;</span><br><span class="line">var key []string</span><br><span class="line">var str = &quot;&quot;</span><br><span class="line">for k := range params &#123;</span><br><span class="line">if k != &quot;sn&quot; &#123;</span><br><span class="line">key = append(key, k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(key)</span><br><span class="line">for i := 0; i &lt; len(key); i++ &#123;</span><br><span class="line">if i == 0 &#123;</span><br><span class="line">str = fmt.Sprintf(&quot;%v=%v&quot;, key[i], params.Get(key[i]))</span><br><span class="line">&#125; else &#123;</span><br><span class="line">str = str + fmt.Sprintf(&quot;&amp;%v=%v&quot;, key[i], params.Get(key[i]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 自定义签名算法</span><br><span class="line">sign := MD5(MD5(str) + MD5(config.APP_NAME + config.APP_SECRET))</span><br><span class="line">return sign</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取参数的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 获取 Get 参数</span><br><span class="line">name := c.Query(&quot;name&quot;)</span><br><span class="line">price := c.DefaultQuery(&quot;price&quot;, &quot;100&quot;)</span><br><span class="line"></span><br><span class="line">// 获取 Post 参数</span><br><span class="line">name := c.PostForm(&quot;name&quot;)</span><br><span class="line">price := c.DefaultPostForm(&quot;price&quot;, &quot;100&quot;)</span><br><span class="line"></span><br><span class="line">// 获取 Get 所有参数</span><br><span class="line">ReqGet = c.Request.URL.Query()</span><br><span class="line"></span><br><span class="line">//获取 Post 所有参数</span><br><span class="line">ReqPost = c.Request.PostForm</span><br></pre></td></tr></table></figure><p>v1 业务代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package v1</span><br><span class="line"></span><br><span class="line">import &quot;github.com/gin-gonic/gin&quot;</span><br><span class="line"></span><br><span class="line">func AddProduct(c *gin.Context)  &#123;</span><br><span class="line">// 获取 Get 参数</span><br><span class="line">name  := c.Query(&quot;name&quot;)</span><br><span class="line">price := c.DefaultQuery(&quot;price&quot;, &quot;100&quot;)</span><br><span class="line"></span><br><span class="line">c.JSON(200, gin.H&#123;</span><br><span class="line">&quot;v1&quot;    : &quot;AddProduct&quot;,</span><br><span class="line">&quot;name&quot;  : name,</span><br><span class="line">&quot;price&quot; : price,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v2 业务代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package v2</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func AddProduct(c *gin.Context)  &#123;</span><br><span class="line">// 获取 Get 参数</span><br><span class="line">name  := c.Query(&quot;name&quot;)</span><br><span class="line">price := c.DefaultQuery(&quot;price&quot;, &quot;100&quot;)</span><br><span class="line"></span><br><span class="line">c.JSON(200, gin.H&#123;</span><br><span class="line">&quot;v1&quot;    : &quot;AddProduct&quot;,</span><br><span class="line">&quot;name&quot;  : name,</span><br><span class="line">&quot;price&quot; : price,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，直接看效果吧。</p><p>访问 v1 接口：</p><p><img src="/timmy6.github.io/images/%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/2_go_1.png"></p><p>访问后，直接返回数据，不走签名验证。</p><p>访问 v2 接口：</p><p><img src="/timmy6.github.io/images/%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/2_go_2.png"></p><p>进入了这段验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 验证过期时间</span><br><span class="line">if ts &gt; GetTimeUnix() || GetTimeUnix() - ts &gt;= exp &#123;</span><br><span class="line">RetJson(&quot;500&quot;, &quot;Ts Error&quot;, &quot;&quot;, c)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改为合法的时间戳后：</p><p><img src="/timmy6.github.io/images/%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/2_go_3.png"></p><p>进入了这段验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 验证签名</span><br><span class="line">if sn == &quot;&quot; || sn != CreateSign(req) &#123;</span><br><span class="line">RetJson(&quot;500&quot;, &quot;Sn Error&quot;, &quot;&quot;, c)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改为合法的签名后：</p><p><img src="/timmy6.github.io/images/%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/2_go_4.png"></p><p>至此，简单的路由配置已经实现了。</p><p>对了，还有一个点没说，就是如何读取配置文件中的配置，我是这样做的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package config</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">PORT       = &quot;:8080&quot;</span><br><span class="line">APP_NAME   = &quot;ginDemo&quot;</span><br><span class="line">APP_SECRET = &quot;6YJSuc50uJ18zj45&quot;</span><br><span class="line">API_EXPIRY = &quot;120&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>引入 config 包，直接 <code>config.xx</code> 即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;这篇文章分享 Gin 的路由配置，主要包含的功能点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现了，路由分组 v1版本、v2版本。&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="Go开发" scheme="https://github.com/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://github.com/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>使用 sync.WaitGroup 来实现并发操作</title>
    <link href="https://github.com/2018/12/15/sync-WaitGroup/"/>
    <id>https://github.com/2018/12/15/sync-WaitGroup/</id>
    <published>2018-12-15T12:22:50.000Z</published>
    <updated>2022-05-11T09:47:04.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果你有一个任务可以分解成多个子任务进行处理，同时每个子任务没有先后执行顺序的限制，等到全部子任务执行完毕后，再进行下一步处理。这时每个子任务的执行可以并发处理，这种情景下适合使用 <code>sync.WaitGroup</code>。</p><p>虽然 <code>sync.WaitGroup</code> 使用起来比较简单，但是一不留神很有可能踩到坑里。</p><h2 id="sync-WaitGroup-正确使用"><a href="#sync-WaitGroup-正确使用" class="headerlink" title="sync.WaitGroup 正确使用"></a>sync.WaitGroup 正确使用</h2><p>比如，有一个任务需要执行 3 个子任务，那么可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">wg.Add(3)</span><br><span class="line"></span><br><span class="line">go handlerTask1(&amp;wg)</span><br><span class="line">go handlerTask2(&amp;wg)</span><br><span class="line">go handlerTask3(&amp;wg)</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;全部任务执行完毕.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handlerTask1(wg *sync.WaitGroup) &#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">fmt.Println(&quot;执行任务 1&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handlerTask2(wg *sync.WaitGroup) &#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">fmt.Println(&quot;执行任务 2&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handlerTask3(wg *sync.WaitGroup) &#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">fmt.Println(&quot;执行任务 3&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行任务 3</span><br><span class="line">执行任务 1</span><br><span class="line">执行任务 2</span><br><span class="line">全部任务执行完毕.</span><br></pre></td></tr></table></figure><h2 id="sync-WaitGroup-闭坑指南"><a href="#sync-WaitGroup-闭坑指南" class="headerlink" title="sync.WaitGroup 闭坑指南"></a>sync.WaitGroup 闭坑指南</h2><h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 正确</span><br><span class="line">go handlerTask1(&amp;wg)</span><br><span class="line"></span><br><span class="line">// 错误</span><br><span class="line">go handlerTask1(wg)</span><br></pre></td></tr></table></figure><p>执行子任务时，使用的 <code>sync.WaitGroup</code> 一定要是 <code>wg</code> 的引用类型！</p><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><p>注意不要将 <code>wg.Add()</code> 放在 <code>go handlerTask1(&amp;wg)</code> 中！</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 错误</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">go handlerTask1(&amp;wg)</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">func handlerTask1(wg *sync.WaitGroup) &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">defer wg.Done()</span><br><span class="line">fmt.Println(&quot;执行任务 1&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>wg.Add()</code> 一定要在 <code>wg.Wait()</code> 执行前执行！</p><h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><p>注意 <code>wg.Add()</code> 和 <code>wg.Done()</code> 的计数器保持一致！其实 <code>wg.Done()</code> 就是执行的 <code>wg.Add(-1)</code> 。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>sync.WaitGroup</code> 使用起来比较简单，一定要注意不要踩到坑里。</p><p>其实 <code>sync.WaitGroup</code> 使用场景比较局限，仅适用于等待全部子任务执行完毕后，再进行下一步处理，如果需求是当第一个子任务执行失败时，通知其他子任务停止运行，这时 <code>sync.WaitGroup</code> 是无法满足的，需要使用到通知机制（<code>channel</code>）。</p><p>以上，希望对你能够有所帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;如果你有一个任务可以分解成多个子任务进行处理，同时每个子任务没有先后执行顺序的限制，等到全部子任务执行完毕后，再进行下一步处理。这时每个子任</summary>
      
    
    
    
    <category term="Go开发" scheme="https://github.com/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://github.com/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>使用sync.Map来解决map的并发操作问题</title>
    <link href="https://github.com/2018/12/12/sync-map/"/>
    <id>https://github.com/2018/12/12/sync-map/</id>
    <published>2018-12-12T12:22:50.000Z</published>
    <updated>2022-05-11T09:46:56.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <code>Golang</code> 中 <code>map</code> 不是并发安全的，自 1.9 才引入了 <code>sync.Map</code> ，<code>sync.Map</code> 的引入确实解决了 <code>map</code> 的并发安全问题，不过 <code>sync.Map</code> 却没有实现 <code>len()</code> 函数，如果想要计算 <code>sync.Map</code> 的长度，稍微有点麻烦，需要使用 <code>Range</code> 函数。</p><h2 id="map-并发操作出现问题"><a href="#map-并发操作出现问题" class="headerlink" title="map 并发操作出现问题"></a>map 并发操作出现问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">demo := make(map[int]int)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">for j := 0; j &lt; 1000; j++ &#123;</span><br><span class="line">demo[j] = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">for j := 0; j &lt; 1000; j++ &#123;</span><br><span class="line">fmt.Println(demo[j])</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second * 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: concurrent map read and map write</span><br></pre></td></tr></table></figure><h2 id="sync-Map-解决并发操作问题"><a href="#sync-Map-解决并发操作问题" class="headerlink" title="sync.Map 解决并发操作问题"></a>sync.Map 解决并发操作问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">demo := sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">for j := 0; j &lt; 1000; j++ &#123;</span><br><span class="line">demo.Store(j, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">for j := 0; j &lt; 1000; j++ &#123;</span><br><span class="line">fmt.Println(demo.Load(j))</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second * 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;nil&gt; false</span><br><span class="line">1 true</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">999 true</span><br></pre></td></tr></table></figure><h2 id="计算-map-长度"><a href="#计算-map-长度" class="headerlink" title="计算 map 长度"></a>计算 map 长度</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">demo := make(map[int]int)</span><br><span class="line"></span><br><span class="line">for j := 0; j &lt; 1000; j++ &#123;</span><br><span class="line">demo[j] = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;len of demo:&quot;, len(demo))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len of demo: 1000</span><br></pre></td></tr></table></figure><h2 id="计算-sync-Map-长度"><a href="#计算-sync-Map-长度" class="headerlink" title="计算 sync.Map 长度"></a>计算 sync.Map 长度</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">demo := sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line">for j := 0; j &lt; 1000; j++ &#123;</span><br><span class="line">demo.Store(j, j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lens := 0</span><br><span class="line">demo.Range(func(key, value interface&#123;&#125;) bool &#123;</span><br><span class="line">lens++</span><br><span class="line">return true</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;len of demo:&quot;, lens)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len of demo: 1000</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><code>Load</code> 加载 key 数据</li><li><code>Store</code> 更新或新增 key 数据</li><li><code>Delete</code> 删除 key 数据</li><li><code>Range</code> 遍历数据</li><li><code>LoadOrStore</code> 如果存在 key 数据则返回，反之则设置</li><li><code>LoadAndDelete</code> 如果存在 key 数据则删除</li></ol><p>以上，希望对你能够有所帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;code&gt;Golang&lt;/code&gt; 中 &lt;code&gt;map&lt;/code&gt; 不是并发安全的，自 1.9 才引入了 &lt;code&gt;sync</summary>
      
    
    
    
    <category term="Go开发" scheme="https://github.com/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://github.com/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>基于逃逸分析来提升程序性能</title>
    <link href="https://github.com/2018/12/10/escape/"/>
    <id>https://github.com/2018/12/10/escape/</id>
    <published>2018-12-10T11:17:50.000Z</published>
    <updated>2022-05-11T09:46:49.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为什么需要了解逃逸分析？</p><p>因为我们想要提升程序性能，通过逃逸分析我们能够知道变量是分配到堆上还是栈上，如果分配到栈上，内存的分配和释放都是由编译器进行管理，分配和释放的速度非常快，如果分配到堆上，堆不像栈那样可以自动清理，它会引起频繁地进行垃圾回收（<code>GC</code>），而垃圾回收会占用比较大的系统开销。</p><h2 id="什么是逃逸分析？"><a href="#什么是逃逸分析？" class="headerlink" title="什么是逃逸分析？"></a>什么是逃逸分析？</h2><blockquote><p>在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法，简单来说就是分析在程序的哪些地方可以访问到该指针。</p></blockquote><p>简单的说，它是在对变量放到堆上还是栈上进行分析，该分析在编译阶段完成。如果一个变量超过了函数调用的生命周期，也就是这个变量在函数外部存在引用，编译器会把这个变量分配到堆上，这时我们就说这个变量发生逃逸了。</p><h2 id="如何确定是否逃逸？"><a href="#如何确定是否逃逸？" class="headerlink" title="如何确定是否逃逸？"></a>如何确定是否逃逸？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run -gcflags &#x27;-m -l&#x27; main.go</span><br></pre></td></tr></table></figure><h2 id="可能出现逃逸的场景"><a href="#可能出现逃逸的场景" class="headerlink" title="可能出现逃逸的场景"></a>可能出现逃逸的场景</h2><h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">Name interface&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">stu := new(Student)</span><br><span class="line">stu.Name = &quot;tom&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go run -gcflags &#x27;-m -l&#x27; 01.go</span><br><span class="line"># command-line-arguments</span><br><span class="line">./01.go:8:12: new(Student) does not escape</span><br><span class="line">./01.go:9:11: &quot;tom&quot; escapes to heap</span><br></pre></td></tr></table></figure><p><code>interface&#123;&#125;</code> 赋值，会发生逃逸，优化方案是将类型设置为固定类型，例如：<code>string</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">stu := new(Student)</span><br><span class="line">stu.Name = &quot;tom&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run -gcflags &#x27;-m -l&#x27; 01.go</span><br><span class="line"># command-line-arguments</span><br><span class="line">./01.go:8:12: new(Student) does not escape</span><br></pre></td></tr></table></figure><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func GetStudent() *Student &#123;</span><br><span class="line">stu := new(Student)</span><br><span class="line">stu.Name = &quot;tom&quot;</span><br><span class="line">return stu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">GetStudent()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分析结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run -gcflags &#x27;-m -l&#x27; 02.go</span><br><span class="line"># command-line-arguments</span><br><span class="line">./02.go:8:12: new(Student) escapes to heap</span><br></pre></td></tr></table></figure><p>返回指针类型，会发生逃逸，优化方案视情况而定。</p><p>函数传递指针和传值哪个效率高吗？我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加 <code>GC</code> 的负担，所以传递指针不一定是高效的。</p><p>不要盲目使用变量指针作为参数，虽然减少了复制，但变量逃逸的开销可能更大。</p><h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">nums := make([]int, 10000, 10000)</span><br><span class="line"></span><br><span class="line">for i := range nums &#123;</span><br><span class="line">nums[i] = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run -gcflags &#x27;-m -l&#x27; 03.go</span><br><span class="line"># command-line-arguments</span><br><span class="line">./03.go:4:14: make([]int, 10000, 10000) escapes to heap</span><br></pre></td></tr></table></figure><p>栈空间不足，会发生逃逸，优化方案尽量设置容量，如果容量实在过大那就没办法了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>逃逸分析是编译器在静态编译时完成的。</li><li>逃逸分析后可以确定哪些变量可以分配在栈上，栈的性能好。</li></ol><p>以上，希望对你能够有所帮助。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/0NVp59uI8h9WTp68wtb7XQ">Go - 使用 sync.Pool 来减少 GC 压力</a></li><li><a href="https://mp.weixin.qq.com/s/jvSbZ0_g_EFqaR2TmjjO8w">Go - 使用 options 设计模式</a></li><li><a href="https://mp.weixin.qq.com/s/ykZCZb9IAXJaKAx_cO7YjA">Go - json.Unmarshal 遇到的小坑</a></li><li><a href="https://mp.weixin.qq.com/s/-QCG61vh6NVJUWz6tOY7Gw">Go - 两个在开发中需注意的小点</a></li><li><a href="https://mp.weixin.qq.com/s/1pFVaMaWItp8zCXotQ9iBg">Go - time.RFC3339 时间格式化</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;为什么需要了解逃逸分析？&lt;/p&gt;
&lt;p&gt;因为我们想要提升程序性能，通过逃逸分析我们能够知道变量是分配到堆上还是栈上，如果分配到栈上，内存的分</summary>
      
    
    
    
    <category term="Go开发" scheme="https://github.com/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://github.com/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>不要使用 + 和 fmt.Sprintf 操作字符串</title>
    <link href="https://github.com/2018/12/05/string-append/"/>
    <id>https://github.com/2018/12/05/string-append/</id>
    <published>2018-12-05T10:17:50.000Z</published>
    <updated>2022-05-11T09:46:44.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不要使用-和-fmt-Sprintf-操作字符串"><a href="#不要使用-和-fmt-Sprintf-操作字符串" class="headerlink" title="不要使用 + 和 fmt.Sprintf 操作字符串"></a>不要使用 + 和 fmt.Sprintf 操作字符串</h2><p>不要使用 <code>+</code> 和 <code>fmt.Sprintf</code> 操作字符串，虽然很方便，但是真的很慢！</p><p>我们要使用 <code>bytes.NewBufferString</code> 进行处理。</p><p>基准测试如下：</p><h3 id=""><a href="#" class="headerlink" title="+"></a>+</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkStringOperation1(b *testing.B)  &#123;</span><br><span class="line">b.ResetTimer()</span><br><span class="line">str := &quot;&quot;</span><br><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">str += &quot;golang&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: demo/stringoperation</span><br><span class="line">cpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz</span><br><span class="line">BenchmarkStringOperation1</span><br><span class="line">BenchmarkStringOperation1-12      353318    114135 ns/op</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">Process finished with the exit code 0</span><br></pre></td></tr></table></figure><h3 id="fmt-Sprintf"><a href="#fmt-Sprintf" class="headerlink" title="fmt.Sprintf"></a>fmt.Sprintf</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkStringOperation2(b *testing.B)  &#123;</span><br><span class="line">b.ResetTimer()</span><br><span class="line">str := &quot;&quot;</span><br><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">str = fmt.Sprintf(&quot;%s%s&quot;, str, &quot;golang&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: demo/stringoperation</span><br><span class="line">cpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz</span><br><span class="line">BenchmarkStringOperation2</span><br><span class="line">BenchmarkStringOperation2-12      280140    214098 ns/op</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">Process finished with the exit code 0</span><br></pre></td></tr></table></figure><h3 id="bytes-NewBufferString"><a href="#bytes-NewBufferString" class="headerlink" title="bytes.NewBufferString"></a>bytes.NewBufferString</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkStringOperation3(b *testing.B)  &#123;</span><br><span class="line">b.ResetTimer()</span><br><span class="line">strBuf := bytes.NewBufferString(&quot;&quot;)</span><br><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">strBuf.WriteString(&quot;golang&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: demo/stringoperation</span><br><span class="line">cpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz</span><br><span class="line">BenchmarkStringOperation3</span><br><span class="line">BenchmarkStringOperation3-12    161292136         8.582 ns/op</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">Process finished with the exit code 0</span><br></pre></td></tr></table></figure><h2 id="对于固定字段的键值对，不要使用-map-string-interface"><a href="#对于固定字段的键值对，不要使用-map-string-interface" class="headerlink" title="对于固定字段的键值对，不要使用 map[string]interface{}"></a>对于固定字段的键值对，不要使用 map[string]interface{}</h2><p>对于固定字段的键值对，不要使用 <code>map[string]interface&#123;&#125;</code>!</p><p>我们要使用<code>临时 Struct</code>。</p><p>基准测试如下：</p><h3 id="map-string-interface"><a href="#map-string-interface" class="headerlink" title="map[string]interface{}"></a>map[string]interface{}</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkStructOperation1(b *testing.B) &#123;</span><br><span class="line">b.ResetTimer()</span><br><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">var demo = map[string]interface&#123;&#125;&#123;&#125;</span><br><span class="line">demo[&quot;Name&quot;] = &quot;Tom&quot;</span><br><span class="line">demo[&quot;Age&quot;] = 30</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: demo/structoperation</span><br><span class="line">cpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz</span><br><span class="line">BenchmarkStructOperation1</span><br><span class="line">BenchmarkStructOperation1-12    43300134        27.97 ns/op</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">Process finished with the exit code 0</span><br></pre></td></tr></table></figure><h3 id="临时-Struct"><a href="#临时-Struct" class="headerlink" title="临时 Struct"></a>临时 Struct</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkStructOperation2(b *testing.B) &#123;</span><br><span class="line">b.ResetTimer()</span><br><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">var demo struct &#123;</span><br><span class="line">Name string</span><br><span class="line">Age  int</span><br><span class="line">&#125;</span><br><span class="line">demo.Name = &quot;Tom&quot;</span><br><span class="line">demo.Age = 30</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">oos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: demo/structoperation</span><br><span class="line">cpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz</span><br><span class="line">BenchmarkStructOperation2</span><br><span class="line">BenchmarkStructOperation2-12    1000000000         0.2388 ns/op</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">Process finished with the exit code 0</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>你有类似这样的注意点吗，欢迎留言~ </p><p>下面推荐阅读的这几篇文章也是关于开发中需要知道的小技术点，更多技术细节和代码讨论，可以加入到我的星球。</p><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul><li><a href="https://mp.weixin.qq.com/s/jvSbZ0_g_EFqaR2TmjjO8w">函数的不定参数你是这样用吗？</a></li><li><a href="https://mp.weixin.qq.com/s/W_LsZtnjGIKQ-LB6EkRgBA">优雅地处理错误真是一门学问啊！</a></li><li><a href="https://mp.weixin.qq.com/s/6c6uapjIzJC9wmjUFyZuZA">如何设计 API 接口，实现统一格式返回？</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;不要使用-和-fmt-Sprintf-操作字符串&quot;&gt;&lt;a href=&quot;#不要使用-和-fmt-Sprintf-操作字符串&quot; class=&quot;headerlink&quot; title=&quot;不要使用 + 和 fmt.Sprintf 操作字符串&quot;&gt;&lt;/a&gt;不要使用 + 和 fmt</summary>
      
    
    
    
    <category term="Go开发" scheme="https://github.com/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://github.com/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>json.Unmarshal遇到的小坑</title>
    <link href="https://github.com/2018/11/25/json-unmarshal/"/>
    <id>https://github.com/2018/11/25/json-unmarshal/</id>
    <published>2018-11-25T10:17:50.000Z</published>
    <updated>2022-05-11T09:46:39.159Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题现象描述"><a href="#1-问题现象描述" class="headerlink" title="1.问题现象描述"></a>1.问题现象描述</h2><p>使用 <code>json.Unmarshal()</code>，反序列化时，出现了科学计数法，参考代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jsonStr := `&#123;&quot;number&quot;:1234567&#125;`</span><br><span class="line">result := make(map[string]interface&#123;&#125;)</span><br><span class="line">err := json.Unmarshal([]byte(jsonStr), &amp;result)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(result)</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// map[number:1.234567e+06]</span><br></pre></td></tr></table></figure><p>这个问题不是必现，只有当数字的位数大于 6 位时，才会变成了科学计数法。</p><h2 id="2-问题影响描述"><a href="#2-问题影响描述" class="headerlink" title="2.问题影响描述"></a>2.问题影响描述</h2><p>当数据结构未知，使用 <code>map[string]interface&#123;&#125;</code> 来接收反序列化结果时，如果数字的位数大于 6 位，都会变成科学计数法，用到的地方都会受到影响。</p><h2 id="3-引起问题的原因"><a href="#3-引起问题的原因" class="headerlink" title="3.引起问题的原因"></a>3.引起问题的原因</h2><p>从 <code>encoding/json</code> 可以找到答案，看一下这段注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// To unmarshal JSON into an interface value,</span><br><span class="line">// Unmarshal stores one of these in the interface value:</span><br><span class="line">//</span><br><span class="line">//bool, for JSON booleans</span><br><span class="line">//float64, for JSON numbers</span><br><span class="line">//string, for JSON strings</span><br><span class="line">//[]interface&#123;&#125;, for JSON arrays</span><br><span class="line">//map[string]interface&#123;&#125;, for JSON objects</span><br><span class="line">//nil for JSON null</span><br></pre></td></tr></table></figure><p>是因为当 <code>JSON</code> 中存在一个比较大的数字时，它会被解析成 <code>float64</code> 类型，就有可能会出现科学计数法的形式。</p><h2 id="4-问题的解决方案"><a href="#4-问题的解决方案" class="headerlink" title="4.问题的解决方案"></a>4.问题的解决方案</h2><p><strong>方案一</strong></p><p>强制类型转换，参考代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jsonStr := `&#123;&quot;number&quot;:1234567&#125;`</span><br><span class="line">result := make(map[string]interface&#123;&#125;)</span><br><span class="line">err := json.Unmarshal([]byte(jsonStr), &amp;result)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(int(result[&quot;number&quot;].(float64)))</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// 1234567</span><br></pre></td></tr></table></figure><p><strong>方案二</strong></p><p>尽量避免使用 <code>interface</code>，对 <code>json</code> 字符串结构定义结构体，快捷方法可使用在线工具：<code>https://mholt.github.io/json-to-go/</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Num struct &#123;</span><br><span class="line">Number int `json:&quot;number&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonStr := `&#123;&quot;number&quot;:1234567&#125;`</span><br><span class="line">var result Num</span><br><span class="line">err := json.Unmarshal([]byte(jsonStr), &amp;result)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(result)</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// &#123;1234567&#125;</span><br></pre></td></tr></table></figure><p><strong>方案三</strong></p><p>使用 <code>UseNumber()</code> 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jsonStr := `&#123;&quot;number&quot;:1234567&#125;`</span><br><span class="line">result := make(map[string]interface&#123;&#125;)</span><br><span class="line">d := json.NewDecoder(bytes.NewReader([]byte(jsonStr)))</span><br><span class="line">d.UseNumber()</span><br><span class="line">err := d.Decode(&amp;result)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(result)</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// map[number:1234567]</span><br></pre></td></tr></table></figure><p>这时一定要注意 <code>result[&quot;number&quot;]</code> 的数据类型！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(fmt.Sprintf(&quot;type: %v&quot;, reflect.TypeOf(result[&quot;number&quot;])))</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// type: json.Number</span><br></pre></td></tr></table></figure><p>通过代码可以看出 <code>json.Number</code> 其实就是字符串类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// A Number represents a JSON number literal.</span><br><span class="line">type Number string</span><br></pre></td></tr></table></figure><p>如果转换其他类型，参考如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 转成 int64</span><br><span class="line">numInt, _ := result[&quot;number&quot;].(json.Number).Int64()</span><br><span class="line">fmt.Println(fmt.Sprintf(&quot;value: %v, type: %v&quot;, numInt, reflect.TypeOf(numInt)))</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// value: 1234567, type: int64</span><br><span class="line"></span><br><span class="line">// 转成 string</span><br><span class="line">numStr := result[&quot;number&quot;].(json.Number).String()</span><br><span class="line">fmt.Println(fmt.Sprintf(&quot;value: %v, type: %v&quot;, numStr, reflect.TypeOf(numStr)))</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// value: 1234567, type: string</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-问题现象描述&quot;&gt;&lt;a href=&quot;#1-问题现象描述&quot; class=&quot;headerlink&quot; title=&quot;1.问题现象描述&quot;&gt;&lt;/a&gt;1.问题现象描述&lt;/h2&gt;&lt;p&gt;使用 &lt;code&gt;json.Unmarshal()&lt;/code&gt;，反序列化时，出现了科学计数</summary>
      
    
    
    
    <category term="Go开发" scheme="https://github.com/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://github.com/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>defer 函数</title>
    <link href="https://github.com/2018/11/15/defer/"/>
    <id>https://github.com/2018/11/15/defer/</id>
    <published>2018-11-15T11:17:50.000Z</published>
    <updated>2022-05-11T09:46:33.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>defer 函数大家肯定都用过，它在声明时不会立刻去执行，而是在函数 return 后去执行的。</p><p>它的主要应用场景有异常处理、记录日志、清理数据、释放资源 等等。</p><p>这篇文章不是分享 defer 的应用场景，而是分享使用 defer 需要注意的点。</p><p>咱们先从一道题开始，一起来感受下 …</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func calc(index string, a, b int) int &#123;</span><br><span class="line">ret := a + b</span><br><span class="line">fmt.Println(index, a, b, ret)</span><br><span class="line">return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">x := 1</span><br><span class="line">y := 2</span><br><span class="line">defer calc(&quot;A&quot;, x, calc(&quot;B&quot;, x, y))</span><br><span class="line">x = 3</span><br><span class="line">defer calc(&quot;C&quot;, x, calc(&quot;D&quot;, x, y))</span><br><span class="line">y = 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出什么？</p><p>…</p><p>接下来，先容我分享几个小例子，再进行作答。</p><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">defer fmt.Println(&quot;1&quot;)</span><br><span class="line">defer fmt.Println(&quot;2&quot;)</span><br><span class="line">defer fmt.Println(&quot;3&quot;)</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;main&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>结论：defer 函数定义的顺序 与 实际执的行顺序是相反的，也就是最先声明的最后才执行。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">var a = 1</span><br><span class="line">var b = 2</span><br><span class="line"></span><br><span class="line">defer fmt.Println(a + b)</span><br><span class="line"></span><br><span class="line">a = 2</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;main&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>稍微修改一下，再看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var a = 1</span><br><span class="line">var b = 2</span><br><span class="line"></span><br><span class="line">defer func() &#123;</span><br><span class="line">fmt.Println(a + b)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">a = 2</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;main&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>结论：闭包获取变量相当于引用传递，而非值传递。</p><p>稍微再修改一下，再看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var a = 1</span><br><span class="line">var b = 2</span><br><span class="line"></span><br><span class="line">defer func(a int, b int) &#123;</span><br><span class="line">fmt.Println(a + b)</span><br><span class="line">&#125;(a, b)</span><br><span class="line"></span><br><span class="line">a = 2</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;main&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>结论：传参是值复制。</p><p>还可以理解为：defer 调用的函数，参数的值在 defer 定义时就确定了，看下代码</p><p><code>defer fmt.Println(a + b)</code>，在这时，参数的值已经确定了。</p><p>而 defer 函数内部所使用的变量的值需要在这个函数运行时才确定，看下代码</p><p><code>defer func() &#123; fmt.Println(a + b) &#125;()</code>，a 和 b 的值在函数运行时，才能确定。</p><h2 id="Return"><a href="#Return" class="headerlink" title="Return"></a>Return</h2><h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func t1() int &#123;</span><br><span class="line">a := 1</span><br><span class="line">defer func() &#123;</span><br><span class="line">a++</span><br><span class="line">&#125;()</span><br><span class="line">return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：1</p><h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func t2() (a int) &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">a++</span><br><span class="line">&#125;()</span><br><span class="line">return 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：2</p><h4 id="三"><a href="#三" class="headerlink" title="三"></a>三</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func t3() (b int) &#123;</span><br><span class="line">a := 1</span><br><span class="line">defer func() &#123;</span><br><span class="line">a++</span><br><span class="line">&#125;()</span><br><span class="line">return 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：1</p><h4 id="四"><a href="#四" class="headerlink" title="四"></a>四</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func t4() (a int) &#123;</span><br><span class="line">defer func(a int) &#123;</span><br><span class="line">a++</span><br><span class="line">&#125;(a)</span><br><span class="line">return 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：1</p><p>结论：return 不是原子操作。</p><h2 id="os-Exit"><a href="#os-Exit" class="headerlink" title="os.Exit"></a>os.Exit</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">defer fmt.Println(&quot;1&quot;)</span><br><span class="line">fmt.Println(&quot;main&quot;)</span><br><span class="line">os.Exit(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：main</p><p>结论：当<code>os.Exit()</code>方法退出程序时，defer不会被执行。</p><h2 id="不同协程"><a href="#不同协程" class="headerlink" title="不同协程"></a>不同协程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">GoA()</span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">fmt.Println(&quot;main&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func GoA() &#123;</span><br><span class="line">defer (func()&#123;</span><br><span class="line">if err := recover(); err != nil &#123;</span><br><span class="line">fmt.Println(&quot;panic:&quot; + fmt.Sprintf(&quot;%s&quot;, err))</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">go GoB()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func GoB() &#123;</span><br><span class="line">panic(&quot;error&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GoB()</code> panic 捕获不到。</p><p>结论：defer 只对当前协程有效。</p><p>这个问题怎么解？咱们下回再说。</p><p>接下来，咱们分析下文章开头的问题吧。</p><h2 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h2><p>先列出答案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B 1 2 3</span><br><span class="line">D 3 2 5</span><br><span class="line">C 3 5 8</span><br><span class="line">A 1 3 4</span><br></pre></td></tr></table></figure><p>其实上面那道题，可以拆解为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func calc(index string, a, b int) int &#123;</span><br><span class="line">ret := a + b</span><br><span class="line">fmt.Println(index, a, b, ret)</span><br><span class="line">return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">x := 1</span><br><span class="line">y := 2</span><br><span class="line">tmp1 := calc(&quot;B&quot;, x, y)</span><br><span class="line">defer calc(&quot;A&quot;, x, tmp1)</span><br><span class="line">x = 3</span><br><span class="line">tmp2 := calc(&quot;D&quot;, x, y)</span><br><span class="line">defer calc(&quot;C&quot;, x, tmp2)</span><br><span class="line">y = 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以顺序就是：B D C A。</p><p>执行到 tmp1 时，输出：B 1 2 3。</p><p>执行到 tmp2 时，输出：D 3 2 5。</p><p>根据 defer 执行顺序原则，先声明的后执行，所以下一个该执行 C 了。</p><p>又因为传参是值赋值，所以在 A 的时候，无法用到 <code>x = 3</code> 和 <code>y = 4</code>，在 C 的时候，无法用到 <code>y = 4</code>。</p><p>执行到 C 时，输出：C 3 5 8</p><p>执行到 A 时，输出：A 1 3 4</p><p>到这，基本上 defer 就清楚了，大家可以根据自己的理解去记忆。</p><h2 id="go-gin-api-系列文章"><a href="#go-gin-api-系列文章" class="headerlink" title="go-gin-api 系列文章"></a>go-gin-api 系列文章</h2><ul><li><a href="https://mp.weixin.qq.com/s/0cozELotcpX3Gd6WPJiBbQ">7. 路由中间件 - 签名验证</a></li><li><a href="https://mp.weixin.qq.com/s/Ea28475_UTNaM9RNfgPqJA">6. 路由中间件 - Jaeger 链路追踪（实战篇）</a></li><li><a href="https://mp.weixin.qq.com/s/28UBEsLOAHDv530ePilKQA">5. 路由中间件 - Jaeger 链路追踪（理论篇）</a></li><li><a href="https://mp.weixin.qq.com/s/SconDXB_x7Gan6T0Awdh9A">4. 路由中间件 - 捕获异常</a></li><li><a href="https://mp.weixin.qq.com/s/eTygPXnrYM2xfrRQyfn8Tg">3. 路由中间件 - 日志记录</a></li><li><a href="https://mp.weixin.qq.com/s/11AuXptWGmL5QfiJArNLnA">2. 规划项目目录和参数验证</a></li><li><a href="https://mp.weixin.qq.com/s/1XNTEgZ0XGZZdxFOfR5f_A">1. 使用 go modules 初始化项目</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;defer 函数大家肯定都用过，它在声明时不会立刻去执行，而是在函数 return 后去执行的。&lt;/p&gt;
&lt;p&gt;它的主要应用场景有异常处理、</summary>
      
    
    
    
    <category term="Go开发" scheme="https://github.com/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://github.com/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>chan通道</title>
    <link href="https://github.com/2018/11/05/chan/"/>
    <id>https://github.com/2018/11/05/chan/</id>
    <published>2018-11-05T11:17:50.000Z</published>
    <updated>2022-05-11T09:46:27.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>chan 可以理解为队列，遵循先进先出的规则。</p><p>在说 chan 之前，咱们先说一下 go 关键字。</p><p>在 go 关键字后面加一个函数，就可以创建一个线程，函数可以为已经写好的函数，也可以是匿名函数。</p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;main start&quot;)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">fmt.Println(&quot;goroutine&quot;)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;main end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">main end</span><br></pre></td></tr></table></figure><p>为什么没有输出 goroutine ？</p><p>首先，我们清楚 Go 语言的线程是并发机制，不是并行机制。</p><p>那么，什么是并发，什么是并行？</p><p>并发是不同的代码块交替执行，也就是交替可以做不同的事情。</p><p>并行是不同的代码块同时执行，也就是同时可以做不同的事情。</p><p>举个生活化场景的例子：</p><p>你正在家看书，忽然电话来了，然后你接电话，通话完成后继续看书，这就是并发，看书和接电话交替做。</p><p>如果电话来了，你一边看书一遍接电话，这就是并行，看书和接电话一起做。</p><p>说回上面的例子，为什么没有输出 goroutine ？</p><p>main 函数是一个主线程，是因为主线程执行太快了，子线程还没来得及执行，所以看不到输出。</p><p>现在让主线程休眠 1 秒钟，再试试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;main start&quot;)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">fmt.Println(&quot;goroutine&quot;)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;main end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">goroutine</span><br><span class="line">main end</span><br></pre></td></tr></table></figure><p>这就对了。</p><p>接下来，看看如何使用 chan 。</p><h2 id="声明-chan"><a href="#声明-chan" class="headerlink" title="声明 chan"></a>声明 chan</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 声明不带缓冲的通道</span><br><span class="line">ch1 := make(chan string)</span><br><span class="line"></span><br><span class="line">// 声明带10个缓冲的通道</span><br><span class="line">ch2 := make(chan string, 10)</span><br><span class="line"></span><br><span class="line">// 声明只读通道</span><br><span class="line">ch3 := make(&lt;-chan string)</span><br><span class="line"></span><br><span class="line">// 声明只写通道</span><br><span class="line">ch4 := make(chan&lt;- string)</span><br></pre></td></tr></table></figure><p>注意：</p><p>不带缓冲的通道，进和出都会阻塞。</p><p>带缓冲的通道，进一次长度 +1，出一次长度 -1，如果长度等于缓冲长度时，再进就会阻塞。</p><h2 id="写入-chan"><a href="#写入-chan" class="headerlink" title="写入 chan"></a>写入 chan</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch1 := make(chan string, 10)</span><br><span class="line"></span><br><span class="line">ch1 &lt;- &quot;a&quot;</span><br></pre></td></tr></table></figure><h2 id="读取-chan"><a href="#读取-chan" class="headerlink" title="读取 chan"></a>读取 chan</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val, ok := &lt;- ch1</span><br><span class="line">// 或</span><br><span class="line">val := &lt;- ch1</span><br></pre></td></tr></table></figure><h2 id="关闭-chan"><a href="#关闭-chan" class="headerlink" title="关闭 chan"></a>关闭 chan</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(chan)</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>close 以后不能再写入，写入会出现 panic</li><li>重复 close 会出现 panic</li><li>只读的 chan 不能 close</li><li>close 以后还可以读取数据</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;main start&quot;)</span><br><span class="line">ch := make(chan string)</span><br><span class="line">ch &lt;- &quot;a&quot; // 入 chan</span><br><span class="line">go func() &#123;</span><br><span class="line">val := &lt;- ch // 出 chan</span><br><span class="line">fmt.Println(val)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(&quot;main end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure><p>What ? 这是为啥，刚开始就出师不利呀？</p><p>因为，定义的是一个无缓冲的 chan，赋值后就陷入了阻塞。</p><p>怎么解决它？</p><p>声明一个有缓冲的 chan。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;main start&quot;)</span><br><span class="line">ch := make(chan string, 1)</span><br><span class="line">ch &lt;- &quot;a&quot; // 入 chan</span><br><span class="line">go func() &#123;</span><br><span class="line">val := &lt;- ch // 出 chan</span><br><span class="line">fmt.Println(val)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(&quot;main end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">main end</span><br></pre></td></tr></table></figure><p>为啥没有输出 a , 和前面一样，主线程执行太快了，加个休眠 1 秒钟，再试试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;main start&quot;)</span><br><span class="line">ch := make(chan string, 1)</span><br><span class="line">ch &lt;- &quot;a&quot; // 入 chan</span><br><span class="line">go func() &#123;</span><br><span class="line">val := &lt;- ch // 出 chan</span><br><span class="line">fmt.Println(val)</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">fmt.Println(&quot;main end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">a</span><br><span class="line">main end</span><br></pre></td></tr></table></figure><p>这就对了。</p><p>再看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;main start&quot;)</span><br><span class="line">ch := make(chan string)</span><br><span class="line">go func() &#123;</span><br><span class="line">ch &lt;- &quot;a&quot; // 入 chan</span><br><span class="line">&#125;()</span><br><span class="line">go func() &#123;</span><br><span class="line">val := &lt;- ch // 出 chan</span><br><span class="line">fmt.Println(val)</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">fmt.Println(&quot;main end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">a</span><br><span class="line">main end</span><br></pre></td></tr></table></figure><p>再看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func producer(ch chan string) &#123;</span><br><span class="line">fmt.Println(&quot;producer start&quot;)</span><br><span class="line">ch &lt;- &quot;a&quot;</span><br><span class="line">ch &lt;- &quot;b&quot;</span><br><span class="line">ch &lt;- &quot;c&quot;</span><br><span class="line">ch &lt;- &quot;d&quot;</span><br><span class="line">fmt.Println(&quot;producer end&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;main start&quot;)</span><br><span class="line">ch := make(chan string, 3)</span><br><span class="line">go producer(ch)</span><br><span class="line"></span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">fmt.Println(&quot;main end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">producer start</span><br><span class="line">main end</span><br></pre></td></tr></table></figure><p>带缓冲的通道，如果长度等于缓冲长度时，再进就会阻塞。</p><p>再看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func producer(ch chan string) &#123;</span><br><span class="line">fmt.Println(&quot;producer start&quot;)</span><br><span class="line">ch &lt;- &quot;a&quot;</span><br><span class="line">ch &lt;- &quot;b&quot;</span><br><span class="line">ch &lt;- &quot;c&quot;</span><br><span class="line">ch &lt;- &quot;d&quot;</span><br><span class="line">fmt.Println(&quot;producer end&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func customer(ch chan string) &#123;</span><br><span class="line">for &#123;</span><br><span class="line">msg := &lt;- ch</span><br><span class="line">fmt.Println(msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;main start&quot;)</span><br><span class="line">ch := make(chan string, 3)</span><br><span class="line">go producer(ch)</span><br><span class="line">go customer(ch)</span><br><span class="line"></span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">fmt.Println(&quot;main end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">producer start</span><br><span class="line">producer end</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">main end</span><br></pre></td></tr></table></figure><p>就到这吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;chan 可以理解为队列，遵循先进先出的规则。&lt;/p&gt;
&lt;p&gt;在说 chan 之前，咱们先说一下 go 关键字。&lt;/p&gt;
&lt;p&gt;在 go 关</summary>
      
    
    
    
    <category term="Go开发" scheme="https://github.com/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://github.com/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>老项目迁移 go module 大型灾难记录</title>
    <link href="https://github.com/2018/10/26/gomod/"/>
    <id>https://github.com/2018/10/26/gomod/</id>
    <published>2018-10-26T08:17:50.000Z</published>
    <updated>2022-05-11T09:46:21.557Z</updated>
    
    <content type="html"><![CDATA[<p>最近在改造一个比较早期的一个项目，其中就涉及到用将原来 <code>Vendor</code> 管理依赖换成 <code>Go Modules</code> 来管理。 然而过程真是一波三折，在这里总结一下此次 <code>Go Modules</code> 改造中遇到的问题，以及解决方法。</p><span id="more"></span><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li><p>go version：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go version</span><br><span class="line">go version go1.16.5 darwin/amd64</span><br></pre></td></tr></table></figure></li><li><p>简化的 demo 如下,  很 “简单” 我们只要把 <code>hello world</code> 输出即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/coreos/etcd/pkg/transport&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/google/certificate-transparency-go/tls&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/qiniu/api.v7/auth/qbox&quot;</span></span><br><span class="line"><span class="string">&quot;go.etcd.io/etcd/clientv3&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;qiniupkg.com/x/log.v7&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">_ = transport.TLSInfo&#123;&#125;</span><br><span class="line"></span><br><span class="line">_ = clientv3.WatchResponse&#123;&#125;</span><br><span class="line"></span><br><span class="line">_, _ = clientv3.New(clientv3.Config&#123;&#125;)</span><br><span class="line"></span><br><span class="line">_ = qbox.NewMac(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">_ = tls.DigitallySigned&#123;&#125;</span><br><span class="line"></span><br><span class="line">_ = grpc.ClientConn&#123;&#125;</span><br><span class="line"></span><br><span class="line">log.Info(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>直接初始化，并 tidy 一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init demo-go/gomod</span><br><span class="line">go: creating new go.mod: module demo-go/gomod</span><br><span class="line">go: to add module requirements and sums:</span><br><span class="line">        go mod tidy</span><br><span class="line">   </span><br><span class="line">$ go mod tidy</span><br><span class="line">go: finding module <span class="keyword">for</span> ...</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        qiniupkg.com/x/log.v7: module qiniupkg.com/x@latest found (v1.11.5), but does not contain package qiniupkg.com/x/log.v7</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        github.com/qiniu/api.v7/auth/qbox imports</span><br><span class="line">        github.com/qiniu/x/bytes.v7/seekable: module github.com/qiniu/x@latest found (v1.11.5), but does not contain package github.com/qiniu/x/bytes.v7/seekable</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 imports</span><br><span class="line">        github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context: package github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context provided by github.com/coreos/etcd at latest version v2.3.8+incompatible but not at required version v3.3.10+incompatible</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 imports</span><br><span class="line">        github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc: package github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc provided by github.com/coreos/etcd at latest version v2.3.8+incompatible but not at required version v3.3.10+incompatible</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 imports</span><br><span class="line">        github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/credentials: package github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/credentials provided by github.com/coreos/etcd at latest version v2.3.8+incompatible but not at required version v3.3.10+incompatible</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 imports</span><br><span class="line">        github.com/coreos/etcd/storage/storagepb: package github.com/coreos/etcd/storage/storagepb provided by github.com/coreos/etcd at latest version v2.3.8+incompatible but not at required version v3.3.10+incompatible</span><br></pre></td></tr></table></figure><p>好家伙，报错了。我们先看到前两行</p><ol><li><code>qiniupkg.com/x@latest</code>  中没有 <code>qiniupkg.com/x/log.v7</code>；</li><li><code>github.com/qiniu/x@latest</code> 中没有 <code>github.com/qiniu/x/bytes.v7/seekable</code>；</li></ol><p>这看起来应该是一个问题， <code>qiniupkg.com/x</code> 和<code>github.com/qiniu/x</code>  应该是同一个包，不同镜像。于是我到 Github 看一下 <code>@lastet</code> 版本的代码，确实没有<code>bytes.v7</code> 包了。人肉查找，最后在 <code>v1.7.8</code> 版本，我们找到了 <code>bytes.v7</code> 包。  </p><p>于是，我们可以指定一下版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -replace qiniupkg.com/x=qiniupkg.com/x@v1.7.8</span><br><span class="line">go mod edit -replace github.com/qiniu/x=github.com/qiniu/x@v1.7.8</span><br></pre></td></tr></table></figure><p>继续往下看，接下来的几个问题是一类的，都是<code>etcd</code>导致的。 </p><p>意思是 <code>go.etcd.io/etcd/clientv3</code> 导入了 <code>github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context</code>, 同时 <code>github.com/coreos/etcd@v2.3.8</code>  中 提供了 <code>github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context</code> 。 但是，我们这里需要 <code>github.com/coreos/etcd@v3.3.10</code>, 而该版本并不提供  <code>github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context</code> 。</p><p>我们直接更新 etcd 到的 <code>v3.3.10</code> 试试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -replace go.etcd.io/etcd=go.etcd.io/etcd@v3.3.20+incompatible</span><br></pre></td></tr></table></figure><p>我们再 <code> go mod tidy</code> 下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ go mod tidy</span><br><span class="line">go: demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 tested by</span><br><span class="line">        go.etcd.io/etcd/clientv3.<span class="built_in">test</span> imports</span><br><span class="line">        github.com/coreos/etcd/auth imports</span><br><span class="line">        github.com/coreos/etcd/mvcc/backend imports</span><br><span class="line">        github.com/coreos/bbolt: github.com/coreos/bbolt@v1.3.6: parsing go.mod:</span><br><span class="line">        module declares its path as: go.etcd.io/bbolt</span><br><span class="line">                but was required as: github.com/coreos/bbolt</span><br></pre></td></tr></table></figure><p>这个错误和鸟窝这篇 <a href="https://colobu.com/2020/04/09/accidents-of-etcd-and-go-module/">Etcd使用go module的灾难</a>一致，<code>go.etcd.io/bbolt</code> 和 <code>github.com/coreos/bbolt</code> 包名不一致，我们替换一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -replace github.com/coreos/bbolt@v1.3.6=go.etcd.io/bbolt@v1.3.6</span><br></pre></td></tr></table></figure><p>继续，<code>go mod tidy</code> 一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ go mod tidy</span><br><span class="line">...</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 imports</span><br><span class="line">        github.com/coreos/etcd/clientv3/balancer: module github.com/coreos/etcd@latest found (v2.3.8+incompatible), but does not contain package github.com/coreos/etcd/clientv3/balancer</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 imports</span><br><span class="line">        github.com/coreos/etcd/clientv3/balancer/picker: module github.com/coreos/etcd@latest found (v2.3.8+incompatible), but does not contain package github.com/coreos/etcd/clientv3/balancer/picker</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 imports</span><br><span class="line">        github.com/coreos/etcd/clientv3/balancer/resolver/endpoint: module github.com/coreos/etcd@latest found (v2.3.8+incompatible), but does not contain package github.com/coreos/etcd/clientv3/balancer/resolver/endpoint</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 imports</span><br><span class="line">        github.com/coreos/etcd/clientv3/credentials: module github.com/coreos/etcd@latest found (v2.3.8+incompatible), but does not contain package github.com/coreos/etcd/clientv3/credentials</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 tested by</span><br><span class="line">        go.etcd.io/etcd/clientv3.<span class="built_in">test</span> imports</span><br><span class="line">        github.com/coreos/etcd/integration imports</span><br><span class="line">        github.com/coreos/etcd/proxy/grpcproxy imports</span><br><span class="line">        google.golang.org/grpc/naming: module google.golang.org/grpc@latest found (v1.39.0), but does not contain package google.golang.org/grpc/naming</span><br></pre></td></tr></table></figure><p>好家伙，又是<code>etcd</code>。 仔细一看，我们导入了<code>github.com/coreos/etcd</code> 和 <code>go.etcd.io/etcd</code> 两个版本<code>etcd</code>, 我们前面只替换了一个。现在我们把另外一个也替换了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -replace github.com/coreos/etcd=github.com/coreos/etcd@v3.3.20+incompatible</span><br></pre></td></tr></table></figure><p>再<code>go mod tidy</code>下，这个错误没有了，但还有个<code>grpc</code>的错误，继续找原因。原来是<code> google.golang.org/grpc</code> <code>v1.39.0</code> 版本没有<code> google.golang.org/grpc/naming</code> 包。 上 Github 仓库， 找了一下历史版本，<code>v1.29.1</code>上是有这个包的，我们继续替换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -replace google.golang.org/grpc=google.golang.org/grpc@v1.29.1</span><br></pre></td></tr></table></figure><p>这下，终于，<code>go mod tidy</code>通过了，可以开心的输出<code>hello world</code> 了。</p><p>然而，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line"><span class="comment"># github.com/coreos/etcd/clientv3/balancer/resolver/endpoint</span></span><br><span class="line">../../../go/pkg/mod/github.com/coreos/etcd@v3.3.20+incompatible/clientv3/balancer/resolver/endpoint/endpoint.go:114:78: undefined: resolver.BuildOption</span><br><span class="line">../../../go/pkg/mod/github.com/coreos/etcd@v3.3.20+incompatible/clientv3/balancer/resolver/endpoint/endpoint.go:182:31: undefined: resolver.ResolveNowOption</span><br><span class="line"><span class="comment"># github.com/coreos/etcd/clientv3/balancer/picker</span></span><br><span class="line">../../../go/pkg/mod/github.com/coreos/etcd@v3.3.20+incompatible/clientv3/balancer/picker/err.go:37:44: undefined: balancer.PickOptions</span><br><span class="line">../../../go/pkg/mod/github.com/coreos/etcd@v3.3.20+incompatible/clientv3/balancer/picker/roundrobin_balanced.go:55:54: undefined: balancer.PickOptions</span><br></pre></td></tr></table></figure><p>意不意外，惊不惊喜！!</p><p>原来<code>etcd</code>包依赖了<code>grpc</code>的<code>resolver</code>包，但我导入的<code>v1.29.1</code>版本的<code>grpc</code>是没有这个包的。到 <code>grpc</code><a href="https://github.com/grpc/grpc-go/blob/v1.26.0/resolver/resolver.go">仓库</a> 挨个版本看了一下，确实只有<code>v1.26.0</code>版本才声明了<code>type BuildOption</code> 。于是，我们再次使用替换大法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -replace google.golang.org/grpc=google.golang.org/grpc@v1.26.0</span><br></pre></td></tr></table></figure><p>再次<code>tidy</code>, 运行！ 终于，看到了久违的<code>hello world!</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">2021/07/20 12:27:09.642431 [INFO] /Users/razeen/wspace/github/demo-go/gomod/main.go:26: hello world</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="项目规范"><a href="#项目规范" class="headerlink" title="项目规范"></a>项目规范</h4><p>现在我们回过头看下这个 demo 项目，其实很有问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;github.com/coreos/etcd/pkg/transport&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/google/certificate-transparency-go/tls&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/qiniu/api.v7/auth/qbox&quot;</span></span><br><span class="line"><span class="string">&quot;go.etcd.io/etcd/clientv3&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;qiniupkg.com/x/log.v7&quot;</span></span><br></pre></td></tr></table></figure><p><code>etcd</code> 和 <code>qiniupkg</code>的包完全可以统一，只导入一种！而且，后来我们发现<code>log.v7</code>这包也是意外导入的….</p><p>这也是在改造我们一些老的项目时遇到的问题，以前用<code>vendor</code> <code>go get</code> 没有注意到这些问题，这是需要提前规范的。</p><h4 id="看懂-go-mod"><a href="#看懂-go-mod" class="headerlink" title="看懂 go.mod"></a>看懂 <code>go.mod</code></h4><p>我们来简单看一下，经历各种坎坷后，得出的<code>go.mod</code> 文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">module demo-<span class="keyword">go</span>/gomod</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.16</span></span><br><span class="line"></span><br><span class="line">replace qiniupkg.com/x =&gt; qiniupkg.com/x v1<span class="number">.7</span><span class="number">.8</span></span><br><span class="line"></span><br><span class="line">replace github.com/qiniu/x =&gt; github.com/qiniu/x v1<span class="number">.7</span><span class="number">.8</span></span><br><span class="line"></span><br><span class="line">replace <span class="keyword">go</span>.etcd.io/etcd =&gt; <span class="keyword">go</span>.etcd.io/etcd v3<span class="number">.3</span><span class="number">.20</span>+incompatible</span><br><span class="line"></span><br><span class="line">replace github.com/coreos/bbolt v1<span class="number">.3</span><span class="number">.6</span> =&gt; <span class="keyword">go</span>.etcd.io/bbolt v1<span class="number">.3</span><span class="number">.6</span></span><br><span class="line"></span><br><span class="line">replace github.com/coreos/etcd =&gt; github.com/coreos/etcd v3<span class="number">.3</span><span class="number">.20</span>+incompatible</span><br><span class="line"></span><br><span class="line">replace google.golang.org/grpc =&gt; google.golang.org/grpc v1<span class="number">.26</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">github.com/coreos/bbolt v1<span class="number">.3</span><span class="number">.6</span> <span class="comment">// indirect</span></span><br><span class="line">github.com/coreos/etcd v3<span class="number">.3</span><span class="number">.10</span>+incompatible</span><br><span class="line">github.com/dgrijalva/jwt-<span class="keyword">go</span> v3<span class="number">.2</span><span class="number">.0</span>+incompatible <span class="comment">// indirect</span></span><br><span class="line">github.com/google/certificate-transparency-<span class="keyword">go</span> v1<span class="number">.1</span><span class="number">.1</span></span><br><span class="line">github.com/grpc-ecosystem/<span class="keyword">go</span>-grpc-prometheus v1<span class="number">.2</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">github.com/qiniu/api.v7 v7<span class="number">.2</span><span class="number">.5</span>+incompatible</span><br><span class="line">github.com/qiniu/x v0<span class="number">.0</span><span class="number">.0</span><span class="number">-00010101000000</span><span class="number">-000000000000</span> <span class="comment">// indirect</span></span><br><span class="line">github.com/soheilhy/cmux v0<span class="number">.1</span><span class="number">.5</span> <span class="comment">// indirect</span></span><br><span class="line">github.com/xiang90/probing v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190116061207</span><span class="number">-43</span>a291ad63a2 <span class="comment">// indirect</span></span><br><span class="line"><span class="keyword">go</span>.etcd.io/etcd v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200513171258</span>-e048e166ab9c</span><br><span class="line">google.golang.org/grpc v1<span class="number">.29</span><span class="number">.1</span></span><br><span class="line">qiniupkg.com/x v0<span class="number">.0</span><span class="number">.0</span><span class="number">-00010101000000</span><span class="number">-000000000000</span></span><br><span class="line">sigs.k8s.io/yaml v1<span class="number">.2</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们先看一个常见的这几个<a href="https://golang.org/ref/mod#go-mod-file-module">指令</a>，</p><ul><li><code>module</code> 定义主模块的路径；</li><li><code>go</code> 编写该<code>mod</code>文件时的go版本；</li><li><code>require</code> 声明给定模块依赖项的最低要求版本;</li><li><code>replace</code> 手动指定的依赖模块 (可以替换全部的版本、指定的版本、本地的版本等等 )；</li></ul><p>还有就是 <code>v3.3.20+incompatible</code> 后面的 <code>+incompatible</code> , 这是指兼容的版本，指依赖库的版本是<code>v2</code> 或以上，但<code>go.mod</code>和 依赖库路径 没有按照官方指定的方式命名，会加上这个。</p><p><code>v0.0.0-00010101000000-000000000000</code> 这是一个伪版本，在和 不兼容 module 或 标记的版本不可用的时候，回打上这个伪版本。</p><p><code>// indirect</code> 这指明这些不是我们直接引用的依赖。</p><p>除此之外，以下指令也可了解一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前模块以及所有的依赖模块</span></span><br><span class="line">go list -m all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个模块的以及打标签的版本</span></span><br><span class="line">go list -m -versions go.etcd.io/etcd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级特定的包</span></span><br><span class="line">go get xx@version 升级特定的包</span><br><span class="line"></span><br><span class="line"><span class="comment"># 了解为什么需要模块</span></span><br><span class="line">go mod why -m all  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 为什么需要指定（google.golang.org/grpc）的模块</span></span><br><span class="line">go mod why -m google.golang.org/grpc</span><br></pre></td></tr></table></figure><p>更多可以细读<a href="https://golang.org/ref/mod#incompatible-versions">官方文档</a>，感谢阅读。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.golang.org/using-go-modules">Using Go Modules</a></li><li><a href="https://research.swtch.com/vgo-mvs">Minimal Version Selection</a></li><li><a href="https://colobu.com/2018/08/27/learn-go-module/">跳出Go module的泥潭</a></li><li><a href="https://colobu.com/2020/04/09/accidents-of-etcd-and-go-module/">Etcd使用go module的灾难</a></li><li><a href="https://duyanghao.github.io/golang-module/">浅谈Go Modules原理</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在改造一个比较早期的一个项目，其中就涉及到用将原来 &lt;code&gt;Vendor&lt;/code&gt; 管理依赖换成 &lt;code&gt;Go Modules&lt;/code&gt; 来管理。 然而过程真是一波三折，在这里总结一下此次 &lt;code&gt;Go Modules&lt;/code&gt; 改造中遇到的问题，以及解决方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Go开发" scheme="https://github.com/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://github.com/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Golang中的RESTful API最佳实践</title>
    <link href="https://github.com/2018/10/22/restful/"/>
    <id>https://github.com/2018/10/22/restful/</id>
    <published>2018-10-22T08:17:50.000Z</published>
    <updated>2022-05-11T09:46:15.199Z</updated>
    
    <content type="html"><![CDATA[<p>RESRful  API已经流行很多年了，我也一直在使用它。最佳实践也看过不少，但当一个项目完成，再次回顾&#x2F;梳理项目时，会发现很多API和规范还是多少有些出入。在这篇文章中，我们结合Go Web再次梳理一下RESTful API的相关最佳实践。</p><span id="more"></span><h3 id="关于RESTful-API"><a href="#关于RESTful-API" class="headerlink" title="关于RESTful API"></a>关于RESTful API</h3><p>关于什么是RESTful API，不再累述。推荐几个相关链接。</p><ul><li><a href="https://www.ruanyifeng.com/blog/2011/09/restful.html">理解RESTful架构</a></li><li><a href="https://restfulapi.net/">REST API Tutorial</a></li></ul><h3 id="1-使用JSON"><a href="#1-使用JSON" class="headerlink" title="1.使用JSON"></a>1.使用JSON</h3><p>不管是接收还是返回数据都推荐使用JSON。</p><p>通常返回数据的格式有JSON和XML，但XML过于冗长，可读性差，而且各种语言的解析上也不如JSON，使用JSON的好处，显而易见。</p><p>而接收数据，我们这里也推荐使用JSON，对于后端开发而言，入参直接与模型绑定，省去冗长的参数解析能简化不少代码，而且JSON能更简单的传递一些更复杂的结构等。</p><p>正如示例代码中的这一段，我们以<code>gin</code>框架为例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleLogin doc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleLogin</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">param := &amp;LoginParams&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := c.BindJSON(param); err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, &amp;Resp&#123;Error: <span class="string">&quot;parameters error&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做一些校验</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">session := sessions.Default(c)</span><br><span class="line">session.Set(sessionsKey, param.UserID)</span><br><span class="line">session.Save()</span><br><span class="line">c.JSON(http.StatusOK, &amp;Resp&#123;Data: <span class="string">&quot;login succeed&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>c.BindJSON</code>,轻松的将入参于模型<code>LoginParams</code>绑定；通过<code>c.JSON</code>轻松的将数据JSON序列化返回。</p><p>但所有接口都必须用JSON么？那也未必。比如文件上传，这时我们使用<code>FormData</code>比把文件base64之类的放到JSON里面更高效。</p><h3 id="2-路径中不包含动词"><a href="#2-路径中不包含动词" class="headerlink" title="2.路径中不包含动词"></a>2.路径中不包含动词</h3><p>我们的HTTP请求方法中已经有<code>GET</code>,<code>POST</code>等这些动作了，完全没有必要再路径中加上动词。</p><p>我们常用HTTP请求方法包括<code>GET</code>,<code>POST</code>,<code>PUT</code>和<code>DELETE</code>, 这也对应了我们经常需要做的数据库操作。<code>GET</code>查找&#x2F;获取资源，<code>POST</code>新增资源，<code>PUT</code>修改资源，<code>DELETE</code>删除资源。</p><p>如下，这些路径中没有任何动词，简洁明了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文章列表</span></span><br><span class="line">v1.GET(<span class="string">&quot;/articles&quot;</span>, HandleGetArticles)</span><br><span class="line"><span class="comment">// 发布文章</span></span><br><span class="line">v1.POST(<span class="string">&quot;/articles&quot;</span>, HandlePostArticles)</span><br><span class="line"><span class="comment">// 修改文章</span></span><br><span class="line">v1.PUT(<span class="string">&quot;/articles&quot;</span>, HandleUpdateArticles)</span><br><span class="line"><span class="comment">// 删除文章</span></span><br><span class="line">v1.DELETE(<span class="string">&quot;/articles/:id&quot;</span>, HandleDeleteArticles)</span><br></pre></td></tr></table></figure><h3 id="3-路径中对应资源用复数"><a href="#3-路径中对应资源用复数" class="headerlink" title="3.路径中对应资源用复数"></a>3.路径中对应资源用复数</h3><p>就像我们上面这段代码，<code>articles</code>对于的是我们的文章资源，背后就是一张数据库表<code>articles</code>, 所以操作这个资源的应该都用复数形式。</p><h3 id="4-次要资源可分层展示"><a href="#4-次要资源可分层展示" class="headerlink" title="4.次要资源可分层展示"></a>4.次要资源可分层展示</h3><p>一个博客系统中，最主要的应该是文章了，而评论应该是其子资源，我们可以评论嵌套在它的父资源后面，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取评论列表</span></span><br><span class="line">v1.GET(<span class="string">&quot;/articles/:articles_id/comments&quot;</span>, HandleGetComments)</span><br><span class="line"><span class="comment">// 添加评论</span></span><br><span class="line">v1.POST(<span class="string">&quot;/articles/:articles_id/comments&quot;</span>, HandleAddComments)</span><br><span class="line"><span class="comment">// 修改评论</span></span><br><span class="line">v1.PUT(<span class="string">&quot;/articles/:articles_id/comments/:id&quot;</span>, HandleUpdateComments)</span><br><span class="line"><span class="comment">// 删除评论</span></span><br><span class="line">v1.DELETE(<span class="string">&quot;/articles/:articles_id/comments/:id&quot;</span>, HandleDeleteComments)</span><br></pre></td></tr></table></figure><p>那么，我们需要获取所有文章的评论怎么办？可以这么写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1.GET(<span class="string">&quot;/articles/-/comments&quot;</span>, HandleGetComments)</span><br></pre></td></tr></table></figure><p>但这也不是决对的，资源虽然有层级关系，但这种层级关系不宜太深，个人感觉两层最多了，如果超过，可以直接拿出来放在一级。</p><h3 id="5-分页、排序、过滤"><a href="#5-分页、排序、过滤" class="headerlink" title="5.分页、排序、过滤"></a>5.分页、排序、过滤</h3><p>获取列表时，会使用到分页、排序过滤。一般：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?page=1&amp;page_size=10  <span class="comment"># 指定页面page与分页大小page_size</span></span><br><span class="line">?<span class="built_in">sort</span>=-create_at,+author <span class="comment"># 按照创建时间create_at降序，作者author升序排序</span></span><br><span class="line">?title=helloworld <span class="comment"># 按字段title搜索</span></span><br></pre></td></tr></table></figure><h3 id="6-统一数据格式"><a href="#6-统一数据格式" class="headerlink" title="6.统一数据格式"></a>6.统一数据格式</h3><p>不管是路径的格式，还是参数的格式，还是返回值的格式建议统一形式。</p><p>一般常用的格式有<code>蛇形</code>,<code>大驼峰</code>和<code>小驼峰</code>，个人比较喜欢<code>蛇形</code>。Anyway, 不管哪种，只要统一即可。</p><p>除了参数的命名统一外，返回的数据格式，最好统一，方便前端对接。</p><p>如下，我们定义<code>Resp</code>为通用返回数据结构，<code>Data</code>中存放返回的数据，如果出错，将错误信息放在<code>Error</code>中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Resp doc</span></span><br><span class="line"><span class="keyword">type</span> Resp <span class="keyword">struct</span> &#123;</span><br><span class="line">Data  <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">Error <span class="type">string</span>      <span class="string">`json:&quot;error&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登陆成功返回</span></span><br><span class="line">  c.JSON(http.StatusOK, &amp;Resp&#123;Data: <span class="string">&quot;login succeed&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">c.JSON(http.StatusOK, &amp;Resp&#123;Data: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">&quot;result&quot;</span>: tempStorage,</span><br><span class="line"><span class="string">&quot;total&quot;</span>:  <span class="built_in">len</span>(tempStorage),</span><br><span class="line">&#125;&#125;)</span><br><span class="line"><span class="comment">// 参数错误</span></span><br><span class="line">c.JSON(http.StatusBadRequest, &amp;Resp&#123;Error: <span class="string">&quot;parameters error&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="7-善用HTTP状态码"><a href="#7-善用HTTP状态码" class="headerlink" title="7.善用HTTP状态码"></a>7.善用HTTP状态码</h3><p>HTTP状态码有很多，我们没有必要也不可能全部用上，常用如下：</p><ul><li>200 StatusOK - 只有成功请求都返回200。</li><li>400 StatusBadRequest - 当出现参数不对，用户参数校验不通过时，给出该状态，并返回Error</li><li>401 StatusUnauthorized - 没有登陆&#x2F;经过认证</li><li>403 Forbidden - 服务端拒绝授权(如密码错误)，不允许访问</li><li>404 Not Found - 路径不存在</li><li>500 Internal Server Error - 所请求的服务器遇到意外的情况并阻止其执行请求</li><li>502 Bad Gateway - 网关或代理从上游接收到了无效的响应 </li><li>503 Service Unavailable - 服务器尚未处于可以接受请求的状态</li></ul><p>其中<code>502</code>,<code>503</code>，我们写程序时并不会明确去抛出。所以我们平常用6个状态码已经能很好的展示服务端状态了。</p><p>同时，我们将状态与返回值对应起来，<code>200</code>状态下，返回<code>Data</code>数据；其他状态返回<code>Error</code>。</p><h3 id="8-API版本化"><a href="#8-API版本化" class="headerlink" title="8.API版本化"></a>8.API版本化</h3><p>正如Demo中所示，我们将路由分组到了<code>/api/v1</code>路径下面，版本化API。如果后续的服务端升级，但可能仍有很大部分客户端请求未升级，依然请求老版本的API，那么我们只需要增加<code>/api/v2</code>，然后在该路径下为已升级的客户端提供服务。这样，我们就做到了API的版本控制，可以平滑的从一个版本切换到另外一个版本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v1 := r.Group(<span class="string">&quot;/api/v1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">v1.POST(<span class="string">&quot;/login&quot;</span>, HandleLogin)</span><br><span class="line">v1.GET(<span class="string">&quot;/articles&quot;</span>, HandleGetArticles)</span><br><span class="line">v1.GET(<span class="string">&quot;/articles/:id/comments&quot;</span>, HandleGetComments)</span><br><span class="line">   <span class="comment">// ....</span></span><br></pre></td></tr></table></figure><h3 id="9-统一-‘-x2F-‘-开头"><a href="#9-统一-‘-x2F-‘-开头" class="headerlink" title="9. 统一 ‘&#x2F;‘ 开头"></a>9. 统一 ‘&#x2F;‘ 开头</h3><p>所以路由中，路径都以’&#x2F;‘开头，虽然框架会为我们做这件事，但还是建议统一加上。</p><h3 id="10-增加-x2F-更新操作-返回资源"><a href="#10-增加-x2F-更新操作-返回资源" class="headerlink" title="10. 增加&#x2F;更新操作 返回资源"></a>10. 增加&#x2F;更新操作 返回资源</h3><p>对于<code>POST</code>,<code>PUT</code>操作，建议操作后，返回更新后的资源。</p><h3 id="11-使用HTTPS"><a href="#11-使用HTTPS" class="headerlink" title="11. 使用HTTPS"></a>11. 使用HTTPS</h3><p>对于暴露出去的接口&#x2F;OpenAPI，一定使用HTTPS。一般时候，我们可以直接在服务前面架设一个WebServer，在WebServer内部署证书即可。当然，如果是直接由后端暴露出的接口，有必要直接在后端开启HTTPS！</p><h3 id="12-规范的API文档"><a href="#12-规范的API文档" class="headerlink" title="12. 规范的API文档"></a>12. 规范的API文档</h3><p>对于我们这种前后端分离的架构，API文档是很重要。在Go中，我们很容易的能用swag结合代码注释自动生成API文档。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>API写的好不好，重要的还是看是否遵循WEB标准和保持一致性，最终目的也是让这些API更清晰，易懂，安全，希望这些建议对你有所帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;RESRful  API已经流行很多年了，我也一直在使用它。最佳实践也看过不少，但当一个项目完成，再次回顾&amp;#x2F;梳理项目时，会发现很多API和规范还是多少有些出入。在这篇文章中，我们结合Go Web再次梳理一下RESTful API的相关最佳实践。&lt;/p&gt;</summary>
    
    
    
    <category term="Go开发" scheme="https://github.com/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://github.com/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>gin文件上传与下载</title>
    <link href="https://github.com/2018/10/12/gin-file/"/>
    <id>https://github.com/2018/10/12/gin-file/</id>
    <published>2018-10-12T08:17:50.000Z</published>
    <updated>2022-05-11T09:46:09.526Z</updated>
    
    <content type="html"><![CDATA[<p>Gin是用Go编写的web框架。性能还不错，而且使用比较简单，还支持RESTful API。</p><p>日常的使用中我们可能要处理一些文件的上传与下载，我这里简单总结一下。</p><h3 id="单文件上传"><a href="#单文件上传" class="headerlink" title="单文件上传"></a>单文件上传</h3><p>我们使用<code>multipart/form-data</code>格式上传文件，利用<code>c.Request.FormFile</code>解析文件。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleUploadFile 上传单个文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleUploadFile</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">file, header, err := c.Request.FormFile(<span class="string">&quot;file&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;文件上传失败&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">content, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;文件读取失败&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(header.Filename)</span><br><span class="line">fmt.Println(<span class="type">string</span>(content))</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;上传成功&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们上传文件可以看到。</p><p><img src="https://st.razeen.me/bcj/201809/jietu20180906-002227.png" alt="jietu20180906-002227"></p><p>我们已经看到文件上传成功，已经文件名字与内容。</p><h3 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h3><p>多文件的上传利用<code>c.Request.MultipartForm</code>解析。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleUploadMutiFile 上传多个文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleUploadMutiFile</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 限制放入内存的文件大小</span></span><br><span class="line">err := c.Request.ParseMultipartForm(<span class="number">4</span> &lt;&lt; <span class="number">20</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;文件太大&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">formdata := c.Request.MultipartForm</span><br><span class="line">files := formdata.File[<span class="string">&quot;file&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> files &#123;</span><br><span class="line">file, err := v.Open()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;文件读取失败&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">content, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;文件读取失败&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(v.Filename)</span><br><span class="line">fmt.Println(<span class="type">string</span>(content))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;上传成功&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个文件，遍历文件内容即可读取。</p><p><del>利用<code>c.Request.ParseMultipartForm()</code>可设置上传文件的大小，这里限制了4MB。</del><br> <code>c.Request.ParseMultipartForm()</code>并不能限制上传文件的大小，只是限制了上传的文件读取到内存部分的大小，如果超过了就存入了系统的临时文件中。<br>如果需要限制文件大小，需要使用<code>github.com/gin-contrib/size</code>中间件，如demo中使用<code>r.Use(limits.RequestSizeLimiter(4 &lt;&lt; 20))</code>限制最大4Mb。</p><p>我们看到</p><p><img src="https://st.razeen.me/bcj/201809/jietu20180906-002143.png" alt="jietu20180906-002143"></p><p>两个文件已经上传成功。</p><h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><p>文件的下载主要是注意设置文件名，文件类型等。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleDownloadFile 下载文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleDownloadFile</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">content := c.Query(<span class="string">&quot;content&quot;</span>)</span><br><span class="line"></span><br><span class="line">content = <span class="string">&quot;hello world, 我是一个文件，&quot;</span> + content</span><br><span class="line"></span><br><span class="line">c.Writer.WriteHeader(http.StatusOK)</span><br><span class="line">c.Header(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=hello.txt&quot;</span>)</span><br><span class="line">c.Header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/text/plain&quot;</span>)</span><br><span class="line">c.Header(<span class="string">&quot;Accept-Length&quot;</span>, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, <span class="built_in">len</span>(content)))</span><br><span class="line">c.Writer.Write([]<span class="type">byte</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过</p><ul><li><code>Content-Disposition</code>设置文件名字；</li><li><code>Content-Type</code>设置文件类型，可以到<a href="http://www.runoob.com/http/http-content-type.html">这里</a>查阅；</li><li><code>Accept-Length</code>这个设置文件长度；</li><li><code>c.Writer.Write</code>写出文件。</li></ul><p>成功下载可以看到：</p><p><img src="https://st.razeen.me/bcj/201809/jietu20180906-004014.png" alt="jietu20180906-004014"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Gin是用Go编写的web框架。性能还不错，而且使用比较简单，还支持RESTful API。&lt;/p&gt;
&lt;p&gt;日常的使用中我们可能要处理一些文件的上传与下载，我这里简单总结一下。&lt;/p&gt;
&lt;h3 id=&quot;单文件上传&quot;&gt;&lt;a href=&quot;#单文件上传&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Go开发" scheme="https://github.com/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://github.com/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>gRPC在Go中的使用（三）gRPC实现TLS加密通信与流通信</title>
    <link href="https://github.com/2018/10/02/grpc3/"/>
    <id>https://github.com/2018/10/02/grpc3/</id>
    <published>2018-10-02T08:17:50.000Z</published>
    <updated>2022-05-11T09:46:03.455Z</updated>
    
    <content type="html"><![CDATA[<p>在前面的两篇博客中，我们已经知道了如何利用gRPC建立简单RPC通信。但这样简单的实现有时候满足不了我们的业务需求。在一些场景中我们需要防止数据被劫持，或是一些场景中我们希望客户端与服务器不是简单的一问一答，而是建立起一个流式的RPC通信，那么该怎么做到呢？</p><span id="more"></span><h3 id="TLS加密通信"><a href="#TLS加密通信" class="headerlink" title="TLS加密通信"></a>TLS加密通信</h3><p>TLS加密无非就是认证客户端与服务器，如果对SSL&#x2F;TLS加密通信有所了解的童鞋都知道我们首先需要两张证书。</p><p>所以作为准备工作，我们首先要申请两张测试证书。一张客户端证书，一张服务器证书。</p><h4 id="生成测试证书"><a href="#生成测试证书" class="headerlink" title="生成测试证书"></a>生成测试证书</h4><p>利用<a href="https://myssl.com/create_test_cert.html">MySSL测试证书生成工具</a>我们可以很简单的生成两张证书，如下所示：</p><p>如图，填入域名生成一张服务器证书，然后将私钥，证书链，根证书都下载下来，保存到文件。</p><p><img src="https://st.razeen.me/essay/image/grpc-demo3-001.png"></p><p>同样，生成一张客户端证书并保存。</p><p><img src="https://st.razeen.me/essay/image/grpc-demo3-002.png"></p><h4 id="客户端与服务器TLS认证"><a href="#客户端与服务器TLS认证" class="headerlink" title="客户端与服务器TLS认证"></a>客户端与服务器TLS认证</h4><p>在gRPC通信中，我们完成服务器认证与客户端认证主要使用的是grpc下的<a href="https://godoc.org/google.golang.org/grpc/credentials">credentials</a>库。下面通过实例来看看怎么使用。</p><p><a href="">代码实例</a></p><p><strong>服务端实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 加载证书和密钥 （同时能验证证书与私钥是否匹配）</span></span><br><span class="line">cert, err := tls.LoadX509KeyPair(<span class="string">&quot;certs/test_server.pem&quot;</span>, <span class="string">&quot;certs/test_server.key&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将根证书加入证书池</span></span><br><span class="line"><span class="comment">// 测试证书的根如果不加入可信池，那么测试证书将视为不可惜，无法通过验证。</span></span><br><span class="line">certPool := x509.NewCertPool()</span><br><span class="line">rootBuf, err := ioutil.ReadFile(<span class="string">&quot;certs/root.pem&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !certPool.AppendCertsFromPEM(rootBuf) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;fail to append test ca&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tlsConf := &amp;tls.Config&#123;</span><br><span class="line">ClientAuth:   tls.RequireAndVerifyClientCert,</span><br><span class="line">Certificates: []tls.Certificate&#123;cert&#125;,</span><br><span class="line">ClientCAs:    certPool,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">serverOpt := grpc.Creds(credentials.NewTLS(tlsConf))</span><br><span class="line">grpcServer := grpc.NewServer(serverOpt)</span><br><span class="line"></span><br><span class="line">pb.RegisterHelloWorldServiceServer(grpcServer, &amp;SayHelloServer&#123;&#125;)</span><br><span class="line"></span><br><span class="line">log.Println(<span class="string">&quot;Server Start...&quot;</span>)</span><br><span class="line">grpcServer.Serve(lis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端实现</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">cert, err := tls.LoadX509KeyPair(<span class="string">&quot;certs/test_client.pem&quot;</span>, <span class="string">&quot;certs/test_client.key&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 将根证书加入证书池</span></span><br><span class="line">certPool := x509.NewCertPool()</span><br><span class="line">bs, err := ioutil.ReadFile(<span class="string">&quot;certs/root.pem&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> !certPool.AppendCertsFromPEM(bs) &#123;</span><br><span class="line"><span class="built_in">panic</span>(<span class="string">&quot;fail to append test ca&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 新建凭证</span></span><br><span class="line">    <span class="comment">// ServerName 需要与服务器证书内的通用名称一致</span></span><br><span class="line">transportCreds := credentials.NewTLS(&amp;tls.Config&#123;</span><br><span class="line">ServerName:   <span class="string">&quot;server.razeen.me&quot;</span>,</span><br><span class="line">Certificates: []tls.Certificate&#123;cert&#125;,</span><br><span class="line">RootCAs:      certPool,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">dialOpt := grpc.WithTransportCredentials(transportCreds)</span><br><span class="line"></span><br><span class="line">conn, err := grpc.Dial(<span class="string">&quot;localhost:8080&quot;</span>, dialOpt)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Dial failed:%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">client := pb.NewHelloWorldServiceClient(conn)</span><br><span class="line">resp1, err := client.SayHelloWorld(context.Background(), &amp;pb.HelloWorldRequest&#123;</span><br><span class="line">Greeting: <span class="string">&quot;Hello Server 1 !!&quot;</span>,</span><br><span class="line">Infos:    <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Resp1:%+v&quot;</span>, resp1)</span><br><span class="line"></span><br><span class="line">resp2, err := client.SayHelloWorld(context.Background(), &amp;pb.HelloWorldRequest&#123;</span><br><span class="line">Greeting: <span class="string">&quot;Hello Server 2 !!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Resp2:%+v&quot;</span>, resp2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中，我们不难看出，主要是创建一个通信凭证(TransportCredentials)。利用<code>credentials</code>库的<code>NewTLS</code>方法从<code>tls</code>加载一个通信凭证用于通信。而在其中需要注意的是：</p><ul><li><p>如果你使用的是自签发的证书，注意将根加入证书池。如果你使用的是可信CA签发的证书大部分不用添加，因为系统的可信CA库已经有了。如果没有成功添加, 在通信时会出现以下错误：</p><blockquote><p> rpc error: code &#x3D; Unavailable desc &#x3D; all SubConns are in TransientFailure, latest connection error: connection error: desc &#x3D; “transport: authentication handshake failed: x509: certificate signed by unknown authority”</p></blockquote><p>或</p><blockquote><p>rpc error: code &#x3D; Unavailable desc &#x3D; all SubConns are in TransientFailure, latest connection error: connection error: desc &#x3D; “transport: authentication handshake failed: remote error: tls: bad certificate”</p></blockquote></li><li><p>客户端凭证内 <code>ServerName</code> 需要与服务器证书内的通用名称一致，如果不一致会出现如下错误：</p><blockquote><p>rpc error: code &#x3D; Unavailable desc &#x3D; all SubConns are in TransientFailure, latest connection error: connection error: desc &#x3D; “transport: authentication handshake failed: x509: certificate is valid for server.razeen.me, not xxxxx”</p></blockquote></li></ul><p>之后，我们就可安心的通信了，在私钥不泄漏的情况下，基本不再担心数据劫持问题了。</p><p><strong>这里我想多说一句：</strong>我们经常在提交代码时会直接 <code>git add .</code> ，这是个不好的习惯，有时后我们会将一些不必要的文件提交上去，特别是一些<strong>证书</strong>、<strong>私钥</strong>、<strong>密码</strong>之类的文件。</p><h3 id="流式的RPC通信"><a href="#流式的RPC通信" class="headerlink" title="流式的RPC通信"></a>流式的RPC通信</h3><p>流式PRC通信可以分为:</p><ul><li><p>服务器端流式 RPC;</p><p>客户端发送请求到服务器，拿到一个流去读取返回的消息序列。 客户端读取返回的流，直到里面没有任何消息。如：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> ListHello(HelloWorldRequest) <span class="keyword">returns</span> (stream HelloWorldResponse) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>客户端流式 RPC;</p><p>客户端写入一个消息序列并将其发送到服务器，同样也是使用流。一旦客户端完成写入消息，它等待服务器完成读取返回它的响应。如：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> SayMoreHello(stream HelloWorldRequest) <span class="keyword">returns</span> (HelloWorldResponse) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>双向流式 RPC;</p><p>双方使用读写流去发送一个消息序列。两个流独立操作，因此客户端和服务器可以以任意喜欢的顺序读写。如：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">rpc</span> SayHelloChat(stream HelloWorldRequest) <span class="keyword">returns</span> (stream HelloWorldRequest) </span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><p>从上面的定义不难看出，用<code>stream</code>可以定义一个流式消息。下面我们就通过实例来演示一下流式通信的使用方法。</p><p>首先，我们将上面三个rpc server加入<code>.proto</code> , 并且生成新的<code>.pb.go</code>代码。</p><p>在生成的代码<code>hello_world.pb.go</code>中，我们可以看到客户端接口如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> HelloWorldServiceClient <span class="keyword">interface</span> &#123;</span><br><span class="line">SayHelloWorld(ctx context.Context, in *HelloWorldRequest, opts ...grpc.CallOption) (*HelloWorldResponse, <span class="type">error</span>)</span><br><span class="line">ListHello(ctx context.Context, in *HelloWorldRequest, opts ...grpc.CallOption) (HelloWorldService_ListHelloClient, <span class="type">error</span>)</span><br><span class="line">SayMoreHello(ctx context.Context, opts ...grpc.CallOption) (HelloWorldService_SayMoreHelloClient, <span class="type">error</span>)</span><br><span class="line">SayHelloChat(ctx context.Context, opts ...grpc.CallOption) (HelloWorldService_SayHelloChatClient, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端接口如下:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorldServiceServer is the server API for HelloWorldService service.</span></span><br><span class="line"><span class="keyword">type</span> HelloWorldServiceServer <span class="keyword">interface</span> &#123;</span><br><span class="line">SayHelloWorld(context.Context, *HelloWorldRequest) (*HelloWorldResponse, <span class="type">error</span>)</span><br><span class="line">ListHello(*HelloWorldRequest, HelloWorldService_ListHelloServer) <span class="type">error</span></span><br><span class="line">SayMoreHello(HelloWorldService_SayMoreHelloServer) <span class="type">error</span></span><br><span class="line">SayHelloChat(HelloWorldService_SayHelloChatServer) <span class="type">error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在客户段的接口中，生成了<code>HelloWorldService_XXXXClient</code>接口类型。  在服务端的接口中，生成了<code>HelloWorldService_XXXXServer</code>接口类型。 我们再查看这些接口的定义，发现这这几个接口都是实现了以下几个方法中的数个：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Send(*HelloWorldRequest) <span class="type">error</span></span><br><span class="line">Recv() (*HelloWorldRequest, <span class="type">error</span>)</span><br><span class="line">CloseAndRecv() (*HelloWorldResponse, <span class="type">error</span>)</span><br><span class="line">grpc.ClientStream</span><br></pre></td></tr></table></figure><p>看其名字，我们不难知道，流式RPC的使用，或者说流的收发也就离不开这几个方法了。下面我们通过几个实例来验证一下。</p><p>在服务端，我们实现这三个接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务器端流式 RPC, 接收一次客户端请求，返回一个流</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SayHelloServer)</span></span> ListHello(in *pb.HelloWorldRequest, stream pb.HelloWorldService_ListHelloServer) <span class="type">error</span> &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Client Say: %v&quot;</span>, in.Greeting)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们返回多条数据</span></span><br><span class="line">stream.Send(&amp;pb.HelloWorldResponse&#123;Reply: <span class="string">&quot;ListHello Reply &quot;</span> + in.Greeting + <span class="string">&quot; 1&quot;</span>&#125;)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">stream.Send(&amp;pb.HelloWorldResponse&#123;Reply: <span class="string">&quot;ListHello Reply &quot;</span> + in.Greeting + <span class="string">&quot; 2&quot;</span>&#125;)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">stream.Send(&amp;pb.HelloWorldResponse&#123;Reply: <span class="string">&quot;ListHello Reply &quot;</span> + in.Greeting + <span class="string">&quot; 3&quot;</span>&#125;)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端流式 RPC， 客户端流式请求，服务器可返回一次</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SayHelloServer)</span></span> SayMoreHello(stream pb.HelloWorldService_SayMoreHelloServer) <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// 接受客户端请求</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">req, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;SayMoreHello Client Say: %v&quot;</span>, req.Greeting)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 流读取完成后，返回</span></span><br><span class="line"><span class="keyword">return</span> stream.SendAndClose(&amp;pb.HelloWorldResponse&#123;Reply: <span class="string">&quot;SayMoreHello Recv Muti Greeting&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向流式 RPC</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SayHelloServer)</span></span> SayHelloChat(stream pb.HelloWorldService_SayHelloChatServer) <span class="type">error</span> &#123;</span><br><span class="line"><span class="comment">// 开一个协程去处理客户端数据</span></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">req, err := stream.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;SayHelloChat Client Say: %v&quot;</span>, req.Greeting)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 向客户端写入多条数据</span></span><br><span class="line">stream.Send(&amp;pb.HelloWorldRequest&#123;Greeting: <span class="string">&quot;SayHelloChat Server Say Hello 1&quot;</span>&#125;)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">stream.Send(&amp;pb.HelloWorldRequest&#123;Greeting: <span class="string">&quot;SayHelloChat Server Say Hello 2&quot;</span>&#125;)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line">stream.Send(&amp;pb.HelloWorldRequest&#123;Greeting: <span class="string">&quot;SayHelloChat Server Say Hello 3&quot;</span>&#125;)</span><br><span class="line">time.Sleep(<span class="number">1</span> * time.Second)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后我们就可以在客户端分别请求这几个rpc服务。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 服务器端流式 RPC;</span></span><br><span class="line">    <span class="comment">// 我们向服务器SayHello </span></span><br><span class="line">recvListHello, err := client.ListHello(context.Background(), &amp;pb.HelloWorldRequest&#123;Greeting: <span class="string">&quot;Hello Server List Hello&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;ListHello err: %v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器以流式返回</span></span><br><span class="line">    <span class="comment">// 直到 err==io.EOF时，表示接收完毕。</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">resp, err := recvListHello.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;ListHello Server Resp: %v&quot;</span>, resp.Reply)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Client Out:</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:27:55 ListHello Server Resp: ListHello Reply Hello Server List Hello 1</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:27:56 ListHello Server Resp: ListHello Reply Hello Server List Hello 2</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:27:57 ListHello Server Resp: ListHello Reply Hello Server List Hello 3</span></span><br><span class="line"><span class="comment">// Server Out:</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:27:55 Client Say: Hello Server List Hello</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端流式 RPC;</span></span><br><span class="line">sayMoreClient, err := client.SayMoreHello(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">sayMoreClient.Send(&amp;pb.HelloWorldRequest&#123;Greeting: fmt.Sprintf(<span class="string">&quot;SayMoreHello Hello Server %d&quot;</span>, i)&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayMoreResp, err := sayMoreClient.CloseAndRecv()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">log.Printf(<span class="string">&quot;SayMoreHello Server Resp: %v&quot;</span>, sayMoreResp.Reply)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Client Out:</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:11 SayMoreHello Server Resp: SayMoreHello Recv Muti Greeting</span></span><br><span class="line"><span class="comment">// Server Out:</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:11 SayMoreHello Client Say: SayMoreHello Hello Server 0</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:11 SayMoreHello Client Say: SayMoreHello Hello Server 1</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:11 SayMoreHello Client Say: SayMoreHello Hello Server 2</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 双向流式 RPC;</span></span><br><span class="line">sayHelloChat, err := client.SayHelloChat(context.Background())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line">sayHelloChat.Send(&amp;pb.HelloWorldRequest&#123;Greeting: fmt.Sprintf(<span class="string">&quot;SayHelloChat Hello Server %d&quot;</span>, i)&#125;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">resp, err := sayHelloChat.Recv()</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;SayHelloChat Server Say: %v&quot;</span>, resp.Greeting)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Client Out:</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:11 SayHelloChat Server Say: SayHelloChat Server Say Hello 1</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:12 SayHelloChat Server Say: SayHelloChat Server Say Hello 2</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:13 SayHelloChat Server Say: SayHelloChat Server Say Hello 3</span></span><br><span class="line"><span class="comment">// Server Out:</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:11 SayHelloChat Client Say: SayHelloChat Hello Server 0</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:11 SayHelloChat Client Say: SayHelloChat Hello Server 1</span></span><br><span class="line"><span class="comment">// 2018/08/06 01:31:11 SayHelloChat Client Say: SayHelloChat Hello Server 2</span></span><br></pre></td></tr></table></figure><p>看了实例，是不是觉得很简单～。三种方式大同小异，只要掌握了怎么去收发流，怎么判断流的结束，基本就可以了。</p><p>好了，gRPC在Go中的使用三篇文章到这里也就结束了，如果博客中有错误或者你还有想知道的，记得留言哦。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在前面的两篇博客中，我们已经知道了如何利用gRPC建立简单RPC通信。但这样简单的实现有时候满足不了我们的业务需求。在一些场景中我们需要防止数据被劫持，或是一些场景中我们希望客户端与服务器不是简单的一问一答，而是建立起一个流式的RPC通信，那么该怎么做到呢？&lt;/p&gt;</summary>
    
    
    
    <category term="Go开发" scheme="https://github.com/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://github.com/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>gRPC在Go中的使用（二）gRPC实现简单通讯</title>
    <link href="https://github.com/2018/09/25/grpc2/"/>
    <id>https://github.com/2018/09/25/grpc2/</id>
    <published>2018-09-25T07:27:50.000Z</published>
    <updated>2022-05-11T09:45:57.735Z</updated>
    
    <content type="html"><![CDATA[<p>Desc:gRPC实现简单通讯,Google 开源 RPC 框架 gRPC 初探</p><p>在上一篇中，我们用protobuf定义了两个消息<code>HelloWorldRequest</code>与<code>HelloWorldResponse</code>以及一个<code>HelloWorldService</code>服务。同时，我们还生成了相应的go代码<code>.pb.go</code>。</p><p>那么客户端与服务端怎么去通过这些接口去完成通讯呢？下面我们一起实现一个简单的gRPC通讯。</p><span id="more"></span><p>在RPC通讯中，客户端使用存根(SayHelloWorld)发送请求到服务器并且等待响应返回，整个过程就像我们平常函数调用一样。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service HelloWorldService &#123;</span><br><span class="line">  rpc SayHelloWorld(HelloWorldRequest) returns (HelloWorldResponse)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么接下来，我们先创建一个服务端。</p><h3 id="创建服务端"><a href="#创建服务端" class="headerlink" title="创建服务端"></a>创建服务端</h3><p>在生成的<code>hello_world.pb.go</code>中，已经为我们生成了服务端的接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HelloWorldServiceServer is the server API for HelloWorldService service.</span></span><br><span class="line"><span class="keyword">type</span> HelloWorldServiceServer <span class="keyword">interface</span> &#123;</span><br><span class="line">SayHelloWorld(context.Context, *HelloWorldRequest) (*HelloWorldResponse, <span class="type">error</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在服务端我们首先要做的就是实现这个接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">type</span> SayHelloServer <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(s *SayHelloServer)</span></span> SayHelloWorld(ctx context.Context, in *pb.HelloWorldRequest) (res *pb.HelloWorldResponse, err <span class="type">error</span>) &#123;</span><br><span class="line">log.Printf(<span class="string">&quot;Client Greeting:%s&quot;</span>, in.Greeting)</span><br><span class="line">log.Printf(<span class="string">&quot;Client Info:%v&quot;</span>, in.Infos)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> an *any.Any</span><br><span class="line"><span class="keyword">if</span> in.Infos[<span class="string">&quot;hello&quot;</span>] == <span class="string">&quot;world&quot;</span> &#123;</span><br><span class="line">an, err = ptypes.MarshalAny(&amp;pb.HelloWorld&#123;Msg: <span class="string">&quot;Good Request&quot;</span>&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">an, err = ptypes.MarshalAny(&amp;pb.Error&#123;Msg: []<span class="type">string</span>&#123;<span class="string">&quot;Bad Request&quot;</span>, <span class="string">&quot;Wrong Info Msg&quot;</span>&#125;&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &amp;pb.HelloWorldResponse&#123;</span><br><span class="line">Reply:   <span class="string">&quot;Hello World !!&quot;</span>,</span><br><span class="line">Details: []*any.Any&#123;an&#125;,</span><br><span class="line">&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 简单如上面的几行，实现了这个接口我们只需要创建一个结构<code>SayHelloServer</code>,同时实现<code>HelloWorldServiceServer</code>的所有方法即可。</p><p>这里为了演示效果我打印了一些数据，同时利用<code>any.Any</code>在不同的情况下返回不同的类型数据。</p><p>当然，只是现实了接口还不够，我们还需要启动一个服务，这样客户端才能使用该服务。启动服务很简单，就像我们平常启用一个Server一样。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 我们首先须监听一个tcp端口</span></span><br><span class="line">lis, err := net.Listen(<span class="string">&quot;tcp&quot;</span>, <span class="string">&quot;:8080&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建一个grpc服务器</span></span><br><span class="line">grpcServer := grpc.NewServer()</span><br><span class="line">    <span class="comment">// 向grpc服务器注册SayHelloServer</span></span><br><span class="line">pb.RegisterHelloWorldServiceServer(grpcServer, &amp;SayHelloServer&#123;&#125;)</span><br><span class="line">    <span class="comment">// 启动服务</span></span><br><span class="line">grpcServer.Serve(lis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码，我们可以看到，简单的4步即可启动一个服务。</p><ol><li>监听一个服务端口，供客户端调用；</li><li>创建一个grpc服务器，当然这里可以设置<code>授权认证</code>,这个在下一篇中我们将详细介绍；</li><li>注册服务，其实是调用生存的<code>.pb.go</code>中的<code>RegisterHelloWorldServiceServer</code>方法，将我们这里实现的<code>SayHelloServer</code>加入到该服务中。</li><li>启动服务，等待客户端连接。</li></ol><p>我们<code> go run server.go</code>,无任何报错，这样一个简单的grpc服务的服务端就准备就绪了。接下来我们看看客户端。</p><h3 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h3><p>例如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 gRPC channel 和服务器交互</span></span><br><span class="line">conn, err := grpc.Dial(<span class="string">&quot;localhost:8080&quot;</span>, grpc.WithInsecure())</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatalf(<span class="string">&quot;Dial failed:%v&quot;</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> conn.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建客户端</span></span><br><span class="line">client := pb.NewHelloWorldServiceClient(conn)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 直接调用</span></span><br><span class="line">resp1, err := client.SayHelloWorld(context.Background(), &amp;pb.HelloWorldRequest&#123;</span><br><span class="line">Greeting: <span class="string">&quot;Hello Server 1 !!&quot;</span>,</span><br><span class="line">Infos:    <span class="keyword">map</span>[<span class="type">string</span>]<span class="type">string</span>&#123;<span class="string">&quot;hello&quot;</span>: <span class="string">&quot;world&quot;</span>&#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Resp1:%+v&quot;</span>, resp1)</span><br><span class="line"></span><br><span class="line">resp2, err := client.SayHelloWorld(context.Background(), &amp;pb.HelloWorldRequest&#123;</span><br><span class="line">Greeting: <span class="string">&quot;Hello Server 2 !!&quot;</span>,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">log.Printf(<span class="string">&quot;Resp2:%+v&quot;</span>, resp2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端的实现比服务端更简洁，三步即可。</p><ol><li>创建一个 gRPC channel 和服务器交互。这里也是可以设置<code>授权认证</code>的；</li><li>创建一个客户端去执行RPC。用到的也是<code>.pb.go</code>内的<code>NewHelloWorldServiceClient</code>方法；</li><li>像函数调用一样去调用RPC服务。</li></ol><p>我直接RUN起来，如下，我们可以看到客户端发送到服务的消息以及服务端对不同消息的不同回复。</p><p><img src="https://st.razeen.me/essay/image/grpc/grpc-result.png"></p><p>那么到这里，我们简单的实现了一个gRPC通讯。但很多时候，我们可能希望客户端与服务器能更安全的通信，或者客户端与服务器不再是一种固定的结构的传输，需要流式的去处理一些问题等等。针对这些问题，在下一篇博客中，我将结合实例详细说明。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Desc:gRPC实现简单通讯,Google 开源 RPC 框架 gRPC 初探&lt;/p&gt;
&lt;p&gt;在上一篇中，我们用protobuf定义了两个消息&lt;code&gt;HelloWorldRequest&lt;/code&gt;与&lt;code&gt;HelloWorldResponse&lt;/code&gt;以及一个&lt;code&gt;HelloWorldService&lt;/code&gt;服务。同时，我们还生成了相应的go代码&lt;code&gt;.pb.go&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;那么客户端与服务端怎么去通过这些接口去完成通讯呢？下面我们一起实现一个简单的gRPC通讯。&lt;/p&gt;</summary>
    
    
    
    <category term="Go开发" scheme="https://github.com/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://github.com/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>gRPC在Go中的使用（一）Protocol Buffers语法与相关使用</title>
    <link href="https://github.com/2018/09/20/grpc1/"/>
    <id>https://github.com/2018/09/20/grpc1/</id>
    <published>2018-09-20T06:07:50.000Z</published>
    <updated>2022-05-11T09:45:51.566Z</updated>
    
    <content type="html"><![CDATA[<p>Desc:protobuf语法介绍，怎么写proto文件，grpc的使用入门</p><p>在gRPC官网用了一句话来介绍:“一个高性能、开源的通用RPC框架”，同时介绍了其四大特点：</p><ul><li>定义简单</li><li>支持多种编程语言多种平台</li><li>快速启动和缩放</li><li>双向流媒体和集成身份验证</li></ul><span id="more"></span><p>在<code>gRPC在go中使用</code>系列中，关于其简介与性能我就不多介绍，相信在社区也有很多关于这些的讨论。这里我主要从三个层次来总结我以往在Go中使用gRPC的一些经验，主要分为：</p><ol><li>Protocol Buffers语法与相关使用</li><li>gRPC实现简单通讯</li><li>gRPC服务认证与双向流通讯</li></ol><p>*<em>注:下面Protocol Buffers简写protobuf.</em></p><p>这篇我们先介绍protobuf的相关语法、怎么书写<code>.proto</code>文件以及go代码生成。</p><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>要熟练的使用GRPC，protobuf的熟练使用必不可少。</p><p>gRPC使用<a href="https://github.com/google/protobuf">protobuf</a>来定义服务。protobuf是由Google开发的一种数据序列化协议，可以把它想象成是XML或JSON格式，但更小，更快更简洁。而且一次定义，可生成多种语言的代码。</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>首先我们需要编写一些<code>.proto</code>文件，定义我们在程序中需要处理的结构化数据。我们直接从一个实例开始讲起，下面是一个proto文件：</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">&quot;proto3&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">option</span> go_package = <span class="string">&quot;github.com/razeencheng/demo-go/grpc/demo1/helloworld&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> helloworld;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;github.com/golang/protobuf/ptypes/any/any.proto&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloWorldRequest</span> &#123;</span><br><span class="line">  <span class="type">string</span> greeting = <span class="number">1</span>;</span><br><span class="line">  map&lt;<span class="type">string</span>, <span class="type">string</span>&gt; infos  = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">message </span><span class="title class_">HelloWorldResponse</span> &#123;</span><br><span class="line">  <span class="type">string</span> reply = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">repeated</span> google.protobuf.Any details = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">service </span><span class="title class_">HelloWorldService</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">rpc</span> SayHelloWorld(HelloWorldRequest) <span class="keyword">returns</span> (HelloWorldResponse)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h4><p>文件的开头<code>syntax=&quot;proto3&quot;</code>也就指明版本，主要有<code>proto2</code>与<code>proto3</code>,他们在语法上有一定的差异，我这里主要使用的是后者。</p><h4 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h4><p>第二行，指定生成go文件的包名，可选项，默认使用第三行包名。</p><p>第三行，包名。</p><h4 id="导包"><a href="#导包" class="headerlink" title="导包"></a>导包</h4><p>第四行，类似你写go一样，protobuf也可以导入其他的包。</p><h4 id="消息定义"><a href="#消息定义" class="headerlink" title="消息定义"></a>消息定义</h4><p>后面message开头的两个结构就是我们需要传递的消息类型。所有的消息类型都是以<code>message</code>开始，然后定义类型名称。结构内字段的定义为<code>字段规则 字段类型 字段名=字段编号</code></p><ul><li>字段规则主要有 <code>singular</code>和<code>repeated</code>。如其中<code>greeting</code>和<code>reply</code>的字段规则为<code>singular</code>,允许该消息中出现0个或1个该字段(但不能超过一个)，而像<code>details</code>字段允许重复任意次数。其实对应到go里面也就是基本类型和切片类型。</li><li>字段类型，下表是proto内类型与go类型的对应表。</li></ul><table><thead><tr><th>.proto Type</th><th>Notes</th><th>Go Type</th></tr></thead><tbody><tr><td>double</td><td></td><td>float64</td></tr><tr><td>float</td><td></td><td>float32</td></tr><tr><td>int32</td><td>使用可变长度编码。 无效编码负数 - 如果您的字段可能具有负值， 请改用sint32。</td><td>int32</td></tr><tr><td>int64</td><td>使用可变长度编码。 无效编码负数 - 如果您的字段可能具有负值，请改用sint64。</td><td>int64</td></tr><tr><td>uint32</td><td>使用可变长度编码。</td><td>uint32</td></tr><tr><td>uint64</td><td>使用可变长度编码。</td><td>uint64</td></tr><tr><td>sint32</td><td>使用可变长度编码。 带符号的int值。 这些比常规的int32更有效地编码负数。</td><td>int32</td></tr><tr><td>sint64</td><td>使用可变长度编码。 带符号的int值。 这些比常规的int64更有效地编码负数。</td><td>int64</td></tr><tr><td>fixed32</td><td>总是四个字节。 如果值通常大于228，则比uint32效率更高。</td><td>uint32</td></tr><tr><td>fixed64</td><td>总是八个字节。 如果值通常大于256，则会比uint64更高效。</td><td>uint64</td></tr><tr><td>sfixed32</td><td>总是四个字节。</td><td>int32</td></tr><tr><td>sfixed64</td><td>总是八个字节。</td><td>int64</td></tr><tr><td>bool</td><td></td><td>bool</td></tr><tr><td>string</td><td>字符串必须始终包含UTF-8编码或7位ASCII文本。</td><td>string</td></tr><tr><td>bytes</td><td>可能包含任何字节序列。</td><td>[]byte</td></tr></tbody></table><p>看到这里你也许会疑惑，go里面的切片，map，接口等类型我怎么定义呢？别急，下面一一替你解答。</p><p>1.map类型，<code>HelloWorldRequest</code>的<code>infos</code>就是一个map类型，它的结构为<code>map&lt;key_type, value_type&gt; map_field = N</code>  但是在使用的时候你需要注意map类型不能<code>repetead</code>。</p><p>2.切片类型，我们直接定义其规则为<code>repeated</code>就可以了。就像<code>HelloWorldResponse</code>中的<code>details</code>字段一样，它就是一个切片类型。那么你会问了它是什么类型的切片？这就看下面了~</p><p>3.接口类型在proto中没有直接实现，但在<a href="https://github.com/golang/protobuf/blob/master/ptypes/any/any.proto">google&#x2F;protobuf&#x2F;any.proto</a>中定义了一个<code>google.protobuf.Any</code>类型，然后结合<a href="https://github.com/golang/protobuf/blob/master/ptypes/any.go">protobuf&#x2F;go</a>也算是曲线救国了~</p><ul><li><p>字段编号</p><p>最后的1，2代表的是每个字段在该消息中的唯一标签，在与消息二进制格式中标识这些字段，而且当你的消息在使用的时候该值不能改变。1到15都是用一个字节编码的，通常用于标签那些频繁发生修改的字段。16到2047用两个字节编码，最大的是2^29-1(536,870,911)，其中19000-19999为预留的，你也不可使用。</p></li></ul><h4 id="服务定义"><a href="#服务定义" class="headerlink" title="服务定义"></a>服务定义</h4><p>如果你要使用RPC(远程过程调用)系统的消息类型，那就需要定义RPC服务接口，protobuf编译器将会根据所选择的不同语言生成服务接口代码及存根。就如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">service HelloWorldService &#123;</span><br><span class="line">  rpc SayHelloWorld(HelloWorldRequest) returns (HelloWorldResponse)&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>protobuf编译器将产生一个抽象接口<code>HelloWorldService</code>以及一个相应的存根实现。存根将所有的调用指向RpcChannel(SayHelloWorld)，它是一个抽象接口，必须在RPC系统中对该接口进行实现。具体如何使用，将在下一篇博客中详细介绍。</p><h3 id="生成Go代码"><a href="#生成Go代码" class="headerlink" title="生成Go代码"></a>生成Go代码</h3><h4 id="安装protoc"><a href="#安装protoc" class="headerlink" title="安装protoc"></a>安装protoc</h4><p>首先要安装<code>protoc</code>,可直接到<a href="https://github.com/google/protobuf/releases/tag/v3.0.0">这里</a>下载二进制安装到 <code>$PATH</code>里面，也可以直接下载源码编译。除此之外，你还需要安装go的proto插件<code>protoc-gen-go</code>。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mac terminal</span></span><br><span class="line"><span class="keyword">go</span> get -u github.com/golang/protobuf/&#123;proto,protoc-gen-<span class="keyword">go</span>&#125;</span><br><span class="line"><span class="comment">// win powershell</span></span><br><span class="line"><span class="keyword">go</span> get -u github.com/golang/protobuf/proto</span><br><span class="line"><span class="keyword">go</span> get -u github.com/golang/protobuf/protoc-gen-<span class="keyword">go</span></span><br></pre></td></tr></table></figure><h4 id="生成go代码"><a href="#生成go代码" class="headerlink" title="生成go代码"></a>生成go代码</h4><p>接下来，使用<code>protoc</code>命令即可生成。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">### mac terminal</span></span><br><span class="line">protoc -I <span class="variable">$&#123;GOPATH&#125;</span>/src --go_out=plugins=grpc:<span class="variable">$&#123;GOPATH&#125;</span>/src <span class="variable">$&#123;GOPATH&#125;</span>/src/github.com/razeencheng/demo-go/grpc/demo1/helloworld/hello_world.proto</span><br><span class="line"><span class="comment">### win powershell</span></span><br><span class="line">protoc -I <span class="variable">$env</span>:GOPATH\src --go_out=plugins=grpc:<span class="variable">$env</span>:GOPATH\src <span class="variable">$env</span>:GOPATH\src\github.com\razeencheng\demo-go\grpc\demo1\helloworld\hello_world.proto</span><br></pre></td></tr></table></figure><p>如上所示 <code>-I</code>指定搜索proto文件的目录,<code>--go_out=plugins=grpc:</code>指定生成go代码的文件夹，后面就是需要生成的proto文件路径。</p><blockquote><p> <em>注意：</em> 如果你使用到了其他包的结构，<code>-I</code>需要将该资源包括在内。</p><p>例如我导入了<code>github.com/golang/protobuf/ptypes/any/any.proto</code> 我首先需要</p><p><code>go get -u github.com/golang/protobuf</code>获取该包，然后在使用时资源路径(<code>-I</code>)直接为<code>GOPATH\src</code>。</p></blockquote><p>最后生成的<code>hello-world.pb.go</code>文件。内容大概如下图所示</p><img src="https://st.razeen.me/essay/image/go/grpc-001.png" width="600px" height="200px"><img src="https://st.razeen.me/essay/image/go/grpc-002.png" width="600px" height="200px"><p>图中我们可以看到两个<code>message</code>对应生成了两个结构体，同时会生成一些序列化的方法等。</p><img src="https://st.razeen.me/essay/image/go/grpc-003.png" width="600px" height="200px"><img src="https://st.razeen.me/essay/image/go/grpc-004.png" width="600px" height="200px"><p>而定义的<code>service</code>则是生成了对应的<code>client</code>与<code>server</code>接口，那么这到底有什么用？怎么去用呢？将为你详细讲解~</p><p>看到这，我们简单的了解一下protobuf语法，如果你想了解更多，点<a href="https://developers.google.com/protocol-buffers/docs/proto3">这里</a>看官方文档。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Desc:protobuf语法介绍，怎么写proto文件，grpc的使用入门&lt;/p&gt;
&lt;p&gt;在gRPC官网用了一句话来介绍:“一个高性能、开源的通用RPC框架”，同时介绍了其四大特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定义简单&lt;/li&gt;
&lt;li&gt;支持多种编程语言多种平台&lt;/li&gt;
&lt;li&gt;快速启动和缩放&lt;/li&gt;
&lt;li&gt;双向流媒体和集成身份验证&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Go开发" scheme="https://github.com/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://github.com/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>怎么写Go基准测试（性能测试)</title>
    <link href="https://github.com/2018/09/15/benchmark/"/>
    <id>https://github.com/2018/09/15/benchmark/</id>
    <published>2018-09-15T03:07:50.000Z</published>
    <updated>2022-05-11T09:45:41.231Z</updated>
    
    <content type="html"><![CDATA[<p>或许你经常会思考这样的问题，我用不同的方法实现了同样的效果，哪个会更快？哪个内存消耗更小？这时候你一个简单的基准测试就能解决你的疑惑。</p><span id="more"></span><p>Go向来是以工具丰富而著称的，在学习Go的过程中，你会发现无论是写一个单元测试，还是做一些竞争检测都能很快的上手，而且用的很痛快。当然，接下来要说的基准测试也一样。</p><p>基准测试工具就在Go的测试包中，下面就用一个例子来介绍。</p><h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><p>由于一些场景需要，我需要将<code>[]byte</code>输出16进制字符。</p><p>有时候我会这么写:</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, b)</span><br></pre></td></tr></table></figure><p>但有时候我会这么写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hex.EncodeToString(b)</span><br></pre></td></tr></table></figure><p>但到底哪种写法更好呢？今天我就来比较一下。</p><p>直接写了个<code>main.go</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeA</span><span class="params">(b []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> fmt.Sprintf(<span class="string">&quot;%x&quot;</span>, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">EncodeB</span><span class="params">(b []<span class="type">byte</span>)</span></span> <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> hex.EncodeToString(b)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再写个测试<code>main_test.go</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buf = []<span class="type">byte</span>(<span class="string">&quot;skdjadialsdgasadasdhsakdjsahlskdjagloqweiqwo&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkEncodeA</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">EncodeA(buf)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkEncodeB</span><span class="params">(b *testing.B)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; b.N; i++ &#123;</span><br><span class="line">EncodeB(buf)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就这么简单，我们的基本测试就写完了。从我的写法中你也许就知道：</p><ul><li>和单元测试一样，都写在<code>_test.go</code>文件中；</li><li>需要以<code>Benchmark</code>为函数名开头；</li><li>和单元测试类似，必须接受一个<code>*testing.B</code>参数；</li><li>被测试代码放在一个循环中。</li></ul><p>我们直接跑一下。当然我们也是用<code>go test</code>来执行测试，简单的测试只要带上<code>-bench=.</code>就可以了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go <span class="built_in">test</span> -bench=.</span></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/razeencheng/demo-go/benchmark</span><br><span class="line">BenchmarkEncodeA-8       5000000               265 ns/op</span><br><span class="line">BenchmarkEncodeB-8      10000000               161 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/razeencheng/demo-go/benchmark        3.397s</span><br></pre></td></tr></table></figure><p>前两行是平台信息，第三行包名。第四、五行就是测试的结果了。</p><ul><li><code>BenchmarkEncodeA-8 </code> ,<code>BenchmarkEncodeB-8 </code> 基准测试函数名-GOMAXPROCS</li><li><code>5000000</code>,<code>10000000</code> 被测试的函数执行次数，也就是<code>EncodeA()</code>被执行了5000000次，<code>EncodeB()</code>被执行了10000000次，也就是<code>b.N</code>的值了。</li><li><code>265 ns/op</code>,<code>161 ns/op</code>表示每次调用被测试函数花费的时间。</li></ul><p>从花费的时间上来看，我们知道<code>EncodeB()</code>要快一点。</p><h3 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h3><p>你以为就这么简单的结束了么？NONONO。</p><ul><li><code>-bench</code> 可接收一个有效的正则表达式来执行符合条件的测试函数。当你的函数很多时，可以用它来过滤.</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go <span class="built_in">test</span> -bench=BenchmarkEncodeA</span></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/razeencheng/demo-go/benchmark</span><br><span class="line">BenchmarkEncodeA-8       5000000               256 ns/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/razeencheng/demo-go/benchmark        1.575s</span><br></pre></td></tr></table></figure><ul><li><code> -benchmem</code>可以查看内存分配</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go <span class="built_in">test</span> -bench=. -benchmem</span></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/razeencheng/demo-go/benchmark</span><br><span class="line">BenchmarkEncodeA-8       5000000               261 ns/op             128 B/op          2 allocs/op</span><br><span class="line">BenchmarkEncodeB-8      10000000               162 ns/op             192 B/op          2 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/razeencheng/demo-go/benchmark        3.408s</span><br></pre></td></tr></table></figure><p>其中<code>B/op</code> 表示每次执行会分配多少内存，<code>allocs/op</code>表示每次执行会发生多少次内存分配。</p><ul><li><p><code>-benchtime</code>指定每个测试执行的时间。默认<code>1s</code>,当你的函数比较耗时你可以设置更长一点。因为<code>b.N</code>是与这个时间有关的。</p><p>当你的运行时间没达到<code>-benchtime</code>制定的时间前，<code>b.N</code>将以1，2，5，10，20，50…增加，然后重新运行测试代码。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go <span class="built_in">test</span> -bench=. -benchmem -benchtime=5s</span></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/razeencheng/demo-go/benchmark</span><br><span class="line">BenchmarkEncodeA-8      30000000               254 ns/op             128 B/op          2 allocs/op</span><br><span class="line">BenchmarkEncodeB-8      50000000               160 ns/op             192 B/op          2 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/razeencheng/demo-go/benchmark        16.113s  </span><br></pre></td></tr></table></figure></li><li><p><code>-count</code>指定每个测试执行的次数。</p></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">go <span class="built_in">test</span> -bench=. -benchmem -count=3</span></span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: github.com/razeencheng/demo-go/benchmark</span><br><span class="line">BenchmarkEncodeA-8       5000000               256 ns/op             128 B/op          2 allocs/op</span><br><span class="line">BenchmarkEncodeA-8       5000000               255 ns/op             128 B/op          2 allocs/op</span><br><span class="line">BenchmarkEncodeA-8       5000000               253 ns/op             128 B/op          2 allocs/op</span><br><span class="line">BenchmarkEncodeB-8      10000000               163 ns/op             192 B/op          2 allocs/op</span><br><span class="line">BenchmarkEncodeB-8      10000000               160 ns/op             192 B/op          2 allocs/op</span><br><span class="line">BenchmarkEncodeB-8      10000000               160 ns/op             192 B/op          2 allocs/op</span><br><span class="line">PASS</span><br><span class="line">ok      github.com/razeencheng/demo-go/benchmark        9.984s</span><br></pre></td></tr></table></figure><p>我常用的也就这些了。</p><p>但对于<code>testing.B</code>来说，它拥有了<code>testing.T</code>的全部接口，所以<code>Fail,Skip,Error</code>这些都可以用，而且还增加了</p><ul><li><code>SetBytes( i uint64)</code> 统计内存消耗。</li><li><code>SetParallelism(p int)</code> 制定并行数目。</li><li><code>StartTimer / StopTimer / ResertTimer</code> 操作计时器。</li></ul><p>你可以按需使用。</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><code>b.N</code>为一个自增字段，谨慎用它做函数参数。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;或许你经常会思考这样的问题，我用不同的方法实现了同样的效果，哪个会更快？哪个内存消耗更小？这时候你一个简单的基准测试就能解决你的疑惑。&lt;/p&gt;</summary>
    
    
    
    <category term="Go开发" scheme="https://github.com/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://github.com/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>你好，Go语言</title>
    <link href="https://github.com/2018/09/12/var_dec/"/>
    <id>https://github.com/2018/09/12/var_dec/</id>
    <published>2018-09-12T03:07:50.000Z</published>
    <updated>2022-05-11T09:45:32.285Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>在声明变量之前，咱们先了解下变量的数据类型，这篇文章主要涉及 字符串、布尔、数字，其他类型后面开篇再说。</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p><code>string</code></p><p>只能用一对双引号（””）或反引号（&#96;&#96;）括起来定义，不能用单引号（’’）定义！</p><h4 id="布尔"><a href="#布尔" class="headerlink" title="布尔"></a>布尔</h4><p><code>bool</code></p><p>只有 true 和 false，默认为 false。</p><h4 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h4><p><strong>整型</strong></p><p><code>int8</code> <code>uint8</code> </p><p><code>int16</code> <code>uint16</code></p><p><code>int32</code> <code>uint32</code></p><p><code>int64</code> <code>uint64</code></p><p><code>int</code> <code>uint</code>，具体长度取决于 CPU 位数。</p><p><strong>浮点型</strong></p><p><code>float32</code> <code>float64</code></p><h2 id="常量声明"><a href="#常量声明" class="headerlink" title="常量声明"></a>常量声明</h2><p><strong>常量</strong>，在程序编译阶段就确定下来的值，而程序在运行时无法改变该值。</p><p><strong>单个常量声明</strong></p><p>第一种：const 变量名称 数据类型 &#x3D; 变量值</p><p>如果不赋值，使用的是该数据类型的默认值。</p><p>第二种：const 变量名称 &#x3D; 变量值</p><p>根据变量值，自行判断数据类型。</p><p><strong>多个常量声明</strong></p><p>第一种：const 变量名称,变量名称 … ,数据类型 &#x3D; 变量值,变量值 …</p><p>第二种：const 变量名称,变量名称 …  &#x3D; 变量值,变量值 …</p><p><strong>测试代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">//demo_1.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">const name string = &quot;Tom&quot;</span><br><span class="line">fmt.Println(name)</span><br><span class="line"></span><br><span class="line">const age = 30</span><br><span class="line">fmt.Println(age)</span><br><span class="line"></span><br><span class="line">const name_1, name_2 string = &quot;Tom&quot;, &quot;Jay&quot;</span><br><span class="line">fmt.Println(name_1, name_2)</span><br><span class="line"></span><br><span class="line">const name_3, age_1 = &quot;Tom&quot;, 30</span><br><span class="line">fmt.Println(name_3, age_1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://github.com/xinliangnote/Go/blob/master/00-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/images/02-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/2_go_1.png"></p><h2 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h2><p><strong>单个变量声明</strong></p><p>第一种：var 变量名称 数据类型 &#x3D; 变量值</p><p>如果不赋值，使用的是该数据类型的默认值。</p><p>第二种：var 变量名称 &#x3D; 变量值</p><p>根据变量值，自行判断数据类型。</p><p>第三种：变量名称 :&#x3D; 变量值</p><p>省略了 var 和数据类型，变量名称一定要是未声明过的。</p><p><strong>多个变量声明</strong></p><p>第一种：var 变量名称,变量名称 … ,数据类型 &#x3D; 变量值,变量值 …</p><p>第二种：var 变量名称,变量名称 …  &#x3D; 变量值,变量值 …</p><p>第三种：变量名称,变量名称 … :&#x3D; 变量值,变量值 …</p><p><strong>测试代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">//demo_2.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var age_1 uint8 = 31</span><br><span class="line">var age_2 = 32</span><br><span class="line">age_3 := 33</span><br><span class="line">fmt.Println(age_1, age_2, age_3)</span><br><span class="line"></span><br><span class="line">var age_4, age_5, age_6 int = 31, 32, 33</span><br><span class="line">fmt.Println(age_4, age_5, age_6)</span><br><span class="line"></span><br><span class="line">var name_1, age_7 = &quot;Tom&quot;, 30</span><br><span class="line">fmt.Println(name_1, age_7)</span><br><span class="line"></span><br><span class="line">name_2, is_boy, height := &quot;Jay&quot;, true, 180.66</span><br><span class="line">fmt.Println(name_2, is_boy, height)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://github.com/xinliangnote/Go/blob/master/00-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/images/02-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/2_go_2.png"></p><h2 id="输出方法"><a href="#输出方法" class="headerlink" title="输出方法"></a>输出方法</h2><p><strong>fmt.Print</strong>：输出到控制台（仅只是输出）</p><p><strong>fmt.Println</strong>：输出到控制台并换行</p><p><strong>fmt.Printf</strong>：仅输出格式化的字符串和字符串变量（整型和整型变量不可以）</p><p><strong>fmt.Sprintf</strong>：格式化并返回一个字符串，不输出。</p><p>测试代码</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//demo_3.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Print(&quot;输出到控制台不换行&quot;)</span><br><span class="line">fmt.Println(&quot;---&quot;)</span><br><span class="line">fmt.Println(&quot;输出到控制台并换行&quot;)</span><br><span class="line">fmt.Printf(&quot;name=%s,age=%d\n&quot;, &quot;Tom&quot;, 30)</span><br><span class="line">fmt.Printf(&quot;name=%s,age=%d,height=%v\n&quot;, &quot;Tom&quot;, 30, fmt.Sprintf(&quot;%.2f&quot;, 180.567))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p><img src="https://github.com/xinliangnote/Go/blob/master/00-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/images/02-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E/2_go_3.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;在声明变量之前，咱们先了解下变量的数据类型，这篇文章主要涉及 字符串、布尔、数字，其他类型后面开篇再说。&lt;/p&gt;
&lt;h2 id=&quot;数据类型&quot;</summary>
      
    
    
    
    <category term="Go开发" scheme="https://github.com/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://github.com/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>你好，Go语言</title>
    <link href="https://github.com/2018/09/11/hello-wrold/"/>
    <id>https://github.com/2018/09/11/hello-wrold/</id>
    <published>2018-09-11T03:07:50.000Z</published>
    <updated>2022-05-11T09:47:23.542Z</updated>
    
    <content type="html"><![CDATA[<h2 id="你好，Go语言"><a href="#你好，Go语言" class="headerlink" title="你好，Go语言"></a>你好，Go语言</h2><blockquote><p>Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。</p></blockquote><p>因工作需要，准备入坑，先从环境安装开始，输出一个 Hello World。</p><h2 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h2><p><strong>目标</strong></p><p>安装完成并运行 Hello World 成功！</p><p>本机系统：macOS High Sierra 10.13.4</p><p>Go 版本：1.12</p><p><strong>方式一：</strong></p><p>通过 brew 安装</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install go</span><br></pre></td></tr></table></figure><p>根据提示进行安装吧，我使用的 方式二 进行安装的。</p><p><strong>方式二：</strong></p><p>通过安装包安装</p><p>地址：<a href="https://dl.google.com/go/go1.12.darwin-amd64.pkg">https://dl.google.com/go/go1.12.darwin-amd64.pkg</a></p><p>下载之后直接点击安装，一步步继续即可。</p><p><strong>配置环境变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.bashrc</span><br><span class="line"></span><br><span class="line">//新增</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/Users/username/go/code //代码目录，自定义即可</span><br><span class="line">export PATH=$PATH:$GOPATH/bin</span><br></pre></td></tr></table></figure><p>及时生效，请执行命令：source ~&#x2F;.bashrc</p><p><strong>如果命令行使用的是zsh，请修改 .zshrc 文件。</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vi ~/.zshrc</span><br><span class="line"></span><br><span class="line">//新增</span><br><span class="line">export GOROOT=/usr/local/go</span><br><span class="line">export GOPATH=/Users/username/go/code //自定义代码目录</span><br><span class="line">export PATH=$PATH:$GOPATH/bin</span><br></pre></td></tr></table></figure><p>及时生效，请执行命令：source ~&#x2F;.zshrc</p><p>验证是否安装成功，命令行下执行：</p><p><img src="https://github.com/xinliangnote/Go/blob/master/00-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/images/01-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/1_go_1.png"></p><h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><p><strong>bin</strong></p><p>存放编译后可执行的文件。</p><p><strong>pkg</strong></p><p>存放编译后的应用包。</p><p><strong>src</strong></p><p>存放应用源代码。</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├─ code  -- 代码根目录</span><br><span class="line">│  ├─ bin</span><br><span class="line">│  ├─ pkg</span><br><span class="line">│  ├─ src</span><br><span class="line">│     ├── hello</span><br><span class="line">│         ├── hello.go</span><br></pre></td></tr></table></figure><p><strong>Hello World 代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//在 hello 目录下创建 hello.go</span><br><span class="line"></span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;Hello World!&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>命令行执行：</p><p><img src="https://github.com/xinliangnote/Go/blob/master/00-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/images/01-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/1_go_2.png"></p><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>查看完整的命令：</p><p><img src="https://github.com/xinliangnote/Go/blob/master/00-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/images/01-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/1_go_3.png"></p><p><strong>go build hello</strong></p><p>在src目录或hello目录下执行 go build hello，只在对应当前目录下生成文件。</p><p><strong>go install hello</strong></p><p>在src目录或hello目录下执行 go install hello，会把编译好的结果移动到 $GOPATH&#x2F;bin。</p><p><strong>go run hello</strong></p><p>在src目录或hello目录下执行 go run hello，不生成任何文件只运行程序。</p><p><strong>go fmt hello</strong></p><p>在src目录或hello目录下执行 go run hello，格式化代码，将代码修改成标准格式。</p><p>其他命令，需要的时候再进行研究吧。</p><h2 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h2><p><strong>GoLand</strong></p><p><img src="https://github.com/xinliangnote/Go/blob/master/00-%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/images/01-%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85/1_go_4.png"></p><p>GoLand 是 JetBrains 公司推出的 Go 语言集成开发环境，与我们用的 WebStorm、PhpStorm、PyCharm 是一家，同样支持 Windows、Linux、macOS 等操作系统。</p><p>下载地址：<a href="https://www.jetbrains.com/go/">https://www.jetbrains.com/go/</a></p><p>软件是付费的，不过想想办法，软件可以永久激活的。</p><h2 id="学习网址"><a href="#学习网址" class="headerlink" title="学习网址"></a>学习网址</h2><ul><li>Go语言：<a href="https://golang.org/">https://golang.org/</a></li><li>Go语言中文网：<a href="https://studygolang.com/">https://studygolang.com/</a></li><li>Go语言包管理：<a href="https://gopm.io/">https://gopm.io/</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;你好，Go语言&quot;&gt;&lt;a href=&quot;#你好，Go语言&quot; class=&quot;headerlink&quot; title=&quot;你好，Go语言&quot;&gt;&lt;/a&gt;你好，Go语言&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。&lt;/</summary>
      
    
    
    
    <category term="Go开发" scheme="https://github.com/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://github.com/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
