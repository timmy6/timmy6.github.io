<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://timmy6.github.io/atom.xml" rel="self"/>
  
  <link href="https://timmy6.github.io/"/>
  <updated>2022-05-23T02:54:10.861Z</updated>
  <id>https://timmy6.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>总结Go编码规范</title>
    <link href="https://timmy6.github.io/2022/05/01/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/"/>
    <id>https://timmy6.github.io/2022/05/01/%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/</id>
    <published>2022-05-01T15:15:10.000Z</published>
    <updated>2022-05-23T02:54:10.861Z</updated>
    
    <content type="html"><![CDATA[<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><ul><li>需要注释来补充说明的命名不是好的命名；</li></ul><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li>所有变量或常量都是用驼峰格式，非导出的变量或常量首字母采用小写；<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">startOnce sync.Once</span><br><span class="line">exporting = &amp;atomic.Bool&#123;&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span>  ConnectionMaxSize = <span class="number">100</span></span><br></pre></td></tr></table></figure></li><li>如果函数块较短（小于50行），本地变量尽量使用单字母命名，如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">OpenFile</span><span class="params">(name <span class="type">string</span>, flag <span class="type">int</span>, perm FileMode)</span></span> (*File, <span class="type">error</span>) &#123;</span><br><span class="line">    testlog.Open(name)</span><br><span class="line">    f, err := openFileNolog(name, flag, perm)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span>, err</span><br><span class="line">    &#125;</span><br><span class="line">    f.appendMode = flag&amp;O_APPEND != <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> f, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果函数块较长导致本地变量定义与引用位置较远或者本地变量较多，可以使用非单字母变量名；</li></ul><h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><ul><li>命名使用驼峰格式，非导出结构体首字母采用小写，如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RestyClient a rest client implement by Resty</span></span><br><span class="line"><span class="keyword">type</span> RestyClient <span class="keyword">struct</span> &#123;</span><br><span class="line">client *resty.Client</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>使用名词，不要使用动词，如：”Exporter”, “Protocol”；</li><li>在没有冲突的前提下，结构体前缀尽量避免与包名重复，比如：”dubbo” 包下，避免定义 “DubboExporter”，而是使用 “Export”；</li><li>结构体的导出字段需要放在前，非导出字段在后；</li><li>结构体字段的命名可以参考 <a href="#%E5%8F%98%E9%87%8F">变量</a></li></ul><h3 id="函数名"><a href="#函数名" class="headerlink" title="函数名"></a>函数名</h3><ul><li>函数命名使用驼峰格式，非导出函数首字母采用小写，如：”NewResponse”, “removePendingResponse”</li></ul><h3 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h3><ul><li>文件名如果有多个单词，需要以下划线分割；</li></ul><h3 id="其他情况"><a href="#其他情况" class="headerlink" title="其他情况"></a>其他情况</h3><ul><li>bool 类型变量，名称应以 Has, Is, Can 或 Allow 开头；</li><li>包含常见特有名词的命名，特有名字不能使用驼峰格式，如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// bad</span><br><span class="line">ApiClient, HttpRequest, IpAddress</span><br><span class="line">// good</span><br><span class="line">APIClient/apiClient, HTTPRequest/httpRequest, IPAddress/ipAddress</span><br></pre></td></tr></table></figure></li></ul><h3 id="包名"><a href="#包名" class="headerlink" title="包名"></a>包名</h3><ul><li>采用小写，不能使用大写或中划线；</li><li>命名保持简短清晰，尽量使用单个单词的名词，如：”config”, “protocol”, “registry”；</li><li>命名如需使用多个单词，可以下划线分割，如：”config_center”；</li><li>不能使用基础库库名，如：”http”, “cmd”, “math”；</li><li>不要使用复数，如：”urls”；</li><li>不要使用信息量不足的单词，比如：”common”, “global”, “lib”, “util”；</li><li>尽量不要对导入的包进行重命名，以下两种情况必须使用别名导入：<ul><li>包名与导入路径最后一个单词不匹配，必须使用别名导入：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line"></span><br><span class="line">    client <span class="string">&quot;example.com/client-go&quot;</span></span><br><span class="line">    trace <span class="string">&quot;example.com/trace/v2&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li>导入的包名有冲突，必须使用别名导入：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;os&quot;</span></span><br><span class="line">    <span class="string">&quot;runtime/trace&quot;</span></span><br><span class="line"></span><br><span class="line">    nettrace <span class="string">&quot;golang.net/x/trace&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>参考:<a href="https://go.dev/blog/package-names">Package names</a></p><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><ul><li>编码阶段需要同步维护好变量、函数以及包注释；</li><li>注释必须是完整句子，并以句号结束；</li><li>尽量采用英文注释，以避免各种编码问题；</li><li>所有导出的变量、常量、函数、结构体都必须有注释；</li><li>没有用的代码直接删除，不要通过注释保留下来；</li></ul><h3 id="函数注释"><a href="#函数注释" class="headerlink" title="函数注释"></a>函数注释</h3><ul><li>函数注释需要以函数名开头，详细描述函数的入参、功能、返回结果、错误类型等信息；</li></ul><h3 id="结构体（接口）注释"><a href="#结构体（接口）注释" class="headerlink" title="结构体（接口）注释"></a>结构体（接口）注释</h3><ul><li>每个结构体（或接口）都需要在定义前一行添加注释；</li><li>结构体字段命名应该能够清晰体现字段含义，如果需要补充说明可以在字段定义前添加行注释或者块注释，如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ServiceDiscoveryConfig will be used to create</span></span><br><span class="line"><span class="keyword">type</span> ServiceDiscoveryConfig <span class="keyword">struct</span> &#123;</span><br><span class="line"><span class="comment">// Protocol indicate which implementation will be used.</span></span><br><span class="line"><span class="comment">// for example, if the Protocol is nacos, it means that we will use nacosServiceDiscovery</span></span><br><span class="line">Protocol <span class="type">string</span> <span class="string">`yaml:&quot;protocol&quot; json:&quot;protocol,omitempty&quot; property:&quot;protocol&quot;`</span></span><br><span class="line"><span class="comment">// Group, usually you don&#x27;t need to config this field.</span></span><br><span class="line"><span class="comment">// you can use this to do some isolation</span></span><br><span class="line">Group <span class="type">string</span> <span class="string">`yaml:&quot;group&quot; json:&quot;group,omitempty&quot;`</span></span><br><span class="line"><span class="comment">// RemoteRef is the reference point to RemoteConfig which will be used to create remotes instances.</span></span><br><span class="line">RemoteRef <span class="type">string</span> <span class="string">`yaml:&quot;remote_ref&quot; json:&quot;remote_ref,omitempty&quot; property:&quot;remote_ref&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>接口下的所有方法都需要有注释，如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Protocol extension for protocol</span></span><br><span class="line"><span class="keyword">type</span> Protocol <span class="keyword">interface</span> &#123;</span><br><span class="line"><span class="comment">// Export service for remote invocation</span></span><br><span class="line">Export(invoker Invoker) Exporter</span><br><span class="line"><span class="comment">// Refer a remote service</span></span><br><span class="line">Refer(url *common.URL) Invoker</span><br><span class="line"><span class="comment">// Destroy will destroy all invoker and exporter, so it only is called once.</span></span><br><span class="line">Destroy()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="包注释"><a href="#包注释" class="headerlink" title="包注释"></a>包注释</h3><ul><li>每个包都应该有一个包注释，位于package子句之前的块注释或行注释。包如果有多个go文件，只需要出现在一个go文件中即可，如：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Package hash provides interfaces for hash functions.</span></span><br><span class="line"><span class="keyword">package</span> hash</span><br></pre></td></tr></table></figure></li><li>如果包注释较长，建议在包下新建一个 doc.go 文件单独放置包注释；</li></ul><h2 id="控制结构"><a href="#控制结构" class="headerlink" title="控制结构"></a>控制结构</h2><h3 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h3><ul><li><p>使用 if 语句初始化一次性的本地变量，减少不必要的本地变量定义，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">if</span> err := dir.registry.Subscribe(url, dir); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logger.Error(<span class="string">&quot;registry.Subscribe(url:%v, dir:%v) = error:%v&quot;</span>, url, dir, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line">err := dir.registry.Subscribe(url, dir)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    logger.Error(<span class="string">&quot;registry.Subscribe(url:%v, dir:%v) = error:%v&quot;</span>, url, dir, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>避免不必要的 else 语句，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line">a := <span class="number">10</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">var</span> a <span class="type">int</span></span><br><span class="line"><span class="keyword">if</span> b &#123;</span><br><span class="line">    a = <span class="number">100</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    a = <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代码应该优先处理错误、异常或特殊情况，通过尽早返回或者继续来减少代码嵌套：</p></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">for</span> _, e := <span class="keyword">range</span> employees &#123;</span><br><span class="line">    <span class="keyword">if</span> !isWellDone(e.Id) &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;not good enough this time&quot;</span>)</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> newSalary, err := adjustSalary(e.Id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        e.Salary = newSalary</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;adjust salary failed&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> err</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">for</span> _, e := <span class="keyword">range</span> employees &#123;</span><br><span class="line">    <span class="keyword">if</span> isWellDone(e.Id) &#123;</span><br><span class="line">        <span class="keyword">if</span> newSalary, err := adjustSalary(e.Id); err != <span class="literal">nil</span> &#123;</span><br><span class="line">            e.Salary = newSalary</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            log.Printf(<span class="string">&quot;adjust salary failed&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> err</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        log.Printf(<span class="string">&quot;not good enough this time&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2><ul><li>强制使用gofmt自动格式化代码，所有代码格式风格与官方推荐保持一致；</li><li>单行代码不超过 120 个字符；</li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="Panic"><a href="#Panic" class="headerlink" title="Panic"></a>Panic</h3><ul><li>生产环境中运行的代码必须避免 panic；</li><li>只允许在程序初始化阶段通过 panic 终止程序运行；</li></ul><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ul><li>单元测试文件命名要以 _test 为后缀，如：application_config_test.go；</li></ul><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://go.dev/doc/effective_go#package-names">Effective Go</a></li><li><a href="https://go.dev/blog/package-names">Package names</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;命名&quot;&gt;&lt;a href=&quot;#命名&quot; class=&quot;headerlink&quot; title=&quot;命名&quot;&gt;&lt;/a&gt;命名&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;需要注释来补充说明的命名不是好的命名；&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&quot;变量&quot;&gt;&lt;a href=&quot;#变量&quot; class=&quot;</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go高级" scheme="https://timmy6.github.io/tags/Go%E9%AB%98%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>Redis面试题汇总</title>
    <link href="https://timmy6.github.io/2022/04/06/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <id>https://timmy6.github.io/2022/04/06/Redis%E9%9D%A2%E8%AF%95%E9%A2%98%E6%B1%87%E6%80%BB/</id>
    <published>2022-04-06T15:38:10.000Z</published>
    <updated>2022-05-23T02:37:15.953Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Redis面试题汇总"><a href="#Redis面试题汇总" class="headerlink" title="Redis面试题汇总"></a>Redis面试题汇总</h1><!-- vscode-markdown-toc --><ul><li><ol><li><a href="#Redis">Redis是单线程还是多线程?</a></li></ol><ul><li>1.1. <a href="#Redis4.0">为什么Redis再4.0之前即使使用了单线程，但是仍然那么快？</a></li><li>1.2. <a href="#Redis-1">谈谈Redis中的多路复用机制</a></li><li>1.3. <a href="#Redis-1">Redis线程模型</a></li></ul></li><li><ol start="2"><li><a href="#Redis-1">Redis存在线程安全的问题吗?</a></li></ol></li><li><ol start="3"><li><a href="#Redis-1">Redis如何应对缓存穿透？</a></li></ol><ul><li>3.1. <a href="#Bloom">Bloom过滤器</a></li></ul></li><li><ol start="4"><li><a href="#Redis-1">Redis如何应对缓存击穿？</a></li></ol></li><li><ol start="5"><li><a href="#Redis-1">Redis如何应对缓存雪崩?</a></li></ol></li><li><ol start="6"><li><a href="#Redis-1">Redis如何做缓存预热？</a></li></ol></li><li><ol start="7"><li><a href="#Redis-1">Redis如何保持缓存一致性?</a></li></ol><ul><li>7.1. <a href="#CacheAside">Cache Aside</a></li><li>7.2. <a href="#ReadThrough">Read Through</a></li><li>7.3. <a href="#WriteThrough">Write Through</a></li><li>7.4. <a href="#WriteBehindCaching">Write Behind Caching</a></li></ul></li><li><ol start="8"><li><a href="#Redis-1">Redis如何回收缓存(针对内存空间不足)?</a></li></ol><ul><li>8.1. <a href="#">如何选择合适的策略?</a></li></ul></li><li><ol start="9"><li><a href="#Redis-1">Redis过期键有哪些删除策略?</a></li></ol><ul><li>9.1. <a href="#-1">键的过期精度</a></li><li>9.2. <a href="#-1">过期和持久</a></li><li>9.3. <a href="#key">过期key的删除策略</a></li><li>9.4. <a href="#AOFkey">在复制AOF文件时出现过期key该怎么办?</a></li></ul></li><li><ol start="10"><li><a href="#Redis-1">简述Redis持久化机制</a></li></ol><ul><li>10.1. <a href="#RDB">RDB的优点</a></li><li>10.2. <a href="#RDB-1">RDB的缺点</a></li><li>10.3. <a href="#AOF">AOF的优点</a></li><li>10.4. <a href="#AOF-1">AOF缺点</a></li><li>10.5. <a href="#X">4.X版本的持久化策略整合</a></li></ul></li><li><ol start="11"><li><a href="#Redis-1">简述Redis主从复制</a></li></ol><ul><li>11.1. <a href="#-1">主从复制的过程</a></li><li>11.2. <a href="#-1">主从复制的关注点</a></li><li>11.3. <a href="#-1">复制的流程</a></li></ul></li></ul><!-- vscode-markdown-toc-config    numbering=true    autoSave=true    /vscode-markdown-toc-config --><!-- /vscode-markdown-toc --><h2 id="1-Redis是单线程还是多线程"><a href="#1-Redis是单线程还是多线程" class="headerlink" title="1. Redis是单线程还是多线程?"></a>1. <a name='Redis'></a>Redis是单线程还是多线程?</h2><ul><li>无论什么redis版本，工作线程<a href=""><code>worker thread</code></a>只有一个</li><li><a href=""><code>6.x</code></a>版本出现了IO多线程</li><li>目前所说的Redis单线程，指的是”其网络IO和键值对读写是由一个线程完成的”，也就是说，<strong>Redis中只有网络请求模块和数据操作模块是单线程的。而其他的如持久化存储模块、集群支撑模块等是多线程的。</strong> Redis 4.0的时候就已经针对部分命令做了多线程化。主要是体现在大数据的异步删除功能上，例如<code>unlink key</code>、<code>flushdb async</code>、<code>flushall async</code>等。</li></ul><h3 id="1-1-为什么Redis再4-0之前即使使用了单线程，但是仍然那么快？"><a href="#1-1-为什么Redis再4-0之前即使使用了单线程，但是仍然那么快？" class="headerlink" title="1.1. 为什么Redis再4.0之前即使使用了单线程，但是仍然那么快？"></a>1.1. <a name='Redis4.0'></a>为什么Redis再4.0之前即使使用了单线程，但是仍然那么快？</h3><ul><li>单线程，不存在锁竞争的状态，可以在无锁的情况下完成所有的操作，不存在死锁和线程切换带来的时间开销</li><li>Redis大部分的操作都是在内存中完成的，内存的执行效率非常快，并且采用了高效的数据结构，比如<code>hashtable</code>和<code>skiplist</code></li><li>Redis采用IO多路复用机制处理大量客户端的<code>Socket</code>请求，<strong>注意，多路复用器仅仅负责调度IO事件，不负责真正的读写操作</strong> ，因为这是非阻塞的IO模型，可以让Redis进行高效的网络通信及IO读写</li></ul><h3 id="1-2-谈谈Redis中的多路复用机制"><a href="#1-2-谈谈Redis中的多路复用机制" class="headerlink" title="1.2. 谈谈Redis中的多路复用机制"></a>1.2. <a name='Redis-1'></a>谈谈Redis中的多路复用机制</h3><p><strong>Linux多路复用技术，就是多个进程的IO可以注册到同一个管道上，这个管道会统一和内核进行交互。当管道中的某一个请求需要的数据准备好之后，进程再把对应的数据拷贝到用户空间中。</strong>也就是说，<strong>通过一个线程来处理多个IO流</strong>。</p><p>IO多路复用在Linux下包括了三种，select、poll、epoll三种模式。</p><p>其实，Redis的IO多路复用程序的所有功能都是通过包装操作系统的IO多路复用函数库来实现的。每个IO多路复用函数库在Redis源码中都有对应的一个单独的文件。</p><h3 id="1-3-Redis线程模型"><a href="#1-3-Redis线程模型" class="headerlink" title="1.3. Redis线程模型"></a>1.3. <a name='Redis-1'></a>Redis线程模型</h3><p>在Redis 中，文件事件处理器(<a href=""><code>file event handler</code></a>)包括套接字、I&#x2F;O 多路复用程序、文件事件分派器、以及事件处理器。使用 I&#x2F;O 多路复用程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。每当一个套接字准备好执行连接应答、写入、读取、关闭等操作时，就会产生一个文件事件。因为一个服务器通常会连接多个套接字，所以多个文件事件有可能会并发地出现。</p><p>I&#x2F;O 多路复用程序负责监听多个套接字，并向文件事件分派器传送那些产生了事件的套接字。尽管多个文件事件可能会并发地出现，但 I&#x2F;O 多路复用程序总是会将所有产生事件的套接字都入队到一个队列里面，然后通过这个队列，以有序、同步、每次一个套接字的方式向文件事件分派器传送套接字：当上一个套接字产生的事件被处理完毕之后（该套接字为事件所关联的事件处理器执行完毕），I&#x2F;O 多路复用程序才会继续向文件事件分派器传送下一个套接字。如果一个套接字又可读又可写的话，那么服务器将先读套接字，后写套接字。</p><p>总的来说，就是<strong>请求Socker—&gt;IO多路复用程序—&gt;file event dispatcher队列—&gt;file event handler文件事件处理器</strong></p><p><strong>客户端被读取的顺序不能被保障，但是一个Socket中的操作顺序可以被保障</strong></p><h2 id="2-Redis存在线程安全的问题吗"><a href="#2-Redis存在线程安全的问题吗" class="headerlink" title="2. Redis存在线程安全的问题吗?"></a>2. <a name='Redis-1'></a>Redis存在线程安全的问题吗?</h2><p>Redis虽然可以保障内部串行，但是外部使用Redis的时候需要额外的操作来保障线程安全。<strong>因为Redis不能保障每一个Socket请求被桉顺序读取</strong></p><h2 id="3-Redis如何应对缓存穿透？"><a href="#3-Redis如何应对缓存穿透？" class="headerlink" title="3. Redis如何应对缓存穿透？"></a>3. <a name='Redis-1'></a>Redis如何应对缓存穿透？</h2><ul><li>在接口访问层对用户做校验，如接口传参、登陆状态、n秒内访问接口的次数；</li><li>利用布隆过滤器，将数据库层有的数据key存储在位数组中，以判断访问的key在底层数据库中是否存在；</li></ul><h3 id="3-1-Bloom过滤器"><a href="#3-1-Bloom过滤器" class="headerlink" title="3.1. Bloom过滤器"></a>3.1. <a name='Bloom'></a>Bloom过滤器</h3><ul><li>如果Redis内不存在该数据，则通过布隆过滤器判断数据是否在底层数据库内；</li><li>如果布隆过滤器告诉我们该key在底层库内不存在，则直接返回null给客户端即可，避免了查询底层数据库的动作；</li><li>如果布隆过滤器告诉我们该key<strong>极有可能</strong>在底层数据库内存在，那么将查询下推到底层数据库即可；</li></ul><p><strong>Bloom过滤器也无法100%告诉我们该数据是否一定在DB中，只是描述可能性的大小</strong> 。</p><h2 id="4-Redis如何应对缓存击穿？"><a href="#4-Redis如何应对缓存击穿？" class="headerlink" title="4. Redis如何应对缓存击穿？"></a>4. <a name='Redis-1'></a>Redis如何应对缓存击穿？</h2><p>缓存击穿和缓存穿透从名词上可能很难区分开来，它们的区别是：穿透表示底层数据库没有数据且缓存内也没有数据，击穿表示底层数据库有数据而缓存内没有数据。当热点数据key从缓存内失效时，大量访问同时请求这个数据，就会将查询下沉到数据库层，此时数据库层的负载压力会骤增，我们称这种现象为”缓存击穿”。</p><p><strong>解决方法如下:</strong></p><ul><li>延长热点key的过期时间或者设置永不过期，如排行榜，首页等一定会有高并发的接口；</li><li>利用互斥锁保证同一时刻只有一个客户端可以查询底层数据库的这个数据，一旦查到数据就缓存至Redis内，避免其他大量请求同时穿过Redis访问底层数据库；</li></ul><h2 id="5-Redis如何应对缓存雪崩"><a href="#5-Redis如何应对缓存雪崩" class="headerlink" title="5. Redis如何应对缓存雪崩?"></a>5. <a name='Redis-1'></a>Redis如何应对缓存雪崩?</h2><p>缓存雪崩是缓存击穿的”大面积”版，缓存击穿是数据库缓存到Redis内的热点数据失效导致大量并发查询穿过redis直接击打到底层数据库，而缓存雪崩是指Redis中大量的key几乎同时过期，然后大量并发查询穿过redis击打到底层数据库上，此时数据库层的负载压力会骤增，我们称这种现象为”缓存雪崩”。事实上缓存雪崩相比于缓存击穿更容易发生，对于大多数公司来讲，同时超大并发量访问同一个过时key的场景的确太少见了，而大量key同时过期，大量用户访问这些key的几率相比缓存击穿来说明显更大。</p><p><strong>解决方法如下:</strong></p><ul><li>在可接受的时间范围内随机设置key的过期时间，分散key的过期时间，以防止大量的key在同一时刻过期；</li><li>对于一定要在固定时间让key失效的场景(例如每日12点准时更新所有最新排名)，可以在固定的失效时间时在接口服务端设置随机延时，将请求的时间打散，让一部分查询先将数据缓存起来；</li><li>延长热点key的过期时间或者设置永不过期，这一点和缓存击穿中的方案一样；</li></ul><h2 id="6-Redis如何做缓存预热？"><a href="#6-Redis如何做缓存预热？" class="headerlink" title="6. Redis如何做缓存预热？"></a>6. <a name='Redis-1'></a>Redis如何做缓存预热？</h2><p>缓存预热如字面意思，当系统上线时，缓存内还没有数据，如果直接提供给用户使用，每个请求都会穿过缓存去访问底层数据库，如果并发大的话，很有可能在上线当天就会宕机，因此我们需要在上线前先将数据库内的热点数据缓存至Redis内再提供出去使用，这种操作就成为”缓存预热”。</p><p>缓存预热的实现方式有很多，<strong>比较通用的方式是写个批任务，在启动项目时或定时去触发将底层数据库内的热点数据加载到缓存内。</strong></p><h2 id="7-Redis如何保持缓存一致性"><a href="#7-Redis如何保持缓存一致性" class="headerlink" title="7. Redis如何保持缓存一致性?"></a>7. <a name='Redis-1'></a>Redis如何保持缓存一致性?</h2><p>缓存服务（Redis）和数据服务（底层数据库）是相互独立且异构的系统，在更新缓存或更新数据的时候无法做到原子性的同时更新两边的数据，因此在并发读写或第二步操作异常时会遇到各种数据不一致的问题。如何解决并发场景下更新操作的双写一致是缓存系统的一个重要知识点。</p><h3 id="7-1-Cache-Aside"><a href="#7-1-Cache-Aside" class="headerlink" title="7.1. Cache Aside"></a>7.1. <a name='CacheAside'></a>Cache Aside</h3><p>查询：先查缓存，缓存没有就查数据库，然后加载至缓存内；更新：先更新数据库，然后让缓存失效；或者先失效缓存然后更新数据库； </p><h3 id="7-2-Read-Through"><a href="#7-2-Read-Through" class="headerlink" title="7.2. Read Through"></a>7.2. <a name='ReadThrough'></a>Read Through</h3><p>在查询操作中更新缓存，即当缓存失效时，Cache Aside 模式是由调用方负责把数据加载入缓存，而 Read Through 则用缓存服务自己来加载；</p><h3 id="7-3-Write-Through"><a href="#7-3-Write-Through" class="headerlink" title="7.3. Write Through"></a>7.3. <a name='WriteThrough'></a>Write Through</h3><p>在更新数据时发生。当有数据更新的时候，如果没有命中缓存，直接更新数据库，然后返回。如果命中了缓存，则更新缓存，然后由<strong>缓存自己更新数据库</strong>； </p><h3 id="7-4-Write-Behind-Caching"><a href="#7-4-Write-Behind-Caching" class="headerlink" title="7.4. Write Behind Caching"></a>7.4. <a name='WriteBehindCaching'></a>Write Behind Caching</h3><p>俗称write back，在更新数据的时候，只更新缓存，不更新数据库，<strong>缓存会异步地定时批量更新数据库</strong>；</p><h2 id="8-Redis如何回收缓存-针对内存空间不足"><a href="#8-Redis如何回收缓存-针对内存空间不足" class="headerlink" title="8. Redis如何回收缓存(针对内存空间不足)?"></a>8. <a name='Redis-1'></a>Redis如何回收缓存(针对内存空间不足)?</h2><table><thead><tr><th align="center">回收策略</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">noeviction</td><td align="center">返回错误当内存限制达到并且客户端尝试执行会让更多内存被使用的命令(写入命令)</td></tr><tr><td align="center">allkeys-lru</td><td align="center">尝试回收最近最少使用的键</td></tr><tr><td align="center">volatile-lru</td><td align="center">尝试回收最近最少使用的键，但仅限于在过期集合的键</td></tr><tr><td align="center">volatile-random</td><td align="center">随机回收过期集合中的键</td></tr><tr><td align="center">volatile-ttl</td><td align="center">回收过期集合的键，并优先回收TTL短的键</td></tr><tr><td align="center">volatile-lfu</td><td align="center">从所有配置了过期时间的键中驱逐使用频率最少的键</td></tr><tr><td align="center">allkeys-lfu</td><td align="center">回收最近使用频率最少的键</td></tr><tr><td align="center">allkeys-random</td><td align="center">随即回收键</td></tr></tbody></table><p><strong>如果没有键满足回收条件，volatile-lru,volatile-random和volatile-ttl和noeviction差不多</strong></p><h3 id="8-1-如何选择合适的策略"><a href="#8-1-如何选择合适的策略" class="headerlink" title="8.1. 如何选择合适的策略?"></a>8.1. <a name=''></a>如何选择合适的策略?</h3><ul><li>运行时查看缓存命中率和使用情况决定使用何种或者使用何种组合过期策略</li></ul><h2 id="9-Redis过期键有哪些删除策略"><a href="#9-Redis过期键有哪些删除策略" class="headerlink" title="9. Redis过期键有哪些删除策略?"></a>9. <a name='Redis-1'></a>Redis过期键有哪些删除策略?</h2><h3 id="9-1-键的过期精度"><a href="#9-1-键的过期精度" class="headerlink" title="9.1. 键的过期精度"></a>9.1. <a name='-1'></a>键的过期精度</h3><p>在redis 2.4版本之前，过期时间可能不是一个精确的数字，有0-1秒的误差。</p><p>在redis 2.6版本之后，过期时间误差缩小在0-1ms之间</p><h3 id="9-2-过期和持久"><a href="#9-2-过期和持久" class="headerlink" title="9.2. 过期和持久"></a>9.2. <a name='-1'></a>过期和持久</h3><p>keys的过期是按使用Unix时间戳存储(从redis 2.6之后开始使用以ms为单位的过期时间)。这意味着即使redis实例不可用，时间也是在一直流逝的。要想过期工作做得好，redis必须有一个精确且稳定的过期时间。如果想在两个RDB文件在两台时钟不同的计算机之间进行同步，将会出现意想不到的意外。</p><h3 id="9-3-过期key的删除策略"><a href="#9-3-过期key的删除策略" class="headerlink" title="9.3. 过期key的删除策略"></a>9.3. <a name='key'></a>过期key的删除策略</h3><p>redis keys过期有两种方式：被动和主动。</p><ul><li>当有客户端试图访问过期的Keys的时候，过期的key会被发现并被被动的删除。<strong>当然，一些过期的key也可能永远不会被访问，因此只有被动式的删除并不能解决所有的问题。</strong></li><li>redis还有主动式的删除：<strong>redis会首秀按随机进行20个keys相关的过期检测，然后删除检测到的已经过期的key，如果有多于25%的keys过期，重复第一个步骤。</strong></li></ul><h3 id="9-4-在复制AOF文件时出现过期key该怎么办"><a href="#9-4-在复制AOF文件时出现过期key该怎么办" class="headerlink" title="9.4. 在复制AOF文件时出现过期key该怎么办?"></a>9.4. <a name='AOFkey'></a>在复制AOF文件时出现过期key该怎么办?</h3><p>当一个key过期，<code>DEL</code>将会随着AOF文字一起合成到所有附件的slave。在master实例中，这种方法是集中的，并且不存在一致性错误的机会。然而，当slave连接到master时，不会独立过期keys(会等到master的<code>DEL</code>)，他们可能会在数据集中存在，所以当slave当选为master时淘汰机制将会独立执行，然后成为master。</p><h2 id="10-简述Redis持久化机制"><a href="#10-简述Redis持久化机制" class="headerlink" title="10. 简述Redis持久化机制"></a>10. <a name='Redis-1'></a>简述Redis持久化机制</h2><p>Redis提供了不同级别的持久化方式：</p><ul><li>RDB持久化能够在指定的时间间隔对你的数据进行快照存储</li><li>AOF持久化方式记录每次对服务器写操作，当服务器重启的时候会重新执行这些命令来恢复原始数据，AOF命令以redis协议<strong>追加</strong>保存每次写操作到文件末尾。redis还能对AOF文件进行后台重写，使得AOF文件的体积不至于太大。</li><li>如果只希望运行单机版的redis服务器，可以不适用任何形式的持久化操作。</li><li>redis也支持同时开启两种持久化方式，在这种情况下，当redis重启的时候，会优先载入AOF文件来恢复原始的数据，因为通常情况下AOF文件保存到数据集比RDB文件保存的数据集要更加完整。</li><li><strong>最重要的是RDB和AOF持久化的方式不同</strong></li></ul><h3 id="10-1-RDB的优点"><a href="#10-1-RDB的优点" class="headerlink" title="10.1. RDB的优点"></a>10.1. <a name='RDB'></a>RDB的优点</h3><ul><li>RDB是一个非常紧凑的结构，保存了某个时间点的数据集，非常适用于数据集的备份，比如你可以在每个小时保存过去24小时内的数据，因此每天保存过去30天的数据，这样即使除了问题也可以根据需求恢复到不同版本的数据集。</li><li>RDB是一个紧凑单一的文件，很方便传送到另一个远端数据中心或者亚马逊的S3(可能加密)，非常适用于灾难的恢复。</li><li>RDB在保存RDB文件的时候父进程唯一需要做的就是fork一个子进程，接下来的工作全部交给子进程来做，父进程不需要再做其他IO操作，所以RDB持久化方式可以最大化redis的性能。</li><li>与AOF相比，在恢复大的数据集的时候，RDB的方式会更加快一点。</li></ul><h3 id="10-2-RDB的缺点"><a href="#10-2-RDB的缺点" class="headerlink" title="10.2. RDB的缺点"></a>10.2. <a name='RDB-1'></a>RDB的缺点</h3><ul><li>如果redis意外停止工作，并且要求数据丢失最少的情况下，RDB不适合，因为保存完整数据集是一个非常繁重的任务，通常RDB会每隔几分钟做一个完整的保存，万一redis宕机，有可能会丢失几分钟的数据。</li><li>RDB进场需要fork子进程来保存数据集到硬盘之上，当数据集比较大的时候，fork的过程是非常耗时的，可能会导致redis在一些毫秒级内不能响应客户端的请求，如果数据集巨大并且CPU性能不好的情况下，这种情况会持续1s，AOF也需要fork，但是可以调整重写日志文件的频率来提高数据集的耐久度。</li></ul><h3 id="10-3-AOF的优点"><a href="#10-3-AOF的优点" class="headerlink" title="10.3. AOF的优点"></a>10.3. <a name='AOF'></a>AOF的优点</h3><ul><li>使用AOF会让你的redis更加耐久，你可以使用不同的<code>fsync</code>策略，无<code>fsync</code>， 每秒<code>fsync</code>，每次写的时候<code>fsync</code>，使用默认的每秒<code>fsync</code>策略，redis的性能依然很好，因为<code>fsync</code>是由后台线程进行处理的，主线程会尽力处理客户端的请求，一旦出现故障，最多丢失1s的数据。</li><li>AOF文件是一个只进行追加的日志文件，所以不需要写入<code>seek</code>，即使由于某些原因(磁盘空间已满，写的过程有宕机策略等等)未执行完成的写入命令，也可以使用<code>redis-check-aof</code>工具修复AOF文件。</li><li>redis可以在AOF体积过大的时候，重写AOF文件，重写后的AOF文件包含了恢复当前数据集所需的最小命令集合，整个重写过程是安全的，因为redis在创建新的AOF文件的过程中，会继续将当前命令追加到AOF文件里面，即使重写过程发生了停机，现有的AOF文件也不会丢失。而一旦新的AOF文件创建完毕，redis就会从旧的AOF文件切换到新的AOF文件中，并开始对新的AOF文件进行追加操作。</li><li>AOF文件有序地保存了对数据库执行的所有写入操作，这些写入操作以redis写的形式保存，因此AOF文件的内容非常容易读懂，对文件进行分析也会轻松。导出AOF文件也会非常简单。</li></ul><h3 id="10-4-AOF缺点"><a href="#10-4-AOF缺点" class="headerlink" title="10.4. AOF缺点"></a>10.4. <a name='AOF-1'></a>AOF缺点</h3><ul><li>对于相同的数据集，AOF文件的体积通常要大于RDB文件的体积。</li><li>根据所使用的<code>fsync</code>策略，AOF速度可能会慢于RDB。在一般情况下，每秒<code>fsync</code>的性能依然非常高，而关闭<code>fsync</code>可以让AOF的速度和RDB一样快，即使在高负荷之下也是如此。不过在处理巨大的写入载入时，RDB可以提供更有保证的最大延迟时间。</li></ul><h3 id="10-5-4-X版本的持久化策略整合"><a href="#10-5-4-X版本的持久化策略整合" class="headerlink" title="10.5. 4.X版本的持久化策略整合"></a>10.5. <a name='X'></a>4.X版本的持久化策略整合</h3><ul><li>对AOF重写策略进行了优化</li><li>再重写AOF文件的时候，<code>4.x</code>版本之前是把内存数据集的操作指令落地，而新的版本把内存中的数据集以rdb的方式落地。<strong>这样重写后的AOF依然时追加日志，但是在恢复的时候先RDB再增量的日志，性能非常优秀</strong></li></ul><h2 id="11-简述Redis主从复制"><a href="#11-简述Redis主从复制" class="headerlink" title="11. 简述Redis主从复制"></a>11. <a name='Redis-1'></a>简述Redis主从复制</h2><h3 id="11-1-主从复制的过程"><a href="#11-1-主从复制的过程" class="headerlink" title="11.1. 主从复制的过程"></a>11.1. <a name='-1'></a>主从复制的过程</h3><ul><li>当master和slave正常连接的时候，通过一连串数据流来保证数据的同步</li><li>当master和slave断开又连接，断开时间不长的情况下，只要恢复少许数据。如果断开时间过长，需要进行全量复制。</li></ul><h3 id="11-2-主从复制的关注点"><a href="#11-2-主从复制的关注点" class="headerlink" title="11.2. 主从复制的关注点"></a>11.2. <a name='-1'></a>主从复制的关注点</h3><ul><li>redis使用异步复制，slave和master之间异步地确认处理地数据量</li><li>一个master可以有多个slave，slave也可以接受其他slave的连接，除了多个slave可以连接到一个master之外，slave之间也可以像层状结构那样连接到其他的slave。自redis 4.x版本起，所有的sub-slave将从master收到完全一样的数据流</li><li>复制在master侧时非阻塞的，这意味着master在一个或者多个slave进行初次同步或者部分重同步时，可以继续处理查询请求。</li><li>复制在slave侧大部分也是非阻塞的，当slave进行初次同步的时候，它可以使用旧的数据处理查询请求，假设你在<code>redis.conf</code>中配置了让redis这样做的话。否则，你可以配置如果复制流断开，redis slave会返回一个error给客户端。但是，在初次同步之后，旧的数据集必须被删除，同时加载新的数据集。slave在这个短暂的时间窗口内(如果数据量很大，也可能时间很长)，会阻塞到来的连接请求。自redis 4.0开始，可以配置redis使删除旧数据集的操作在另外一个不同的线程中进行，但是，加载新的数据集的操作依然需要在主线程中进行并且会阻塞slave。</li><li>复制既可以被用在可伸缩性，以便只读查询可以有多个slave进行</li><li>可以避免使用复制来避免master将全部数据集写入磁盘造成的开销，一种典型的技术是配置你的master的<code>redis.conf</code>以避免对磁盘进行持久化，然后连接一个slave，其配置为不定期保存或者启用AOF，但是这个设置必须小心，因为重新启动的master程序将从一个空的数据集开始。如果一个slave试图和master同步，那么这个slave也会被清空。</li><li><strong>如果master使用复制功能但是未配置持久化，那么请把自动重启功能关闭</strong> 。</li></ul><h3 id="11-3-复制的流程"><a href="#11-3-复制的流程" class="headerlink" title="11.3. 复制的流程"></a>11.3. <a name='-1'></a>复制的流程</h3><p>每个redis master都有一个replication ID: 这是一个较大的伪随机字符串，标记了一个给定的数据集。每个master也持有一个偏移量，master将自己产生的复制流发送给slave的时候，发送了多少个字节的数据，自身的偏移量就会增加多少，目的是当有新的操作修改自己的数据集的时候，它可以以此更新slave的状态。复制偏移量即使在没有一个slave连接到master的时候，也会自增，所以基本每一对给定的<code>(replication ID, offset)</code>都会标识一个master数据集的精确版本。</p><p>当slave连接到master的时候，它们使用<code>PSYNC</code>命令来发送它们记录的旧的master replication ID和它们至今为止处理的偏移量。通过这种方式，master能够仅发送slave所需的增量部分。但是如果master的缓冲区中没有足够的命令积压缓冲记录，或者如果slave引用了不再知道的历史replication ID，则会转而进行一个全量的重型同步：在这种情况下，slave会得到一个完整的数据集副本，从头开始。</p><p><strong>下面是全量同步的工作细节</strong> ：</p><p>master开启了一个后台保存进程，以便生产一个RDB文件，同时它开始缓冲所有从客户端接收到的新的写入命令。当后台保存完成的时候，master会将数据集文件传输给slave，slave将之保存在磁盘上，然后加载文件到内存当中。再然后master会发送所有缓冲的命令给slave。这个过程以指令流的形式完成并且和redis协议本身的格式相同。</p><p><strong>下面是无需磁盘参与的复制</strong> ：</p><p>正常情况下，一个全量重同步要求在磁盘上创建一个RDB文件，然后将它从磁盘加载进内存中，然后slave以此形式进行数据同步。如果磁盘性能很低，这对master压力很大。redis 2.8.18是第一个支持无磁盘复制的版本。在此设置中，子进程直接发送RDB给slave，无需使用磁盘作为中间存储介质。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Redis面试题汇总&quot;&gt;&lt;a href=&quot;#Redis面试题汇总&quot; class=&quot;headerlink&quot; title=&quot;Redis面试题汇总&quot;&gt;&lt;/a&gt;Redis面试题汇总&lt;/h1&gt;&lt;!-- vscode-markdown-toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol</summary>
      
    
    
    
    <category term="redis" scheme="https://timmy6.github.io/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>深入理解Channel</title>
    <link href="https://timmy6.github.io/2022/03/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Channel/"/>
    <id>https://timmy6.github.io/2022/03/16/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Channel/</id>
    <published>2022-03-16T15:15:10.000Z</published>
    <updated>2022-05-23T02:22:45.742Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Go源码阅读——runtime-chan"><a href="#Go源码阅读——runtime-chan" class="headerlink" title="Go源码阅读——runtime.chan"></a>Go源码阅读——runtime.chan</h1><!-- vscode-markdown-toc --><ul><li><ol><li><a href="#chan">chan结构体定义</a></li></ol></li><li><ol start="2"><li><a href="#chan-1">chan的创建</a></li></ol><ul><li>2.1. <a href="#chanmakechan">#真正创建chan——#makechan</a></li></ul></li><li><ol start="3"><li><a href="#">发送数据</a></li></ol><ul><li>3.1. <a href="#chansend">发送数据前检查——#chansend</a></li><li>3.2. <a href="#goroutinesend">如果有goroutine急着接收数据——#send</a></li><li>3.3. <a href="#-1">发送数据总结</a></li></ul></li><li><ol start="4"><li><a href="#-1">接收数据</a></li></ol><ul><li>4.1. <a href="#goroutinerecv">如果有goroutine急着发送数据——#recv</a></li><li>4.2. <a href="#-1">接收数据总结</a></li></ul></li><li><ol start="5"><li><a href="#chan-1">关闭chan</a></li></ol><ul><li>5.1. <a href="#chan-1">关闭chan总结</a></li></ul></li><li><ol start="6"><li><a href="#-1">案例说明(好案例)</a></li></ol></li><li><ol start="7"><li><a href="#-1">问题</a></li></ol><ul><li>7.1. <a href="#channelnilchannel">如果channel为nil，从这个channel中接收数据会怎么样？</a></li></ul></li><li><ol start="8"><li><a href="#nilchannel">关闭一个为nil的channel会怎么样?</a></li></ol></li><li><ol start="9"><li><a href="#channel">channel什么情况下会引起资源的泄露?</a></li></ol><ul><li>9.1. <a href="#channelGC">channel何时被GC收集?</a></li></ul></li></ul><!-- vscode-markdown-toc-config    numbering=true    autoSave=true    /vscode-markdown-toc-config --><!-- /vscode-markdown-toc --><h2 id="1-chan结构体定义"><a href="#1-chan结构体定义" class="headerlink" title="1. chan结构体定义"></a>1. <a name='chan'></a>chan结构体定义</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> hchan <span class="keyword">struct</span> &#123;</span><br><span class="line">qcount   <span class="type">uint</span>           <span class="comment">// 队列中元素总数量</span></span><br><span class="line">dataqsiz <span class="type">uint</span>           <span class="comment">// 循环队列的长度</span></span><br><span class="line">buf      unsafe.Pointer <span class="comment">// 指向长度为 dataqsiz 的底层数组，只有在有缓冲时这个才有意义</span></span><br><span class="line">elemsize <span class="type">uint16</span>         <span class="comment">// 能够发送和接受的元素大小</span></span><br><span class="line">closed   <span class="type">uint32</span>         <span class="comment">// 是否关闭</span></span><br><span class="line">elemtype *_type <span class="comment">// 元素的类型</span></span><br><span class="line">sendx    <span class="type">uint</span>   <span class="comment">// 当前已发送的元素在队列当中的索引位置</span></span><br><span class="line">recvx    <span class="type">uint</span>   <span class="comment">// 当前已接收的元素在队列当中的索引位置</span></span><br><span class="line">recvq    waitq  <span class="comment">// 接收 Goroutine 链表</span></span><br><span class="line">sendq    waitq  <span class="comment">// 发送 Goroutine 链表</span></span><br><span class="line"></span><br><span class="line">lock mutex <span class="comment">// 互斥锁</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// waitq 是一个双向链表，里面保存了 goroutine</span></span><br><span class="line"><span class="keyword">type</span> waitq <span class="keyword">struct</span> &#123;</span><br><span class="line">first *sudog</span><br><span class="line">last  *sudog</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><div align=center><img src="/images/other/chan1.png"/></div><p>可以看到,<code>chan</code>底层就是一个循环队列。</p><h2 id="2-chan的创建"><a href="#2-chan的创建" class="headerlink" title="2. chan的创建"></a>2. <a name='chan-1'></a>chan的创建</h2><p>在 Go 中我们使用 <code>make(chan T, cap)</code> 来创建 channel，make 语法会在编译时，转换为 <code>makechan64</code> 和 <code>makechan</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan64</span><span class="params">(t *chantype, size <span class="type">int64</span>)</span></span> *hchan &#123;</span><br><span class="line"><span class="keyword">if</span> <span class="type">int64</span>(<span class="type">int</span>(size)) != size &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> makechan(t, <span class="type">int</span>(size))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>makechan64</code> 主要是做了一下检查，最终还是会调用 <code>makechan</code> ，在看 <code>makechan</code> 源码之前，我们先来看两个全局常量，接下来会用到：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">maxAlign  = <span class="number">8</span></span><br><span class="line">hchanSize = unsafe.Sizeof(hchan&#123;&#125;) + <span class="type">uintptr</span>(-<span class="type">int</span>(unsafe.Sizeof(hchan&#123;&#125;))&amp;(maxAlign<span class="number">-1</span>))</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li><code>maxAlign</code> 是内存对齐的最大值，这个等于 64 位 CPU 下的 cacheline 的大小</li><li><code>hchanSize</code> 计算 <code>unsafe.Sizeof(hchan&#123;&#125;)</code> 最近的 8 的倍数</li></ul><h3 id="2-1-真正创建chan——-makechan"><a href="#2-1-真正创建chan——-makechan" class="headerlink" title="2.1. #真正创建chan——#makechan"></a>2.1. <a name='chanmakechan'></a>#真正创建chan——#makechan</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">makechan</span><span class="params">(t *chantype, size <span class="type">int</span>)</span></span> *hchan &#123;</span><br><span class="line">elem := t.elem</span><br><span class="line"></span><br><span class="line"><span class="comment">// 先做一些检查</span></span><br><span class="line">    <span class="comment">// 元素大小不能大于等于 64k</span></span><br><span class="line"><span class="keyword">if</span> elem.size &gt;= <span class="number">1</span>&lt;&lt;<span class="number">16</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: invalid channel element type&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 判断当前的 hchanSize 是否是 maxAlign 整数倍，并且元素的对齐大小不能大于最大对齐的大小</span></span><br><span class="line"><span class="keyword">if</span> hchanSize%maxAlign != <span class="number">0</span> || elem.align &gt; maxAlign &#123;</span><br><span class="line">throw(<span class="string">&quot;makechan: bad alignment&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里计算内存是否超过限制</span></span><br><span class="line">mem, overflow := math.MulUintptr(elem.size, <span class="type">uintptr</span>(size))</span><br><span class="line"><span class="keyword">if</span> overflow || mem &gt; maxAlloc-hchanSize || size &lt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;makechan: size out of range&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c *hchan</span><br><span class="line"><span class="keyword">switch</span> &#123;</span><br><span class="line"><span class="keyword">case</span> mem == <span class="number">0</span>: <span class="comment">// 如果是无缓冲通道</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize, <span class="literal">nil</span>, <span class="literal">true</span>)) <span class="comment">// 为 hchan 分配内存</span></span><br><span class="line">c.buf = c.raceaddr() <span class="comment">// 这个是 for data race 检测的</span></span><br><span class="line"><span class="keyword">case</span> elem.ptrdata == <span class="number">0</span>: <span class="comment">// 元素不包含指针</span></span><br><span class="line">c = (*hchan)(mallocgc(hchanSize+mem, <span class="literal">nil</span>, <span class="literal">true</span>)) <span class="comment">// 为 hchan 和底层数组分配一段连续的内存地址</span></span><br><span class="line">c.buf = add(unsafe.Pointer(c), hchanSize)</span><br><span class="line"><span class="keyword">default</span>: <span class="comment">// 如果元素包含指针，分别为 hchan 和 底层数组分配内存地址</span></span><br><span class="line">c = <span class="built_in">new</span>(hchan)</span><br><span class="line">c.buf = mallocgc(mem, elem, <span class="literal">true</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一些值</span></span><br><span class="line">c.elemsize = <span class="type">uint16</span>(elem.size)</span><br><span class="line">c.elemtype = elem</span><br><span class="line">c.dataqsiz = <span class="type">uint</span>(size)</span><br><span class="line">lockInit(&amp;c.lock, lockRankHchan)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> c</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，创建的过程可以总结为如下：</p><ul><li>创建时会做一些检查<ul><li>元素大小不能超过 64K</li><li>元素的对齐大小不能超过 maxAlign 也就是 8 字节</li><li>计算出来的内存是否超过限制</li></ul></li><li>创建时的策略<ul><li>如果是无缓冲的 channel，会直接给 hchan 分配内存</li><li>如果是有缓冲的 channel，并且元素不包含指针，那么会为 hchan 和底层数组分配一段连续的地址</li><li>如果是有缓冲的 channel，并且元素包含指针，那么会为 hchan 和底层数组分别分配地址</li></ul></li></ul><h2 id="3-发送数据"><a href="#3-发送数据" class="headerlink" title="3. 发送数据"></a>3. <a name=''></a>发送数据</h2><div align=center><img src="/images/other/chan2.png"/></div><h3 id="3-1-发送数据前检查——-chansend"><a href="#3-1-发送数据前检查——-chansend" class="headerlink" title="3.1. 发送数据前检查——#chansend"></a>3.1. <a name='chansend'></a>发送数据前检查——#chansend</h3><p>我们在 <code>x &lt;- chan T</code> 进行发送数据的时候最终会被编译成 <code>chansend1</code>：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend1</span><span class="params">(c *hchan, elem unsafe.Pointer)</span></span> &#123;</span><br><span class="line">chansend(c, elem, <span class="literal">true</span>, getcallerpc())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而 <code>chansend1</code> 最终还是调用了 <code>chansend</code> 主要的逻辑都在 <code>chansend</code> 上面，注意看下方源码和注释：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代码中删除了调试相关的代码</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chansend</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>, callerpc <span class="type">uintptr</span>)</span></span> <span class="type">bool</span> &#123;</span><br><span class="line">    <span class="comment">// 如果是一个 nil 值的 channel</span></span><br><span class="line">    <span class="comment">// 如果是非阻塞的话就直接返回</span></span><br><span class="line">    <span class="comment">// 如果不是，那么则调用 gopark 休眠当前 goroutine 并且抛出 panic 错误</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanSendNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// fast path 如果当前是非阻塞的</span></span><br><span class="line">    <span class="comment">// 并且通道尚未关闭</span></span><br><span class="line">    <span class="comment">// 并且缓冲区已满时，直接返回</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; c.closed == <span class="number">0</span> &amp;&amp; full(c) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果通道已经关闭了，直接 panic，不允许向一个已经关闭的 channel 写入数据</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果当前存在等待接收数据的 goroutine 直接取出第一个，将数据传递给第一个等待的 goroutine</span></span><br><span class="line"><span class="keyword">if</span> sg := c.recvq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// send 用于发送数据，我们后面再看</span></span><br><span class="line">send(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果当前 channel 包含缓冲区，并且缓冲区没有满</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &lt; c.dataqsiz &#123;</span><br><span class="line"><span class="comment">// 计算数组中下一个可以存放数据的地址</span></span><br><span class="line">qp := chanbuf(c, c.sendx)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将当前的数据放到缓冲区中</span></span><br><span class="line">typedmemmove(c.elemtype, qp, ep)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 索引加一</span></span><br><span class="line">        c.sendx++</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 由于是循环队列，如果索引地址等于数组长度，就需要将索引移动到 0</span></span><br><span class="line"><span class="keyword">if</span> c.sendx == c.dataqsiz &#123;</span><br><span class="line">c.sendx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 当前缓存数据量加一</span></span><br><span class="line">c.qcount++</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是非阻塞的就直接返回了，因为非阻塞发送的情况已经走完了，下面是阻塞发送的逻辑</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取发送数据的 goroutine</span></span><br><span class="line">gp := getg()</span><br><span class="line">    <span class="comment">// 获取 sudog 结构体，并且设置相关信息，包括当前的 channel，是否是 select 等</span></span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.waiting = mysg</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 sudog 结构加入到发送的队列中</span></span><br><span class="line">c.sendq.enqueue(mysg)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 挂起当前 goroutine 等待接收 channel数据</span></span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanSend, traceEvGoBlockSend, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 保证当前数据处于活跃状态避免被回收</span></span><br><span class="line">KeepAlive(ep)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送者 goroutine 被唤醒，检查当前 sg 的状态</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> gp.param == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">if</span> c.closed == <span class="number">0</span> &#123;</span><br><span class="line">throw(<span class="string">&quot;chansend: spurious wakeup&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;send on closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消 channel 绑定</span></span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">    <span class="comment">// 释放 sudog</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-2-如果有goroutine急着接收数据——-send"><a href="#3-2-如果有goroutine急着接收数据——-send" class="headerlink" title="3.2. 如果有goroutine急着接收数据——#send"></a>3.2. <a name='goroutinesend'></a>如果有goroutine急着接收数据——#send</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">send</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果 sudog 上存在数据元素，就调用 sendDirect 直接把数据拷贝到接收变量的地址上</span></span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">sendDirect(c.elemtype, sg, ep)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 goready 将接受者的 Goroutine 标记为可运行状态，并把它放到发送方的所在处理器的 runnext 等待执行，下次调度时就会执行到它。</span></span><br><span class="line">    <span class="comment">// 注意这里不是立即执行</span></span><br><span class="line">goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-发送数据总结"><a href="#3-3-发送数据总结" class="headerlink" title="3.3. 发送数据总结"></a>3.3. <a name='-1'></a>发送数据总结</h3><p>向 channel 中发送数据时大概分为两大块，检查和数据发送，而数据发送又分为三种情况：</p><ul><li>如果 channel 的<code>recvq</code> 存在阻塞等待的接收数据的 goroutine 那么将会直接将数据发送给第一个等待的 goroutine<ul><li>这里会直接将数据拷贝到 <code>x &lt;-ch</code> 接收者的变量 <code>x</code> 上</li><li>然后将接收者的 Goroutine 修改为可运行状态，并把它放到发送方所在处理器的 runnext 上等待下一次调度时执行。</li></ul></li><li>如果 channel 是有缓冲的，并且缓冲区没有满，这个时候就会把数据放到缓冲区中</li><li>如果 channel 的缓冲区满了，这个时候就会走阻塞发送的流程，获取到 sudog 之后将当前 Goroutine 挂起等待唤醒，唤醒后将相关的数据解绑，回收掉 sudog</li></ul><h2 id="4-接收数据"><a href="#4-接收数据" class="headerlink" title="4. 接收数据"></a>4. <a name='-1'></a>接收数据</h2><div align=center><img src="/images/other/chan3.png"/></div><p>在 Go 中接收 channel 数据有两种方式</p><ul><li><code>x &lt;- ch</code> 编译时会被转换为 <code>chanrecv1</code></li><li><code>x, ok &lt;- ch</code> 编译时会被转换为 <code>chanrecv2</code></li></ul><p><code>chanrecv1</code> 和 <code>chanrecv2</code> 没有多大区别，只是 <code>chanrecv2</code> 比 <code>chanrecv1</code> 多了一个返回值，最终都是调用的 <code>chanrecv</code> 来实现的接收数据</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// selected 用于 select&#123;&#125; 语法中是否会选中该分支</span></span><br><span class="line"><span class="comment">// received 表示当前是否真正的接收到数据，用来判断 channel 是否 closed 掉了</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">chanrecv</span><span class="params">(c *hchan, ep unsafe.Pointer, block <span class="type">bool</span>)</span></span> (selected, received <span class="type">bool</span>) &#123;</span><br><span class="line"><span class="comment">// 和发送数据类似，先判断是否为nil，如果是 nil 并且阻塞接收就会 panic</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="comment">// 如果不阻塞，直接返回</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 如果是阻塞模式，接收一个nil的chan会导致挂起</span></span><br><span class="line">gopark(<span class="literal">nil</span>, <span class="literal">nil</span>, waitReasonChanReceiveNilChan, traceEvGoStop, <span class="number">2</span>)</span><br><span class="line">        <span class="comment">// 不会执行到这里</span></span><br><span class="line">throw(<span class="string">&quot;unreachable&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fast path: 检查非阻塞的操作</span></span><br><span class="line">    <span class="comment">// empty 主要是有两种情况返回 true:</span></span><br><span class="line">    <span class="comment">// 1. 无缓冲channel，并且没有阻塞住发送者</span></span><br><span class="line">    <span class="comment">// 2. 有缓冲 channel，但是缓冲区没有数据</span></span><br><span class="line"><span class="keyword">if</span> !block &amp;&amp; empty(c) &#123;</span><br><span class="line"><span class="comment">// 这里判断通道是否关闭，如果是未关闭的通道说明当前还没准备好数据，直接返回</span></span><br><span class="line"><span class="keyword">if</span> atomic.Load(&amp;c.closed) == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果通道已经关闭了，再检查一下通道还有没有数据，如果已经没数据了，我们清理到 ep 指针中的数据并且返回</span></span><br><span class="line"><span class="keyword">if</span> empty(c) &#123;</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上锁</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果通道已经关闭了，并且已经没数据了，我们清理到 ep 指针中的数据并且返回</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &amp;&amp; c.qcount == <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, ep)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待发送队列中goroutine的存在</span></span><br><span class="line">    <span class="comment">// 如果goroutine存在，说明存在下面两种情况:</span></span><br><span class="line">    <span class="comment">// 1. 是非缓冲型的channel</span></span><br><span class="line">    <span class="comment">// 2. 是缓冲型的channel，但是缓冲区已经满了</span></span><br><span class="line">    <span class="comment">// 针对1类型：直接进行内存的拷贝，即从sender goroutine -&gt; receiver goroutine</span></span><br><span class="line">    <span class="comment">// 针对2类型，接收到循环数组头部的数据，并将发送者的元素放置到循环数组尾部</span></span><br><span class="line"><span class="keyword">if</span> sg := c.sendq.dequeue(); sg != <span class="literal">nil</span> &#123;</span><br><span class="line">recv(c, sg, ep, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; unlock(&amp;c.lock) &#125;, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// qcount&gt;0，说明缓冲区还有数据</span></span><br><span class="line"><span class="keyword">if</span> c.qcount &gt; <span class="number">0</span> &#123;</span><br><span class="line"><span class="comment">// 直接从循环数组中找到要接收到数据</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// ep不是nil，说明程序代码中的接收格式为： val &lt;-ch 而不是 &lt;-ch</span></span><br><span class="line">        <span class="comment">// 说明此时有接收对象，将chan中的数据值拷贝到ep指针对应的地方</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 如果ep为nil，说明没有接收对象，那么直接将chan中的数据抹除即可</span></span><br><span class="line">typedmemclr(c.elemtype, qp)</span><br><span class="line">        <span class="comment">// 接收游标向前移动</span></span><br><span class="line">c.recvx++</span><br><span class="line">        <span class="comment">// 接收游标达到边界值，那么清除游标的值</span></span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 数据被接收了，少了1个</span></span><br><span class="line">c.qcount--</span><br><span class="line">        <span class="comment">// 解锁</span></span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是非阻塞的情况，此时没有缓冲区，也就没有数据</span></span><br><span class="line"><span class="keyword">if</span> !block &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>, <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 阻塞接受，和发送类似，拿到当前 Goroutine 和 sudog 并且做一些数据填充</span></span><br><span class="line">gp := getg()</span><br><span class="line">mysg := acquireSudog()</span><br><span class="line">mysg.releasetime = <span class="number">0</span></span><br><span class="line"><span class="keyword">if</span> t0 != <span class="number">0</span> &#123;</span><br><span class="line">mysg.releasetime = <span class="number">-1</span></span><br><span class="line">&#125;</span><br><span class="line">mysg.elem = ep</span><br><span class="line">mysg.waitlink = <span class="literal">nil</span></span><br><span class="line">gp.waiting = mysg</span><br><span class="line">mysg.g = gp</span><br><span class="line">mysg.isSelect = <span class="literal">false</span></span><br><span class="line">mysg.c = c</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 sudog 放入到接收者队列当中</span></span><br><span class="line">c.recvq.enqueue(mysg)</span><br><span class="line">    <span class="comment">// 然后休眠当前 Goroutine 等待唤醒</span></span><br><span class="line">gopark(chanparkcommit, unsafe.Pointer(&amp;c.lock), waitReasonChanReceive, traceEvGoBlockRecv, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Goroutine 被唤醒，接收完数据，做一些数据清理的操作，释放掉 sudog 然后返回</span></span><br><span class="line"><span class="keyword">if</span> mysg != gp.waiting &#123;</span><br><span class="line">throw(<span class="string">&quot;G waiting list is corrupted&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line">gp.waiting = <span class="literal">nil</span></span><br><span class="line">gp.activeStackChans = <span class="literal">false</span></span><br><span class="line"><span class="keyword">if</span> mysg.releasetime &gt; <span class="number">0</span> &#123;</span><br><span class="line">blockevent(mysg.releasetime-t0, <span class="number">2</span>)</span><br><span class="line">&#125;</span><br><span class="line">closed := gp.param == <span class="literal">nil</span></span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line">mysg.c = <span class="literal">nil</span></span><br><span class="line">releaseSudog(mysg)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>, !closed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-1-如果有goroutine急着发送数据——-recv"><a href="#4-1-如果有goroutine急着发送数据——-recv" class="headerlink" title="4.1. 如果有goroutine急着发送数据——#recv"></a>4.1. <a name='goroutinerecv'></a>如果有goroutine急着发送数据——#recv</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">recv</span><span class="params">(c *hchan, sg *sudog, ep unsafe.Pointer, unlockf <span class="keyword">func</span>()</span></span>, skip <span class="type">int</span>) &#123;</span><br><span class="line"><span class="comment">// 如果无缓冲的 channel 直接调用 recvDirect 将数据从发送者 Goroutine 拷贝到变量</span></span><br><span class="line">    <span class="keyword">if</span> c.dataqsiz == <span class="number">0</span> &#123;</span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="comment">// copy data from sender</span></span><br><span class="line">recvDirect(c.elemtype, sg, ep)</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// 否则的话说明这是一个有缓冲的 channel 并且缓冲已经满了</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 先从底层数组中拿到数据地址</span></span><br><span class="line">qp := chanbuf(c, c.recvx)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后把数据复制到接收变量上</span></span><br><span class="line"><span class="keyword">if</span> ep != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemmove(c.elemtype, ep, qp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 然后将发送者 Goroutine 中的数据拷贝到底层数组上</span></span><br><span class="line">typedmemmove(c.elemtype, qp, sg.elem)</span><br><span class="line">c.recvx++</span><br><span class="line"><span class="keyword">if</span> c.recvx == c.dataqsiz &#123;</span><br><span class="line">c.recvx = <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line">c.sendx = c.recvx <span class="comment">// c.sendx = (c.sendx+1) % c.dataqsiz</span></span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 最后做一些清理操作</span></span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">gp := sg.g</span><br><span class="line">unlockf()</span><br><span class="line">gp.param = unsafe.Pointer(sg)</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">goready(gp, skip+<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-接收数据总结"><a href="#4-2-接收数据总结" class="headerlink" title="4.2. 接收数据总结"></a>4.2. <a name='-1'></a>接收数据总结</h3><p>数据接收和发送其实大同小异，也是分为检查和数据接收，数据接收又分三种情况</p><ul><li>直接获取数据，如果当前有阻塞的发送者 Goroutine 走这条路<ul><li>如果是无缓冲 channel，直接从发送者那里把数据拷贝给接收变量</li><li>如果是有缓冲 channel，并且 channel 已经满了，就先从 channel 的底层数组拷贝数据，再把阻塞的发送者 Goroutine 的数据拷贝到 channel 的循环队列中</li></ul></li><li>从 channel 的缓冲中获取数据，有缓冲 channel 并且缓存队列有数据时走这条路<ul><li>直接从缓存队列中复制数据给接收变量</li></ul></li><li>阻塞接收，剩余情况走这里<ul><li>和发送类似，先获取当前 Goroutine 信息，构造 sudog 加入到 channel 的 recvq 上</li><li>然后休眠当前 Goroutine 等待唤醒</li><li>唤醒后做一些清理工作，释放 sudog 返回</li></ul></li></ul><h2 id="5-关闭chan"><a href="#5-关闭chan" class="headerlink" title="5. 关闭chan"></a>5. <a name='chan-1'></a>关闭chan</h2><p>我们使用 <code>close(ch)</code> 来关闭 channel 最后会调用 runtime 中的 <code>closechan</code> 方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">closechan</span><span class="params">(c *hchan)</span></span> &#123;</span><br><span class="line">    <span class="comment">// 关闭 nil 的 channel 会导致 panic</span></span><br><span class="line"><span class="keyword">if</span> c == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of nil channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加锁</span></span><br><span class="line">lock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭已关闭的 channel 会导致 panic</span></span><br><span class="line"><span class="keyword">if</span> c.closed != <span class="number">0</span> &#123;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"><span class="built_in">panic</span>(plainError(<span class="string">&quot;close of closed channel&quot;</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置 channel 状态</span></span><br><span class="line">c.closed = <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> glist gList</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放所有的接收者 Goroutine</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.recvq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.elem != <span class="literal">nil</span> &#123;</span><br><span class="line">typedmemclr(c.elemtype, sg.elem)</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"></span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放所有的发送者channel，会 panic 因为不允许向已关闭的 channel 发送数据</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">sg := c.sendq.dequeue()</span><br><span class="line"><span class="keyword">if</span> sg == <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">sg.elem = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> sg.releasetime != <span class="number">0</span> &#123;</span><br><span class="line">sg.releasetime = cputicks()</span><br><span class="line">&#125;</span><br><span class="line">gp := sg.g</span><br><span class="line">gp.param = <span class="literal">nil</span></span><br><span class="line"><span class="keyword">if</span> raceenabled &#123;</span><br><span class="line">raceacquireg(gp, c.raceaddr())</span><br><span class="line">&#125;</span><br><span class="line">glist.push(gp)</span><br><span class="line">&#125;</span><br><span class="line">unlock(&amp;c.lock)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将所有的 Goroutine 设置为可运行状态</span></span><br><span class="line"><span class="keyword">for</span> !glist.empty() &#123;</span><br><span class="line">gp := glist.pop()</span><br><span class="line">gp.schedlink = <span class="number">0</span></span><br><span class="line">goready(gp, <span class="number">3</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-1-关闭chan总结"><a href="#5-1-关闭chan总结" class="headerlink" title="5.1. 关闭chan总结"></a>5.1. <a name='chan-1'></a>关闭chan总结</h3><ul><li>关闭一个 nil 的 channel 和已关闭了的 channel 都会导致 panic</li><li>关闭 channel 后会释放所有因为 channel 而阻塞的 Goroutine</li></ul><h2 id="6-案例说明-好案例"><a href="#6-案例说明-好案例" class="headerlink" title="6. 案例说明(好案例)"></a>6. <a name='-1'></a>案例说明(好案例)</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gA</span><span class="params">(a &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    val := &lt;-a</span><br><span class="line">    fmt.Println(<span class="string">&quot;g1 received data:&quot;</span>, val)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">gB</span><span class="params">(b &lt;-<span class="keyword">chan</span> <span class="type">int</span>)</span></span> &#123;</span><br><span class="line">    val := &lt;-b</span><br><span class="line">    fmt.Println(<span class="string">&quot;g2 received data:&quot;</span>, val)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>)</span><br><span class="line">    <span class="keyword">go</span> gA(ch)</span><br><span class="line">    <span class="keyword">go</span> gB(ch)</span><br><span class="line">    ch &lt;- <span class="number">3</span></span><br><span class="line">    time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先创建了一个无缓冲的 channel，接着启动两个 goroutine，并将前面创建的 channel 传递进 去。然后，向这个 channel 中发送数据 3，最后 sleep 1 秒后程序退出。</p><h2 id="7-问题"><a href="#7-问题" class="headerlink" title="7. 问题"></a>7. <a name='-1'></a>问题</h2><h3 id="7-1-如果channel为nil，从这个channel中接收数据会怎么样？"><a href="#7-1-如果channel为nil，从这个channel中接收数据会怎么样？" class="headerlink" title="7.1. 如果channel为nil，从这个channel中接收数据会怎么样？"></a>7.1. <a name='channelnilchannel'></a>如果channel为nil，从这个channel中接收数据会怎么样？</h3><ul><li>在非阻塞模式下，会直接返回</li><li>在阻塞模式下，会调用<code>gopark</code>挂起goroutine，并且会一直阻塞下去</li></ul><h2 id="8-关闭一个为nil的channel会怎么样"><a href="#8-关闭一个为nil的channel会怎么样" class="headerlink" title="8. 关闭一个为nil的channel会怎么样?"></a>8. <a name='nilchannel'></a>关闭一个为nil的channel会怎么样?</h2><p>关闭一个nil的channel或者一个已经关闭的channel都会导致panic</p><h2 id="9-channel什么情况下会引起资源的泄露"><a href="#9-channel什么情况下会引起资源的泄露" class="headerlink" title="9. channel什么情况下会引起资源的泄露?"></a>9. <a name='channel'></a>channel什么情况下会引起资源的泄露?</h2><p>channel资源泄露的原因是goroutine操作channel之后，处于发送或者接收阻塞状态，而channel处于满或者空的状态，一直得不到改变。他同时，垃圾回收器也不会回收这部分的资源，就会导致goroutine一直处于等待的状态。</p><h3 id="9-1-channel何时被GC收集"><a href="#9-1-channel何时被GC收集" class="headerlink" title="9.1. channel何时被GC收集?"></a>9.1. <a name='channelGC'></a>channel何时被GC收集?</h3><p>如果一个channel没有任何goroutine引用，GC就会对其进行回收操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Go源码阅读——runtime-chan&quot;&gt;&lt;a href=&quot;#Go源码阅读——runtime-chan&quot; class=&quot;headerlink&quot; title=&quot;Go源码阅读——runtime.chan&quot;&gt;&lt;/a&gt;Go源码阅读——runtime.chan&lt;/h1&gt;&lt;</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go高级" scheme="https://timmy6.github.io/tags/Go%E9%AB%98%E7%BA%A7/"/>
    
  </entry>
  
  <entry>
    <title>探究Go语言中的interface</title>
    <link href="https://timmy6.github.io/2021/10/16/%E6%8E%A2%E7%A9%B6Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84interface/"/>
    <id>https://timmy6.github.io/2021/10/16/%E6%8E%A2%E7%A9%B6Go%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84interface/</id>
    <published>2021-10-16T11:15:10.000Z</published>
    <updated>2022-05-23T01:59:07.480Z</updated>
    
    <content type="html"><![CDATA[<h1 id="探究Go语言中的interface"><a href="#探究Go语言中的interface" class="headerlink" title="探究Go语言中的interface"></a>探究Go语言中的interface</h1><!-- vscode-markdown-toc --><ul><li><ol><li><a href="#">前言</a></li></ol></li><li><ol start="2"><li><a href="#-1">探究的目标</a></li></ol></li><li><ol start="3"><li><a href="#interface">interface的组成部分</a></li></ol><ul><li>3.1. <a href="#fun">接口的方法数据——fun数组</a></li><li>3.2. <a href="#interfacetype">接口的类型描述——interfacetype</a></li><li>3.3. <a href="#_type">类型的运行时表示—— _type</a></li></ul></li><li><ol start="4"><li><a href="#-1">值接收者和指针接收者</a></li></ol><ul><li>4.1. <a href="#-1">两者分别在何时使用</a></li></ul></li><li><ol start="5"><li><a href="#nilinterface">有关nil和interface</a></li></ol></li><li><ol start="6"><li><a href="#interface-1">interface的创建过程(太难了，慢慢写)</a></li></ol></li></ul><!-- vscode-markdown-toc-config    numbering=true    autoSave=true    /vscode-markdown-toc-config --><!-- /vscode-markdown-toc --><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. <a name=''></a>前言</h2><p>Go语言并没有设计诸如虚函数，纯虚函数，继承，多重继承等概念，但是它通过接口非常优雅地实现了支持面向对象地特性。多态是一种<strong>运行期</strong>的行为，有下面几个特点：</p><ul><li>一种类型具有多种类型的能力</li><li>允许不同的对象对同一个消息做出灵活的反应</li><li>以一种通用的方式对待使用的对象</li><li>非动态语言必须通过继承和接口的方式来实现</li></ul><p>Golang通过接口<code>interfacc</code>的方式实现了面向对象的特性，即<strong>鸭子类型</strong> ：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果一个动物长得像鸭子，行为像鸭子，那么它有极大的可能就是鸭子</span><br></pre></td></tr></table></figure><p>鸭子类型是一种动态语言的风格，在这种风格下，一个对象的有效的语义，不是由继承自特定的类或者特定的接口，例如Java中的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Duck</span> <span class="keyword">implements</span> <span class="title class_">AnimalIface</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><p>而是由<strong>它当前的方法或者属性的集合</strong>决定。Go作为一种现代静态语言，通过接口实现了鸭子类型，实际上是Go的编译器在其中做了隐匿转换。</p><h2 id="2-探究的目标"><a href="#2-探究的目标" class="headerlink" title="2. 探究的目标"></a>2. <a name='-1'></a>探究的目标</h2><ul><li>interface 如何构建，其内容如何组成。</li><li>动态分发是如何实现的，什么时候进行，并且有什么样的调用成本。</li><li>空接口和其它特殊情况有什么异同。</li><li>怎么组合 interface 完成工作。</li><li>如何进行断言，断言的成本有多高。</li></ul><h2 id="3-interface的组成部分"><a href="#3-interface的组成部分" class="headerlink" title="3. interface的组成部分"></a>3. <a name='interface'></a>interface的组成部分</h2><p>Go 语言根据接口类型是否包含一组方法将接口类型分成了两类：</p><ul><li>使用 <a href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a> 结构体表示包含方法的接口</li><li>使用 <a href="https://draveness.me/golang/tree/runtime.eface"><code>runtime.eface</code></a> 结构体表示不包含任何方法的 <code>interface&#123;&#125;</code> 类型；</li></ul><p><a href="https://draveness.me/golang/tree/runtime.eface"><code>runtime.eface</code></a> 结构体在 Go 语言中的定义是这样的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> eface <span class="keyword">struct</span> &#123; <span class="comment">// 16 字节</span></span><br><span class="line">_type *_type</span><br><span class="line">data  unsafe.Pointer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>interface&#123;&#125;</code> 类型不包含任何方法，所以它的结构也相对来说比较简单，只包含指向底层数据和类型的两个指针。从上述结构我们也能推断出 — Go 语言的任意类型都可以转换成 <code>interface&#123;&#125;</code>。</p><p>另一个用于表示接口的结构体是 <a href="https://draveness.me/golang/tree/runtime.iface"><code>runtime.iface</code></a>，这个结构体中有指向原始数据的指针 <code>data</code>，不过更重要的是 <a href="https://draveness.me/golang/tree/runtime.itab"><code>runtime.itab</code></a> 类型的 <code>tab</code> 字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> iface <span class="keyword">struct</span> &#123; <span class="comment">// 16 字节</span></span><br><span class="line">tab  *itab</span><br><span class="line">data unsafe.Pointer</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> itab <span class="keyword">struct</span> &#123;</span><br><span class="line">    inter *interfacetype</span><br><span class="line">     _type *_type</span><br><span class="line">    link *itab</span><br><span class="line">    hash <span class="type">uint32</span> <span class="comment">// copy of _type.hash. Used for type switches.</span></span><br><span class="line">    bad <span class="type">bool</span> <span class="comment">// type does not implement interface</span></span><br><span class="line">    inhash <span class="type">bool</span> <span class="comment">// has this itab been added to hash?</span></span><br><span class="line">    unused [<span class="number">2</span>]<span class="type">byte</span></span><br><span class="line">    fun [<span class="number">1</span>]<span class="type">uintptr</span> <span class="comment">// variable sized</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>iface</code> 内部维护两个指针， <code>tab</code> 指向一个 <code>itab</code> 实体， 它表示接口的类型以及赋给这个 接口的实体类型。 <code>data</code> 则指向接口具体的值，一般而言是一个指向<strong>堆内存</strong>的指针。 再来仔细看一下 itab 结构体： <code>_type</code> 字段描述了实体的类型，包括内存对齐方式，大小 等； <code>inter</code> 字段则描述了接口的类型。</p><h3 id="3-1-接口的方法数据——fun数组"><a href="#3-1-接口的方法数据——fun数组" class="headerlink" title="3.1. 接口的方法数据——fun数组"></a>3.1. <a name='fun'></a>接口的方法数据——fun数组</h3><p>为什么<code>fun</code>数组的大小为1，要是接口定义了多个方法怎么办？<strong>实际上，这里存储的只是第一个方法的函数指针，如果有更多的方法，地址自增就行。另外，所有的方法都是按照方法名称的字典序进行排列的。</strong></p><p> **<code>fun</code> 字段放置和接口方法对应的具体数据类型的方法地址，实现接口调用方法的动态分派，一般在每次给接口赋值发生转换时会更新此表，或者直接拿缓存的 <code>itab</code>**。 这里只会列出实体类型和接口相关的方法，实体类型的其他方法并不会出现在这里。如果你学过 C++ 的话，这里可以类比虚函数的概念。</p><h3 id="3-2-接口的类型描述——interfacetype"><a href="#3-2-接口的类型描述——interfacetype" class="headerlink" title="3.2. 接口的类型描述——interfacetype"></a>3.2. <a name='interfacetype'></a>接口的类型描述——interfacetype</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> interfacetype <span class="keyword">struct</span> &#123;</span><br><span class="line">typ _type</span><br><span class="line">pkgpath name</span><br><span class="line">mhdr []imethod</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，它包装了 <code>_type</code> 类型， <code>_type</code> 实际上是描述 Go 语言中各种数据类型的结构体。 我们注意到，这里还包含一个 <code>mhdr</code> 字段，表示接口所定义的函数列表， <code>pkgpath</code> 记录定义 了接口的包名。</p><p>这里通过一张图来看下 iface 结构体的全貌：</p><div align=center><img src="/images/other/if2.png"/></div><h3 id="3-3-类型的运行时表示——-type"><a href="#3-3-类型的运行时表示——-type" class="headerlink" title="3.3. 类型的运行时表示—— _type"></a>3.3. <a name='_type'></a>类型的运行时表示—— _type</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> _type <span class="keyword">struct</span> &#123;</span><br><span class="line">size       <span class="type">uintptr</span></span><br><span class="line">ptrdata    <span class="type">uintptr</span></span><br><span class="line">hash       <span class="type">uint32</span></span><br><span class="line">tflag      tflag</span><br><span class="line">align      <span class="type">uint8</span></span><br><span class="line">fieldAlign <span class="type">uint8</span></span><br><span class="line">kind       <span class="type">uint8</span></span><br><span class="line">equal      <span class="function"><span class="keyword">func</span><span class="params">(unsafe.Pointer, unsafe.Pointer)</span></span> <span class="type">bool</span></span><br><span class="line">gcdata     *<span class="type">byte</span></span><br><span class="line">str        nameOff</span><br><span class="line">ptrToThis  typeOff</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>size</code> 字段存储了类型占用的内存空间，为内存空间的分配提供信息；</li><li><code>hash</code> 字段能够帮助我们快速确定类型是否相等；</li><li><code>equal</code> 字段用于判断当前类型的多个对象是否相等，该字段是为了减少 Go 语言二进制包大小从 <code>typeAlg</code> 结构体中迁移过来的。</li></ul><p>Go 语言各种数据类型都是在 <code>_type</code> 字段的基础上，增加一些额外的字段来进行管理的：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> arraytype <span class="keyword">struct</span> &#123;</span><br><span class="line">typ _type</span><br><span class="line">elem *_type</span><br><span class="line">slice *_type</span><br><span class="line"><span class="built_in">len</span> <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> chantype <span class="keyword">struct</span> &#123;</span><br><span class="line">typ _type</span><br><span class="line">elem *_type</span><br><span class="line">dir <span class="type">uintptr</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> slicetype <span class="keyword">struct</span> &#123;</span><br><span class="line">typ _type</span><br><span class="line">elem *_type</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> structtype <span class="keyword">struct</span> &#123;</span><br><span class="line">typ _type</span><br><span class="line">pkgPath name</span><br><span class="line">fields []structfield</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些数据类型的结构体定义，是反射实现的基础。</p><h2 id="4-值接收者和指针接收者"><a href="#4-值接收者和指针接收者" class="headerlink" title="4. 值接收者和指针接收者"></a>4. <a name='-1'></a>值接收者和指针接收者</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Math <span class="keyword">interface</span> &#123;</span><br><span class="line">Get() <span class="type">int</span></span><br><span class="line">Add()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Adder <span class="keyword">struct</span> &#123;</span><br><span class="line">id <span class="type">int</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(adder Adder)</span></span> Get() <span class="type">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> adder.id</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(adder *Adder)</span></span> Add() &#123;</span><br><span class="line">adder.id++</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 值类型</span></span><br><span class="line">adderVal := Adder&#123;id: <span class="number">100</span>&#125;</span><br><span class="line">    <span class="comment">// 指针类型</span></span><br><span class="line">adderPtr := &amp;Adder&#123;id: <span class="number">200</span>&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(adderVal.Get())</span><br><span class="line">adderVal.Add()</span><br><span class="line">fmt.Println(adderVal.Get())</span><br><span class="line"></span><br><span class="line">fmt.Println(adderPtr.Get())</span><br><span class="line">adderPtr.Add()</span><br><span class="line">fmt.Println(adderPtr.Get())</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述输出的结果为：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PS D:\Github\repo\Go-Backend\src\g_interface&gt; <span class="keyword">go</span> run main.<span class="keyword">go</span></span><br><span class="line"><span class="number">100</span></span><br><span class="line"><span class="number">101</span></span><br><span class="line"><span class="number">200</span></span><br><span class="line"><span class="number">201</span></span><br></pre></td></tr></table></figure><p>调用了<code>Add()</code>之后，无论是值接受者还是指针接受者的<code>id</code>都发生了改变，这实际上是编译器在背后做了一些工作：</p><table><thead><tr><th align="center">-</th><th align="center">值接收者</th><th align="center">指针接收者</th></tr></thead><tbody><tr><td align="center"><strong>值调用者</strong></td><td align="center">方法会使用调用者的一个副本</td><td align="center">使用值的引用来调用方法<code>(&amp;adderVal).Add()</code></td></tr><tr><td align="center"><strong>指针调用者</strong></td><td align="center">指针被解引用<code>(*adderPtr).Add()</code></td><td align="center">会使用调用者指针的一个副本</td></tr></tbody></table><p><strong>实现了值接收者的方法，会隐含的实现了指针接收者的方法。</strong></p><h3 id="4-1-两者分别在何时使用"><a href="#4-1-两者分别在何时使用" class="headerlink" title="4.1. 两者分别在何时使用"></a>4.1. <a name='-1'></a>两者分别在何时使用</h3><p>如果方法的接收者是值类型，无论调用者是对象还是对象指针，修改的都是对象的副本，不影响调用 者；如果方法的接收者是指针类型，则调用者修改的是指针指向的对象本身。 使用指针作为方法的接收者的理由： 方法能够修改接收者指向的值。 避免在每次调用方法时复制该值，在值的类型为大型结构体时，这样做会更加高效。 <strong>是使用值接收者还是指针接收者，不是由该方法是否修改了调用者（也就是接收者）来决定，而是应该基于该类型的本质</strong> 。</p><p>如果类型具备“原始的本质”，也就是说<strong>它的成员都是由 Go 语言里内置的原始类型，如字符串，整型值等，那就定义值接收者类型的方法</strong> 。像<strong>内置的引用类型，如 slice，map，interface， channel，这些类型比较特殊，声明他们的时候，实际上是创建了一个header ， 对于他们也是直接定义值接收者类型的方法</strong>。这样，<strong>调用函数时，是直接copy了这些类型的 header</strong> ，而 header本身就是为复制设计的。 </p><p>如果类型具备非原始的本质，<strong>不能被安全地复制</strong>，这种类型总是应该被共享，那就定义指针接收者的方 法。比如 go源码里的文件结构体（struct File）就不应该被复制，应该只有一份 实体 。</p><h2 id="5-有关nil和interface"><a href="#5-有关nil和interface" class="headerlink" title="5. 有关nil和interface"></a>5. <a name='nilinterface'></a>有关nil和interface</h2><p>从<code>interface</code>源码可以看到，<code>iface</code>包含两个字段：</p><ul><li><code>itab</code>是接口表指针，指向类型信息，<strong>被称为动态类型</strong></li><li><code>data</code>是数据指针，指向具体的数据，<strong>被称为动态值</strong></li></ul><p><strong>而接口的零值是指动态类型和动态值都为nil，当且仅当这两部分的值都为nil的情况下，这个接口才会被认为是nil的</strong> 。下面从一个例子来更深入了解这个特性：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Animal <span class="keyword">interface</span> &#123;</span><br><span class="line">Walk()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Dog <span class="keyword">struct</span> &#123;</span><br><span class="line">name <span class="type">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(d *Dog)</span></span> Walk() &#123;</span><br><span class="line">fmt.Println(<span class="string">&quot;a dog is walking&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">InterfaceNil</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> animal Animal</span><br><span class="line">fmt.Println(animal == <span class="literal">nil</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %v\n&quot;</span>, animal, animal)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog *Dog</span><br><span class="line">fmt.Println(dog == <span class="literal">nil</span>)</span><br><span class="line"></span><br><span class="line">animal = dog</span><br><span class="line">fmt.Println(animal == <span class="literal">nil</span>)</span><br><span class="line">fmt.Printf(<span class="string">&quot;%T %v\n&quot;</span>, animal, animal)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">InterfaceNil()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PS D:\Github\repo\Go-Backend\src\g_interface&gt; go run main.go</span><br><span class="line">true</span><br><span class="line">&lt;nil&gt; &lt;nil&gt;</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">*main.Dog &lt;nil&gt;</span><br></pre></td></tr></table></figure><ul><li>一开始，<code>animal</code>的动态类型和静态类型都为<code>nil</code>，同时<code>dog</code>也为<code>nil</code></li><li>当<code>animal</code>被赋值为<code>dog</code>的时候，<code>animal</code>的动态类型变成了<code>*Dog</code>，尽管此时动态值仍然为<code>nil</code>，但是动态类型不为<code>nil</code>，结果就不为<code>nil</code></li></ul><p><strong>因此，一个包含nil指针的接口不是nil接口</strong></p><h2 id="6-interface的创建过程-太难了，慢慢写"><a href="#6-interface的创建过程-太难了，慢慢写" class="headerlink" title="6. interface的创建过程(太难了，慢慢写)"></a>6. <a name='interface-1'></a>interface的创建过程(太难了，慢慢写)</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;探究Go语言中的interface&quot;&gt;&lt;a href=&quot;#探究Go语言中的interface&quot; class=&quot;headerlink&quot; title=&quot;探究Go语言中的interface&quot;&gt;&lt;/a&gt;探究Go语言中的interface&lt;/h1&gt;&lt;!-- vscode-m</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>如何优雅地关闭channel</title>
    <link href="https://timmy6.github.io/2021/07/15/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%85%B3%E9%97%ADchannel/"/>
    <id>https://timmy6.github.io/2021/07/15/%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E5%85%B3%E9%97%ADchannel/</id>
    <published>2021-07-15T14:15:10.000Z</published>
    <updated>2022-05-23T01:54:31.885Z</updated>
    
    <content type="html"><![CDATA[<!-- vscode-markdown-toc --><ul><li><ol><li><a href="#channel">关闭channel的难点</a></li></ol></li><li><ol start="2"><li><a href="#channel-1">关闭channel的原则</a></li></ol></li><li><ol start="3"><li><a href="#">不优雅的关闭方法</a></li></ol><ul><li>3.1. <a href="#defer-recover">defer-recover兜底</a></li><li>3.2. <a href="#sync.Once">使用sync.Once保证只关闭一次</a></li></ul></li><li><ol start="4"><li><a href="#-1">优雅的关闭方法</a></li></ol><ul><li>4.1. <a href="#senderreceiver">一个sender，一个receiver</a></li><li>4.2. <a href="#senderMreceiver">一个sender，M个receiver</a></li><li>4.3. <a href="#Nsenderreceiver">N个sender，一个receiver</a></li><li>4.4. <a href="#NsenderMreceiver">N个sender，M个receiver</a></li></ul></li></ul><!-- vscode-markdown-toc-config    numbering=true    autoSave=true    /vscode-markdown-toc-config --><!-- /vscode-markdown-toc --><h2 id="1-关闭channel的难点"><a href="#1-关闭channel的难点" class="headerlink" title="1. 关闭channel的难点"></a>1. <a name='channel'></a>关闭channel的难点</h2><ul><li>在不改变channel自身状态下，无法获知一个channel是否关闭</li><li>关闭一个closed channel会导致panic。所以，如果关闭channel的一方在不知道channel是否关闭的情况下就去贸然关闭channel是很危险的事情</li><li>向一个closed channel发送数据会导致panic。所以，如果向channel发送数据的一方不知道channel被关闭就去发送数据很危险</li></ul><h2 id="2-关闭channel的原则"><a href="#2-关闭channel的原则" class="headerlink" title="2. 关闭channel的原则"></a>2. <a name='channel-1'></a>关闭channel的原则</h2><p><strong>不要从一个 receiver 侧关闭 channel，也不要在有多个 sender 时，关闭 channel。</strong></p><h2 id="3-不优雅的关闭方法"><a href="#3-不优雅的关闭方法" class="headerlink" title="3. 不优雅的关闭方法"></a>3. <a name=''></a>不优雅的关闭方法</h2><h3 id="3-1-defer-recover兜底"><a href="#3-1-defer-recover兜底" class="headerlink" title="3.1. defer-recover兜底"></a>3.1. <a name='defer-recover'></a>defer-recover兜底</h3><p>使用defer-recover机制，放心大胆关闭channel或者向channel发送数据。即使发生了panic，有defer-recover机制兜底</p><h3 id="3-2-使用sync-Once保证只关闭一次"><a href="#3-2-使用sync-Once保证只关闭一次" class="headerlink" title="3.2. 使用sync.Once保证只关闭一次"></a>3.2. <a name='sync.Once'></a>使用sync.Once保证只关闭一次</h3><p>利用sync.Once特性保证只关闭channel一次。<strong>这种方法保证了channel只被关闭一次，但是无法保证被关闭后没有sender发送数据</strong></p><h2 id="4-优雅的关闭方法"><a href="#4-优雅的关闭方法" class="headerlink" title="4. 优雅的关闭方法"></a>4. <a name='-1'></a>优雅的关闭方法</h2><p><strong>增加一个关闭信号的channel，receiver通过信号channel下达关闭数据channel指令，sender接收到关闭信号之后，停止接收数据。</strong></p><h3 id="4-1-一个sender，一个receiver"><a href="#4-1-一个sender，一个receiver" class="headerlink" title="4.1. 一个sender，一个receiver"></a>4.1. <a name='senderreceiver'></a>一个sender，一个receiver</h3><p>直接从sender端关闭即可</p><h3 id="4-2-一个sender，M个receiver"><a href="#4-2-一个sender，M个receiver" class="headerlink" title="4.2. 一个sender，M个receiver"></a>4.2. <a name='senderMreceiver'></a>一个sender，M个receiver</h3><p>直接从sender端关闭即可</p><h3 id="4-3-N个sender，一个receiver"><a href="#4-3-N个sender，一个receiver" class="headerlink" title="4.3. N个sender，一个receiver"></a>4.3. <a name='Nsenderreceiver'></a>N个sender，一个receiver</h3><p>在这种情况下，优雅地关闭channel的方法就是receiver负责通知sender不要再发送数据了，然后关闭它。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    datach := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="type">int</span>, <span class="number">100</span>)</span><br><span class="line">    stopch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// senders</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">        <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">            <span class="keyword">for</span> &#123;</span><br><span class="line">                <span class="keyword">select</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> &lt;-stopch:</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">                <span class="keyword">case</span> datach &lt;-rand.Intn(<span class="number">100</span>):</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// receiver</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">for</span> val := <span class="keyword">range</span> datach &#123;</span><br><span class="line">            <span class="keyword">if</span> val == <span class="number">100</span> &#123;</span><br><span class="line">                fmt.Println(<span class="string">&quot;please stop the sender&quot;</span>)</span><br><span class="line">                <span class="comment">// 关闭stopch，让gc代劳</span></span><br><span class="line">                <span class="built_in">close</span>(stopch)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            fmt.Println(val)</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;()</span><br><span class="line">    </span><br><span class="line">    &lt;-time.After(time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-N个sender，M个receiver"><a href="#4-4-N个sender，M个receiver" class="headerlink" title="4.4. N个sender，M个receiver"></a>4.4. <a name='NsenderMreceiver'></a>N个sender，M个receiver</h3><p>这里有 M 个 receiver，如果直接还是采取第 3 种解决方案，由 receiver 直接关闭 stopCh 的话，就会重复关闭一个 channel，导致 panic。因此需要增加一个中间人，M 个 receiver 都向它发送关闭 dataCh 的“请求”，中间人收到第一个请求后，就会直接下达关闭dataCh 的指令（通过关闭 stopCh，这时就不会发生重复关闭的情况，因为 stopCh 的发送方只有 中间人一个）。另外，这里的 N 个 sender 也</p>]]></content>
    
    
      
      
    <summary type="html">&lt;!-- vscode-markdown-toc --&gt;
&lt;ul&gt;
&lt;li&gt;&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#channel&quot;&gt;关闭channel的难点&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;a href=&quot;#channel</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>缓存穿透、缓存击穿、缓存血崩的区别以及解决方案</title>
    <link href="https://timmy6.github.io/2021/06/25/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E8%A1%80%E5%B4%A9%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>https://timmy6.github.io/2021/06/25/%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F%E3%80%81%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF%E3%80%81%E7%BC%93%E5%AD%98%E8%A1%80%E5%B4%A9%E7%9A%84%E5%8C%BA%E5%88%AB%E4%BB%A5%E5%8F%8A%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</id>
    <published>2021-06-25T15:15:10.000Z</published>
    <updated>2022-05-18T09:33:42.657Z</updated>
    
    <content type="html"><![CDATA[<p>平时我们使用缓存的方案，一般是在数据库中存储一份，在缓存中同步存储一份。当请求过来的视乎，可以先从缓存中取数据，如果有数据，直接返回缓存中的结果。如果缓存中没有数据，那么去数据库中取出数据，同时更新到缓存中，返回结果。如果数据库中也没有数据，可以直接返回空。</p><p>关于缓存，一般会有以下几个常见的问题</p><h2 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h2><p>缓存穿透是指，<strong>缓存和数据库都没有的数据</strong>，被大量请求，比如订单号不可能为<code>-1</code>，但是用户请求了大量订单号为<code>-1</code>的数据，由于数据不存在，缓存就也不会存在该数据，所有的请求都会直接穿透到数据库。<br>如果被恶意用户利用，疯狂请求不存在的数据，就会导致数据库压力过大，甚至垮掉。</p><p>注意：穿透的意思是，都没有，直接一路打到数据库。</p><p><strong>那对于这种情况，我们该如何解决呢？</strong></p><ol><li>接口增加业务层级的<code>Filter</code>，进行合法校验，这可以有效拦截大部分不合法的请求。</li><li>作为第一点的补充，最常见的是使用布隆过滤器，针对一个或者多个维度，把可能存在的数据值hash到bitmap中，bitmap证明该数据不存在则该数据一定不存在，但是bitmap证明该数据存在也只能是可能存在，因为不同的数值hash到的bit位很有可能是一样的，hash冲突会导致误判，多个hash方法也只能是降低冲突的概率，无法做到避免。</li><li>另外一个常见的方法，则是针对数据库与缓存都没有的数据，对空的结果进行缓存，但是过期时间设置得较短，一般五分钟内。而这种数据，如果数据库有写入，或者更新，必须同时刷新缓存，否则会导致不一致的问题存在。</li></ol><h2 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h2><p>缓存击穿是指数据库原本有得数据，但是缓存中没有，一般是缓存突然失效了，这时候如果有大量用户请求该数据，缓存没有则会去数据库请求，会引发数据库压力增大，可能会瞬间打垮。</p><p>针对这类问题，一般有以下做法：</p><ol><li>如果是热点数据，那么可以考虑设置永远不过期。</li><li>如果数据一定会过期，那么就需要在数据为空的时候，设置一个互斥的锁，只让一个请求通过，只有一个请求去数据库拉取数据，取完数据，不管如何都需要释放锁，异常的时候也需要释放锁，要不其他线程会一直拿不到锁。</li></ol><p>下面是缓存击穿的时候互斥锁的写法，注意：获取锁之后操作，不管成功或者失败，都应该释放锁，而其他的请求，如果没有获取到锁，应该等待，再重试。当然，如果是需要更加全面一点，应该加上一个等待次数，比如1s中，那么也就是睡眠五次，达到这个阈值，则直接返回空，不应该过度消耗机器，以免当个不可用的场景把整个应用的服务器带挂了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getProductDescById</span><span class="params">(String id)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">desc</span> <span class="operator">=</span> redis.get(id);</span><br><span class="line">    <span class="comment">// 缓存为空，过期了</span></span><br><span class="line">    <span class="keyword">if</span> (desc == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 互斥锁，只有一个请求可以成功</span></span><br><span class="line">        <span class="keyword">if</span> (redis.setnx(lock_id, <span class="number">1</span>, <span class="number">60</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 从数据库取出数据</span></span><br><span class="line">                desc = getFromDB(id);</span><br><span class="line">                redis.set(id, desc, <span class="number">60</span> * <span class="number">60</span> * <span class="number">24</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                LogHelper.error(ex);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="comment">// 确保最后删除，释放锁</span></span><br><span class="line">                redis.del(lock_id);</span><br><span class="line">                <span class="keyword">return</span> desc;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 否则睡眠200ms，接着获取锁</span></span><br><span class="line">            Thread.sleep(<span class="number">200</span>);</span><br><span class="line">            <span class="keyword">return</span> getProductDescById(id);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h2><p>缓存雪崩是指缓存中有大量的数据，在同一个时间点，或者较短的时间段内，全部过期了，这个时候请求过来，缓存没有数据，都会请求数据库，则数据库的压力就会突增，扛不住就会宕机。</p><p>针对这种情况，一般我们都是使用以下方案：</p><ol><li>如果是热点数据，那么可以考虑设置永远不过期。</li><li>缓存的过期时间除非比较严格，要不考虑设置一个波动随机值，比如理论十分钟，那这类key的缓存时间都加上一个1<del>3分钟，过期时间在7</del>13分钟内波动，有效防止都在同一个时间点上大量过期。</li><li>方法1避免了有效过期的情况，但是要是所有的热点数据在一台redis服务器上，也是极其危险的，如果网络有问题，或者redis服务器挂了，那么所有的热点数据也会雪崩（查询不到），因此将热点数据打散分不到不同的机房中，也可以有效减少这种情况。</li><li>也可以考虑双缓存的方式，数据库数据同步到缓存A和B，A设置过期时间，B不设置过期时间，如果A为空的时候去读B，同时异步去更新缓存，但是更新的时候需要同时更新两个缓存。</li></ol><p>比如设置产品的缓存时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis.set(id,value,<span class="number">60</span>*<span class="number">60</span> + Math.random()*<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>缓存穿透是指数据库原本就没有的数据，请求如入无人之境，直奔数据库，而缓存击穿，则是指数据库有数据，缓存也本应该有数据，但是突然缓存过期了，这层保护屏障被击穿了，请求直奔数据库，缓存雪崩则是指很多缓存同一个时间失效了，流量全部涌入数据库，造成数据库极大的压力。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;平时我们使用缓存的方案，一般是在数据库中存储一份，在缓存中同步存储一份。当请求过来的视乎，可以先从缓存中取数据，如果有数据，直接返回缓存中的结果。如果缓存中没有数据，那么去数据库中取出数据，同时更新到缓存中，返回结果。如果数据库中也没有数据，可以直接返回空。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="MySql" scheme="https://timmy6.github.io/categories/MySql/"/>
    
    
    <category term="数据库优化" scheme="https://timmy6.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>timer复用问题</title>
    <link href="https://timmy6.github.io/2021/03/02/timer%E5%A4%8D%E7%94%A8%E9%97%AE%E9%A2%98/"/>
    <id>https://timmy6.github.io/2021/03/02/timer%E5%A4%8D%E7%94%A8%E9%97%AE%E9%A2%98/</id>
    <published>2021-03-02T15:22:10.000Z</published>
    <updated>2022-05-23T02:21:29.063Z</updated>
    
    <content type="html"><![CDATA[<h1 id="重用timer"><a href="#重用timer" class="headerlink" title="重用timer"></a>重用timer</h1><blockquote><p>重用的timer的目的在于减少减少创建timer实例</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://studygolang.com/articles/9289">https://studygolang.com/articles/9289</a></li></ul><h2 id="重置条件"><a href="#重置条件" class="headerlink" title="重置条件"></a>重置条件</h2><ul><li>第一步是要确定timer是否已过期,用<code>timer.Stop</code>确定,<code>true</code>表示timer未过期,<code>false</code>表示timer已过期</li><li>timer已过期,选择性抽干channel,然后调用<code>time.Reset</code></li><li>timer未过期,<code>timer.Stop</code>返回<code>true</code>,此时不必关系channel会被删除,可以直接调用<code>time.Reset</code></li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">       timer := time.NewTimer(time.Second * <span class="number">5</span>)</span><br><span class="line">       <span class="keyword">for</span> &#123;</span><br><span class="line">           <span class="comment">// 不管有没有过期,我们都尝试stop timer,成功表示timer未过期,失败表示timer已过期</span></span><br><span class="line">           <span class="keyword">if</span> !timer.Stop() &#123;</span><br><span class="line">               <span class="keyword">select</span> &#123;</span><br><span class="line">               <span class="keyword">case</span> &lt;-timer.C: <span class="comment">// 尝试抽干channel,因为不知道channel过期之前是否已经被抽干了,但是这不是完美的,会有竞争条件</span></span><br><span class="line">               <span class="keyword">default</span>:</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           timer.Reset(time.Second * <span class="number">5</span>)</span><br><span class="line">           <span class="keyword">select</span> &#123;</span><br><span class="line">           <span class="keyword">case</span> b := &lt;-c:</span><br><span class="line">               <span class="keyword">if</span> b == <span class="literal">false</span> &#123;</span><br><span class="line">                   fmt.Println(time.Now(), <span class="string">&quot;:recv false. continue&quot;</span>)</span><br><span class="line">                   <span class="keyword">continue</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//we want true, not false</span></span><br><span class="line">               fmt.Println(time.Now(), <span class="string">&quot;:recv true. return&quot;</span>)</span><br><span class="line">               <span class="keyword">return</span></span><br><span class="line">           <span class="keyword">case</span> &lt;-timer.C:</span><br><span class="line">               fmt.Println(time.Now(), <span class="string">&quot;:timer expired&quot;</span>)</span><br><span class="line">               <span class="keyword">continue</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;()</span><br></pre></td></tr></table></figure><p>说明:</p><ul><li><code>timer</code>过期,之后从最小堆移除,此时调用<code>timer.Stop</code>会失败,失败之后需要显示抽干channel</li><li><code>timer</code>未过期,调用<code>timer.Stop</code>成功(此时channel抽干),可以直接调用<code>timer.Reset</code></li><li><code>timer</code>未过期,若调用<code>timer.Stop</code>失败,此时channel有可能之前被抽干,也有可能未被抽干,这个时候需要用<code>select&#123;&#125;</code>选择性抽干</li></ul><h2 id="time-timer和time-ticker的区别"><a href="#time-timer和time-ticker的区别" class="headerlink" title="time.timer和time.ticker的区别"></a>time.timer和time.ticker的区别</h2><ul><li><code>time.timer</code> 一次性,到期后会从最小堆移除,可以用<code>time.Reset</code>实现持续运行效果</li><li><code>time.ticker</code> 持续性,到期后执行下个周期</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;重用timer&quot;&gt;&lt;a href=&quot;#重用timer&quot; class=&quot;headerlink&quot; title=&quot;重用timer&quot;&gt;&lt;/a&gt;重用timer&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;重用的timer的目的在于减少减少创建timer实例&lt;/p&gt;
&lt;/bloc</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>sync.WaitGroup实现协程同步</title>
    <link href="https://timmy6.github.io/2021/02/20/sync-WaitGroup%E5%AE%9E%E7%8E%B0%E5%8D%8F%E7%A8%8B%E5%90%8C%E6%AD%A5/"/>
    <id>https://timmy6.github.io/2021/02/20/sync-WaitGroup%E5%AE%9E%E7%8E%B0%E5%8D%8F%E7%A8%8B%E5%90%8C%E6%AD%A5/</id>
    <published>2021-02-20T14:11:10.000Z</published>
    <updated>2022-05-18T09:11:50.369Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/u011304970/article/details/72722044">https://blog.csdn.net/u011304970/article/details/72722044</a></li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Goroutine 1&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Goroutine 2&quot;</span>)</span><br><span class="line">    &#125;()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行以上代码很可能看不到输出，因为有可能这两个协程还没得到执行主协程已经结束了，而主协程结束时会结束所有其他协程。</p><h2 id="管道同步方法"><a href="#管道同步方法" class="headerlink" title="管道同步方法"></a>管道同步方法</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;)</span><br><span class="line">    count := <span class="number">2</span> <span class="comment">// count 表示活动的协程个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Goroutine 1&quot;</span>)</span><br><span class="line">        ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 协程结束，发出信号</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Goroutine 2&quot;</span>)</span><br><span class="line">        ch &lt;- <span class="keyword">struct</span>&#123;&#125;&#123;&#125; <span class="comment">// 协程结束，发出信号</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> <span class="keyword">range</span> ch &#123;</span><br><span class="line">        <span class="comment">// 每次从ch中接收数据，表明一个活动的协程结束</span></span><br><span class="line">        count--</span><br><span class="line">        <span class="comment">// 当所有活动的协程都结束时，关闭管道</span></span><br><span class="line">        <span class="keyword">if</span> count == <span class="number">0</span> &#123;</span><br><span class="line">            <span class="built_in">close</span>(ch)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sync-WaitGroup"><a href="#sync-WaitGroup" class="headerlink" title="sync.WaitGroup"></a>sync.WaitGroup</h2><p>WaitGroup顾名思义，就是用来等待一组操作完成的。WaitGroup内部实现了一个计数器，用来记录未完成的操作个数，它提供了三个方法，Add()用来添加计数。Done()用来在操作结束时调用，使计数减一。Wait()用来等待所有的操作结束，即计数变为0，该函数会在计数不为0时等待，在计数为0时立即返回。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">    wg.Add(<span class="number">2</span>) <span class="comment">// 因为有两个动作，所以增加2个计数</span></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Goroutine 1&quot;</span>)</span><br><span class="line">        wg.Done() <span class="comment">// 操作完成，减少一个计数</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        fmt.Println(<span class="string">&quot;Goroutine 2&quot;</span>)</span><br><span class="line">        wg.Done() <span class="comment">// 操作完成，减少一个计数</span></span><br><span class="line">    &#125;()</span><br><span class="line"></span><br><span class="line">    wg.Wait() <span class="comment">// 等待，直到计数为0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单总结"><a href="#简单总结" class="headerlink" title="简单总结"></a>简单总结</h2><ul><li>定义<code>var wg sync.WaitGroup</code></li><li>增加一个<code>goroutine</code>就执行一下<code>wg.Add(1)</code>,必须在之前</li><li>执行完一个<code>goroutine</code>就执行下<code>wg.Done()</code>,计数减一</li><li>程序最后用<code>wg.Wait()</code>等待所有<code>goroutine</code>退出</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/u011304970/article/details/727220</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>索引原理分析</title>
    <link href="https://timmy6.github.io/2021/01/15/%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>https://timmy6.github.io/2021/01/15/%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2021-01-15T14:11:10.000Z</published>
    <updated>2022-05-18T07:58:52.280Z</updated>
    
    <content type="html"><![CDATA[<p>索引的本质是便于快速查找的数据结构，MySQL 数据库索引一般采用 B+Tree 作为索引的实现。</p><h3 id="一、磁盘-IO-与预读"><a href="#一、磁盘-IO-与预读" class="headerlink" title="一、磁盘 IO 与预读"></a>一、磁盘 IO 与预读</h3><p>上面也讲了索引的目的是为了快速查找，MySQL 的数据存储在磁盘上，快速查找意味着降低磁盘的 I&#x2F;O 次数。</p><p>磁盘 IO 是非常高昂的操作，计算机操作系统做了一些优化，当一次 IO 时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，因为局部预读性原理告诉我们，当计算机访问一个地址的数据的时候，与其相邻的数据也会很快被访问到。每一次 IO 读取的数据我们称之为一页 (page)。具体一页有多大数据跟操作系统有关，一般为 4k 或 8k，也就是我们读取一页内的数据时候，实际上才发生了一次 IO。</p><p>磁盘读取数据靠的是机械运动，每次读取数据花费的时间可以分为寻道时间、旋转延迟、传输时间三个部分，寻道时间指的是磁臂移动到指定磁道所需要的时间，主流磁盘一般在 5ms 以下；旋转延迟就是我们经常听说的磁盘转速，比如一个磁盘 7200 转，表示每分钟能转 7200 次，也就是说 1 秒钟能转 120 次，旋转延迟就是 1&#x2F;120&#x2F;2 &#x3D; 4.17ms；传输时间指的是从磁盘读出或将数据写入磁盘的时间，一般在零点几毫秒，相对于前两个时间可以忽略不计。那么访问一次磁盘的时间，即一次磁盘 IO 的时间约等于 5+4.17 &#x3D; 9ms 左右，听起来还挺不错的，但要知道一台 500 -MIPS 的机器每秒可以执行 5 亿条指令，因为指令依靠的是电的性质，换句话说执行一次 IO 的时间可以执行 40 万条指令，数据库动辄十万百万乃至千万级数据，每次 9 毫秒的时间，显然是个灾难。</p><h3 id="二、B-Tree"><a href="#二、B-Tree" class="headerlink" title="二、B+Tree"></a>二、B+Tree</h3><p><img src="/images/other/mysql_index.jpeg"></p><p><strong>2.1 B+Tree 概述</strong></p><p>浅蓝色的块我们称之为一个磁盘块，可以看到每个磁盘块包含几个数据项（深蓝色所示）和指针（黄色所示），如磁盘块 1 包含数据项 17 和 35，包含指针 P1、P2、P3，P1 表示小于 17 的磁盘块，P2 表示在 17 和 35 之间的磁盘块，P3 表示大于 35 的磁盘块。真实的数据存在于叶子节点即 3、5、9、10、13、15、28、29、36、60、75、79、90、99。非叶子节点只不存储真实的数据，只存储指引搜索方向的数据项，如 17、35 并不真实存在于数据表中。</p><p><strong>2.2 B+Tree 查找过程</strong></p><p>如果要查找数据项 29，那么首先会把磁盘块 1 由磁盘加载到内存，此时发生一次 IO，在内存中用二分查找确定 29 在 17 和 35 之间，锁定磁盘块 1 的 P2 指针，内存时间因为非常短（相比磁盘的 IO）可以忽略不计，通过磁盘块 1 的 P2 指针的磁盘地址把磁盘块 3 由磁盘加载到内存，发生第二次 IO，29 在 26 和 30 之间，锁定磁盘块 3 的 P2 指针，通过指针加载磁盘块 8 到内存，发生第三次 IO，同时内存中做二分查找找到 29，结束查询，总计三次 IO。真实的情况是，3 层的 b+树可以表示上百万的数据，如果上百万的数据查找只需要三次 IO，性能提高将是巨大的，如果没有索引，每个数据项都要发生一次 IO，那么总共需要百万次的 IO，显然成本非常非常高。</p><p><strong>2.3 B+Tree 性质</strong></p><ul><li>IO 次数取决于 b+ 树的高度 h，假设当前数据表的数据为 N，每个磁盘块的数据项的数量是 m，则有 h&#x3D;㏒(m+1)N，当数据量 N 一定的情况下，m 越大，h 越小；而 m &#x3D; 磁盘块的大小 &#x2F; 数据项的大小，磁盘块的大小也就是一个数据页的大小，是固定的，如果数据项占的空间越小，数据项的数量越多，树的高度越低。这就是为什么每个数据项，即索引字段要尽量的小，比如 int 占 4 字节，要比 bigint8 字节少一半。这也是为什么 b+ 树要求把真实的数据放到叶子节点而不是内层节点，一旦放到内层节点，磁盘块的数据项会大幅度下降，导致树增高。当数据项等于 1 时将会退化成线性表。</li><li>当 b+ 树的数据项是复合的数据结构，比如 (name,age,sex) 的时候，b+ 数是按照从左到右的顺序来建立搜索树的，比如当 (张三,20,F) 这样的数据来检索的时候，b+树会优先比较 name 来确定下一步的所搜方向，如果 name 相同再依次比较 age 和 sex，最后得到检索的数据；但当 (20,F) 这样的没有 name 的数据来的时候，b+ 树就不知道下一步该查哪个节点，因为建立搜索树的时候 name 就是第一个比较因子，必须要先根据 name 来搜索才能知道下一步去哪里查询。比如当 (张三,F) 这样的数据来检索时，b+ 树可以用 name 来指定搜索方向，但下一个字段 age 的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是 F 的数据了， 这个是非常重要的性质，即索引的最左匹配特性。</li></ul><p><strong>2.4 B+Tree 与 B-Tree 的区别</strong></p><p>B+ 树只有叶节点存放数据，其余节点用来索引，而 B- 树是每个索引节点都会有 Data 域。为什么 MySQL 索引使用 B+Tree 而不使用 B-Tree 呢？其实在上面已经讲过了，B-Tree 因为节点存放数据会导致磁盘快的数据项变少，导致树的高度变高，查找时会增加 I&#x2F;O 的次数。</p><h3 id="三、索引优化"><a href="#三、索引优化" class="headerlink" title="三、索引优化"></a>三、索引优化</h3><p><strong>3.1 优化策略</strong></p><ul><li>最佳左前缀原则：当我们创建了的索引包括多列，查询的顺序应该是从索引的最前端开始，并且不要跳过索引中的其他列（跳过只会使用索引的一部分），如果最左端的字段不包括，索引直接失效</li><li>不要在索引列上做计算，函数等操作</li><li>不要在索引上做范围操作</li><li>在查询时尽量覆盖索引列，少使用 <code>SELECT *</code></li><li>不要在索引上使用 !&#x3D; 、 &lt;&gt; 、 IS NULL 、 IS NOT NULL</li><li>少使用 OR…</li></ul><p><strong>3.2 SQL 语句分析</strong></p><p>如何判定一个 SQL 使用了索引，并评判它的性能，关于这点我们可以使用 <code>EXPLAIN</code> 关键字进行分析。以下是几个关于索引的重要字段：</p><ul><li>rows：根据表统计信息及选取索引的情况，大致估算出查到记录所需要读取的行数，所以优化语句基本上都是在优化rows</li><li>type：表示查询语句的连接类型，该字段有很多值，最好到最差的顺序是：system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; all ，但是对于一般来说，能够保证达到 range 级别就可以了，最好达到 ref 级别</li><li>key：实际上使用的索引，可以为 null 表示没有使用索引</li></ul><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1] <a href="https://tech.meituan.com/2014/06/30/mysql-index.html">MySQL索引原理及慢查询优化</a> by 美团技术团队 NeverMore <br><br>[2] <a href="http://blog.codinglabs.org/articles/theory-of-mysql-index.html">MySQL索引背后的数据结构及算法原理</a> by 张洋 <br></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;索引的本质是便于快速查找的数据结构，MySQL 数据库索引一般采用 B+Tree 作为索引的实现。&lt;/p&gt;
&lt;h3 id=&quot;一、磁盘-IO-与预读&quot;&gt;&lt;a href=&quot;#一、磁盘-IO-与预读&quot; class=&quot;headerlink&quot; title=&quot;一、磁盘 IO 与预读&quot;&gt;</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>短链接生成原理</title>
    <link href="https://timmy6.github.io/2020/11/15/%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%94%9F%E6%88%90%E5%8E%9F%E7%90%86/"/>
    <id>https://timmy6.github.io/2020/11/15/%E7%9F%AD%E8%BF%9E%E6%8E%A5%E7%94%9F%E6%88%90%E5%8E%9F%E7%90%86/</id>
    <published>2020-11-15T13:11:10.000Z</published>
    <updated>2022-05-18T07:57:33.460Z</updated>
    
    <content type="html"><![CDATA[<p>看业务代码的时候，有些逻辑用到了短链接服务，感觉还蛮有意思的，这里简单的记录一下。</p><p><img src="/images/other/8.message_short_url.png"></p><p>这种营销短信大家应该都收到过，短信有最大字符限制，而且为了更好的观感体验，短信里的链接一般都很短。现成的短链接生成服务也比较多，比如<a href="https://www.sina.lt/">新浪</a>、<a href="https://dwz.cn/console/operation">百度</a>等，谷歌之前也有短链接服务，号称是最快的，但是在 2018 年关闭了。</p><h3 id="一、短链接原理"><a href="#一、短链接原理" class="headerlink" title="一、短链接原理"></a>一、短链接原理</h3><p><img src="/images/other/9.short_url_process.png"></p><p>我们点击短链接会发起一个 GET 方式的 HTTP 请求，当请求到对应的 API 后，会解析短链接里的标识获取到对应的长链接，然后重定向到长链接，这样整个流程就结束了。</p><p>比如我用新浪的短链接服务为 <a href="https://www.google.com/">https://www.google.com/</a> 生成了一个短链接：<a href="http://dwz.date/evn">http://dwz.date/evn</a>，下面是我请求短链接时对应的 HTTP 信息：</p><p><img src="/images/other/7.short_url_http.png"></p><h3 id="二、短链接生成算法"><a href="#二、短链接生成算法" class="headerlink" title="二、短链接生成算法"></a>二、短链接生成算法</h3><p>短链接标识一般是 [0-9, a-z, A-Z] 随机组合而成的字符串，字符一共有 62 个，因此短链接标识可以用 62 进制的字符串表示。</p><p>首先维护一个自增的 ID，当生成短链接时，将 10 进制的自增 ID 转换成 62 进制字符串，这个字符串就可以唯一标识一个长链接。由于 ID 是自增的，对应的 62 进制字符串是不同的，这样就不会出现一个短链接对应多个长链接的问题，62 个字符排列组合，可以保证短链接是用不完的，就算仅限于 6 位长度标识的短链接，也有 558 亿多种情况，这种算法在网上被称为自增序列算法。</p><p>维护自增 ID 主要有以下几种方式：</p><ol><li>数据库主键自增</li><li>redis 自增</li><li>分布式自增主键 ID（雪花算法，存在 ID 浪费）</li></ol><p>下面是 62 进制的 encode 与 decode 方法，来自 <a href="https://github.com/dukky/Base62/blob/master/base62/src/im/duk/base62/Base62.java">Base62</a>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">base62</span><span class="params">(Long b10)</span> &#123;</span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">    <span class="keyword">while</span> (b10 &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        ret.insert(<span class="number">0</span>, characters.charAt((<span class="type">int</span>) (b10 % <span class="number">62</span>)));</span><br><span class="line">        b10 /= <span class="number">62</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret.toString();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">decodeBase62</span><span class="params">(String b62)</span> &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    b62 = <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(b62).reverse().toString();</span><br><span class="line">    <span class="type">long</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> character : b62.toCharArray()) &#123;</span><br><span class="line">        ret += characters.indexOf(character) * count;</span><br><span class="line">        count *= <span class="number">62</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三、一些细节"><a href="#三、一些细节" class="headerlink" title="三、一些细节"></a>三、一些细节</h3><p>自增序列算法也存在一定的缺点，当自增主键很大时，生成的 62 进制字符串会变长，以 <code>0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</code> 顺序的 62 进制为例，当主键大于 56800235583 时，会生成 7 位长度的 62 进制字符串。可以通过控制自增主键的增长速度来解决这个问题，避免主键浪费。</p><p>62 进制的顺序并不一定严格按照 <code>0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ</code> 的顺序来表示，这个顺序可以是打乱的，这样生成的短链接标识更随机不易被破解。</p><p>长链接与短链接是否需要一对多关系，同一个长链接使用自增主键 ID 算法生成的短链接是不同的，因为自增主键 ID 不同，生成的 62 进制字符串自然也不同。如果我们有一个长链接唯一对应一个短链接需求，可以将长链接进行 md5 加密，将加密后的 md5 值存储在 DB 中，每次生成短链接前都根据长链接 md5 值查询 DB，如果存在，则直接返回短链接，当然也可以使用其他方式维护这种关系。</p><p>跳转用 301 还是 302，301 永久重定向，302 是临时重定向。短地址一经生成就不会变化，所以用 301 是符合 http 语义的。同时对服务器压力也会有一定减少。<br>但是如果使用了 301，我们就无法统计到短地址被点击的次数了。而这个点击次数是一个非常有意思的大数据分析数据源。能够分析出的东西非常非常多。所以选择 302 虽然会增加服务器压力，但是我想是一个更好的选择。from <a href="https://www.zhihu.com/question/29270034/answer/46446911">短 URL 系统是怎么设计的？</a> by iammutex</p><p>如果短链接请求频繁，可以借助 redis 做对应的缓存优化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;看业务代码的时候，有些逻辑用到了短链接服务，感觉还蛮有意思的，这里简单的记录一下。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/other/8.message_short_url.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;这种营销短信大家应该都收到过，短信有最大字符限制，而且为了更好</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>秒杀业务总结</title>
    <link href="https://timmy6.github.io/2020/10/15/%E7%A7%92%E6%9D%80%E4%B8%9A%E5%8A%A1%E6%80%BB%E7%BB%93/"/>
    <id>https://timmy6.github.io/2020/10/15/%E7%A7%92%E6%9D%80%E4%B8%9A%E5%8A%A1%E6%80%BB%E7%BB%93/</id>
    <published>2020-10-15T13:11:10.000Z</published>
    <updated>2022-05-18T07:28:05.796Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一、秒杀商品模型"><a href="#一、秒杀商品模型" class="headerlink" title="一、秒杀商品模型"></a>一、秒杀商品模型</h4><p><img src="/images/other/miaosha.png"></p><h4 id="二、架构设计"><a href="#二、架构设计" class="headerlink" title="二、架构设计"></a>二、架构设计</h4><h4 id="2-1-Redis-MQ"><a href="#2-1-Redis-MQ" class="headerlink" title="2.1 Redis + MQ"></a>2.1 Redis + MQ</h4><p><img src="/images/other/miaosha_redis.png"></p><ul><li>缓存预热：秒杀商品一般时效性比较强，一场秒杀活动持续的时间不会很长，当在后台设置秒杀活动添加秒杀商品时，把商品对应的库存直接存到 Redis，但是要注意的是，设置缓存时一定要设置过期时间。</li><li>削减请求流量：当用户进到秒杀商品详情及后续所有操作都应当进行库存、秒杀资格校验</li><li>扣减 Redis 库存：当用户从秒杀商品详情到账单页请求下单时，加分布式锁防止用户重复提交请求，等后续校验通过后，扣减 Redis 库存，通过 Redis 保证线程安全，也能保证商品不会超卖，但是此时并不扣减 DB 库存</li><li>扣减 DB 库存：用户支付核销监听交易支付成功消息，以乐观锁形式扣减 DB 库存。因为只有抢到库存后才能到后续的支付逻辑，一般到秒杀支付逻辑的流量已经很少了，当并发通过乐观锁扣减 DB 库存失败时，消息会重试，保证 Redis 库存与 DB 库存的一致性</li><li>归还 Redis 库存：用户抢到库存不一定会支付，当用户取消订单或者订单超时未支付时，监听订单取消消息，归还 Redis 库存</li><li>归还 Redis 与 DB 库存：用户下单支付后请求退款，应当归还 Redis 与 DB 的库存，这里可以考虑监听交易消息，也可以通过交易直调接口的形式处理，因为退款场景比较少，一般不会有很大的流量</li></ul><p>这种方式实现起来比较简单，对于流量不是特别大的业务一般够用了，当流量特别大时就需要在上游进行流量控制了，整个过程要考虑是否会出现缓存穿透、缓存雪崩问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一、秒杀商品模型&quot;&gt;&lt;a href=&quot;#一、秒杀商品模型&quot; class=&quot;headerlink&quot; title=&quot;一、秒杀商品模型&quot;&gt;&lt;/a&gt;一、秒杀商品模型&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;/images/other/miaosha.png&quot;&gt;&lt;/p&gt;
&lt;h4 </summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>TCP和UDP的一些优缺点和区别</title>
    <link href="https://timmy6.github.io/2020/09/25/TCP%E5%92%8CUDP%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB/"/>
    <id>https://timmy6.github.io/2020/09/25/TCP%E5%92%8CUDP%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BC%98%E7%BC%BA%E7%82%B9%E5%92%8C%E5%8C%BA%E5%88%AB/</id>
    <published>2020-09-25T14:15:10.000Z</published>
    <updated>2022-05-18T06:45:03.508Z</updated>
    
    <content type="html"><![CDATA[<p><strong>TCP 的优点：</strong> </p><p>可靠，稳定。</p><p>TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。</p><p><strong>TCP 的缺点：</strong> </p><p>慢，效率低，占用系统资源高，易被攻击。</p><p>TCP 在传递数据之前，要先建连接，这会消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接，事实上，每个连接都会占用系统的 CPU、内存等硬件资源。</p><p>而且，因为 TCP 有确认机制、三次握手机制，这些也导致 TCP 容易被人利用，实现 DOS、DDOS、CC 等攻击。</p><p><strong>UDP 的优点：</strong> </p><p>快，比 TCP 稍安全。</p><p>UDP 没有 TCP 的握手、确认、窗口、重传、拥塞控制等机制，UDP 是一个无状态的传输协议，所以它在传递数据时非常快。没有 TCP 的这些机制，UDP 较 TCP 被攻击者利用的漏洞就要少一些。但 UDP 也是无法避免攻击的，比如：UDP Flood 攻击。 </p><p><strong>UDP 的缺点：</strong> </p><p>不可靠，不稳定。</p><p>因为 UDP 没有 TCP 那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。 </p><p>基于上面的优缺点，那么，TCP 和 UDP 的应用场景都有哪些呢？</p><p><strong>TCP 应用场景：</strong></p><p>当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，这往往用于一些要求可靠的应用，比如 HTTP、HTTPS、FTP 等传输文件的协议，POP、SMTP 等邮件传输的协议。</p><p>在日常生活中，常见使用 TCP 协议的应用如下： 浏览器用的 HTTP， FlashFXP 用的 FTP，Outlook 用的 POP、SMTP，Putty 用的 Telnet、SSH，QQ 文件传输。</p><p><strong>UDP 应用场景：</strong> </p><p>当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快，这时就可以使用 UDP。 </p><p>比如，日常生活中，常见使用 UDP 协议的应用如下：QQ 语音，QQ 视频，TFTP 等。有些应用场景对可靠性要求不高会用到 UPD，比如长视频，要求速率。</p><p><strong>TCP 与 UDP 区别总结：</strong></p><p>1、TCP 面向连接（如打电话要先拨号建立连接）; UDP 是无连接的，即发送数据之前不需要建立连接。</p><p>2、TCP 提供可靠的服务。也就是说，通过 TCP 连接传送的数据，无差错，不丢失，不重复，且按序到达；UDP 尽最大努力交付，即不保证可靠交付。</p><p>3、TCP 面向字节流，实际上是 TCP 把数据看成一连串无结构的字节流；UDP 是面向报文的。UDP 没有拥塞控制，因此网络出现拥塞不会使源主机的发送速率降低（对实时应用很有用，如IP电话，实时视频会议等）</p><p>4、每一条 TCP 连接只能是点到点的；UDP支持一对一，一对多，多对一和多对多的交互通信。</p><p>5、TCP 首部开销 20 字节；UDP 的首部开销小，只有 8 个字节。</p><p>6、TCP 的逻辑通信信道是全双工的可靠信道，UDP 则是不可靠信道。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;TCP 的优点：&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;可靠，稳定。&lt;/p&gt;
&lt;p&gt;TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="网络" scheme="https://timmy6.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
  </entry>
  
  <entry>
    <title>推荐三个实用的Go开发工具</title>
    <link href="https://timmy6.github.io/2020/08/15/%E6%8E%A8%E8%8D%90%E4%B8%89%E4%B8%AA%E4%BD%BF%E7%94%A8%E7%9A%84Go%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
    <id>https://timmy6.github.io/2020/08/15/%E6%8E%A8%E8%8D%90%E4%B8%89%E4%B8%AA%E4%BD%BF%E7%94%A8%E7%9A%84Go%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</id>
    <published>2020-08-15T14:15:10.000Z</published>
    <updated>2022-05-18T06:30:53.386Z</updated>
    
    <content type="html"><![CDATA[<p><strong>原文链接：</strong> <a href="https://mp.weixin.qq.com/s/3GLMLhegB3wF5_62mpmePA">推荐三个实用的 Go 开发工具</a></p><p>孙悟空在花果山称王的时候，特意去了一趟东海，在那里淘到了如意金箍棒。因为身为一个山大王，怎么能没有一件趁手的兵器呢？</p><p>作为程序员的我们也一样，除了我们的傍身武器 <code>Ctrl C + V</code> 之外，还要不停的补充我们的武器库。不仅要把 <code>Ctrl C + V</code> 用的高级，更要用的恰到好处。</p><p>今天介绍三款小工具，分别可以将 <code>json</code>，<code>yaml</code> 和 <code>table</code> 转成 Go 的 <code>struct</code>。下次再碰到这样的转换场景，再也不用皱眉挠头了，一键轻松搞定。</p><p>前两个直接在线转换，最后一个需要安装一个库，但也很方便。</p><h3 id="json-to-go"><a href="#json-to-go" class="headerlink" title="json-to-go"></a>json-to-go</h3><p><strong>地址：</strong> <a href="https://mholt.github.io/json-to-go/">https://mholt.github.io/json-to-go/</a></p><p>输入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;input_index&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;candidate_index&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;delivery_line_1&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1 N Rosedale St&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;components&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line"><span class="attr">&quot;primary_number&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;street_predirection&quot;</span><span class="punctuation">:</span> <span class="string">&quot;N&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;street_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Rosedale&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;street_suffix&quot;</span><span class="punctuation">:</span> <span class="string">&quot;St&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;city_name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Baltimore&quot;</span><span class="punctuation">,</span></span><br><span class="line"><span class="attr">&quot;state_abbreviation&quot;</span><span class="punctuation">:</span> <span class="string">&quot;MD&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AutoGenerated []<span class="keyword">struct</span> &#123;</span><br><span class="line">InputIndex     <span class="type">int</span>    <span class="string">`json:&quot;input_index&quot;`</span></span><br><span class="line">CandidateIndex <span class="type">int</span>    <span class="string">`json:&quot;candidate_index&quot;`</span></span><br><span class="line">DeliveryLine1  <span class="type">string</span> <span class="string">`json:&quot;delivery_line_1&quot;`</span></span><br><span class="line">Components     <span class="keyword">struct</span> &#123;</span><br><span class="line">PrimaryNumber      <span class="type">string</span> <span class="string">`json:&quot;primary_number&quot;`</span></span><br><span class="line">StreetPredirection <span class="type">string</span> <span class="string">`json:&quot;street_predirection&quot;`</span></span><br><span class="line">StreetName         <span class="type">string</span> <span class="string">`json:&quot;street_name&quot;`</span></span><br><span class="line">StreetSuffix       <span class="type">string</span> <span class="string">`json:&quot;street_suffix&quot;`</span></span><br><span class="line">CityName           <span class="type">string</span> <span class="string">`json:&quot;city_name&quot;`</span></span><br><span class="line">StateAbbreviation  <span class="type">string</span> <span class="string">`json:&quot;state_abbreviation&quot;`</span></span><br><span class="line">&#125; <span class="string">`json:&quot;components&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="yaml-to-go"><a href="#yaml-to-go" class="headerlink" title="yaml-to-go"></a>yaml-to-go</h3><p><strong>地址：</strong> <a href="https://zhwt.github.io/yaml-to-go/">https://zhwt.github.io/yaml-to-go/</a></p><p>输入：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">image:</span> <span class="string">golang:latest</span></span><br><span class="line"></span><br><span class="line"><span class="attr">before_script:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">mkdir</span> <span class="string">-p</span> <span class="string">$GOPATH/src/$(dirname</span> <span class="string">$REPO_NAME)</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">ln</span> <span class="string">-svf</span> <span class="string">$CI_PROJECT_DIR</span> <span class="string">$GOPATH/src/$REPO_NAME</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">cd</span> <span class="string">$GOPATH/src/$REPO_NAME</span></span><br><span class="line"></span><br><span class="line"><span class="attr">stages:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">test</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">build</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">deploy</span></span><br><span class="line"></span><br><span class="line"><span class="attr">format:</span></span><br><span class="line">  <span class="attr">stage:</span> <span class="string">test</span></span><br><span class="line">  <span class="attr">script:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">go</span> <span class="string">fmt</span> <span class="string">$(go</span> <span class="string">list</span> <span class="string">./...</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">-v</span> <span class="string">/vendor/)</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">go</span> <span class="string">vet</span> <span class="string">$(go</span> <span class="string">list</span> <span class="string">./...</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">-v</span> <span class="string">/vendor/)</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">go</span> <span class="string">test</span> <span class="string">-race</span> <span class="string">$(go</span> <span class="string">list</span> <span class="string">./...</span> <span class="string">|</span> <span class="string">grep</span> <span class="string">-v</span> <span class="string">/vendor/)</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> AutoGenerated <span class="keyword">struct</span> &#123;</span><br><span class="line">Image        <span class="type">string</span>   <span class="string">`yaml:&quot;image&quot;`</span></span><br><span class="line">BeforeScript []<span class="type">string</span> <span class="string">`yaml:&quot;before_script&quot;`</span></span><br><span class="line">Stages       []<span class="type">string</span> <span class="string">`yaml:&quot;stages&quot;`</span></span><br><span class="line">Format       <span class="keyword">struct</span> &#123;</span><br><span class="line">Stage  <span class="type">string</span>   <span class="string">`yaml:&quot;stage&quot;`</span></span><br><span class="line">Script []<span class="type">string</span> <span class="string">`yaml:&quot;script&quot;`</span></span><br><span class="line">&#125; <span class="string">`yaml:&quot;format&quot;`</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="table-to-go"><a href="#table-to-go" class="headerlink" title="table-to-go"></a>table-to-go</h3><p><strong>地址</strong> <a href="https://github.com/gohouse/converter">https://github.com/gohouse/converter</a></p><p>假设有这样一张表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> `prefix_user` (</span><br><span class="line">  `Id` <span class="type">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  `Email` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;邮箱&#x27;</span>,</span><br><span class="line">  `Password` <span class="type">varchar</span>(<span class="number">32</span>) <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="string">&#x27;&#x27;</span> COMMENT <span class="string">&#x27;密码&#x27;</span>,</span><br><span class="line">  `CreatedAt` datetime <span class="keyword">NOT</span> <span class="keyword">NULL</span> <span class="keyword">DEFAULT</span> <span class="built_in">CURRENT_TIMESTAMP</span>,</span><br><span class="line">  <span class="keyword">PRIMARY</span> KEY (`Id`)</span><br><span class="line">) ENGINE<span class="operator">=</span>InnoDB <span class="keyword">DEFAULT</span> CHARSET<span class="operator">=</span>utf8mb4 COMMENT<span class="operator">=</span><span class="string">&#x27;用户表&#x27;</span></span><br></pre></td></tr></table></figure><p>使用方式分两种，分别是命令行调用和写 Go 代码：</p><h4 id="命令行调用"><a href="#命令行调用" class="headerlink" title="命令行调用"></a>命令行调用</h4><p>1、下载对应平台的可执行文件， 下载地址：<a href="https://github.com/gohouse/converter/releases">https://github.com/gohouse/converter/releases</a></p><p>2、命令行执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./table2struct-linux.v0.0.3.bin -file model.go -dsn xxx -table user</span><br></pre></td></tr></table></figure><p>3、参数说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-dsn            string 数据库dsn配置</span><br><span class="line">-enableJsonTag  bool 是否添加json的tag</span><br><span class="line">-file           string 保存路径</span><br><span class="line">-packageName    string 包名</span><br><span class="line">-prefix         string 表前缀</span><br><span class="line">-realNameMethod string 结构体对应的表名</span><br><span class="line">-table          string 要迁移的表</span><br><span class="line">-tagKey         string tag的key</span><br></pre></td></tr></table></figure><h4 id="Go-代码调用"><a href="#Go-代码调用" class="headerlink" title="Go 代码调用"></a>Go 代码调用</h4><p>安装库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/gohouse/converter</span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/gohouse/converter&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="comment">// 初始化</span></span><br><span class="line">t2t := converter.NewTable2Struct()</span><br><span class="line"><span class="comment">// 个性化配置</span></span><br><span class="line">t2t.Config(&amp;converter.T2tConfig&#123;</span><br><span class="line"><span class="comment">// 如果字段首字母本来就是大写, 就不添加tag, 默认false添加, true不添加</span></span><br><span class="line">RmTagIfUcFirsted: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">// tag的字段名字是否转换为小写, 如果本身有大写字母的话, 默认false不转</span></span><br><span class="line">TagToLower: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">// 字段首字母大写的同时, 是否要把其他字母转换为小写,默认false不转换</span></span><br><span class="line">UcFirstOnly: <span class="literal">false</span>,</span><br><span class="line"><span class="comment">//// 每个struct放入单独的文件,默认false,放入同一个文件(暂未提供)</span></span><br><span class="line"><span class="comment">//SeperatFile: false,</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 开始迁移转换</span></span><br><span class="line">err := t2t.</span><br><span class="line"><span class="comment">// 指定某个表,如果不指定,则默认全部表都迁移</span></span><br><span class="line">Table(<span class="string">&quot;user&quot;</span>).</span><br><span class="line"><span class="comment">// 表前缀</span></span><br><span class="line">Prefix(<span class="string">&quot;prefix_&quot;</span>).</span><br><span class="line"><span class="comment">// 是否添加json tag</span></span><br><span class="line">EnableJsonTag(<span class="literal">true</span>).</span><br><span class="line"><span class="comment">// 生成struct的包名(默认为空的话, 则取名为: package model)</span></span><br><span class="line">PackageName(<span class="string">&quot;model&quot;</span>).</span><br><span class="line"><span class="comment">// tag字段的key值,默认是orm</span></span><br><span class="line">TagKey(<span class="string">&quot;orm&quot;</span>).</span><br><span class="line"><span class="comment">// 是否添加结构体方法获取表名</span></span><br><span class="line">RealNameMethod(<span class="string">&quot;TableName&quot;</span>).</span><br><span class="line"><span class="comment">// 生成的结构体保存路径</span></span><br><span class="line">SavePath(<span class="string">&quot;/Users/fizz/go/src/github.com/gohouse/gupiao/model/model.go&quot;</span>).</span><br><span class="line"><span class="comment">// 数据库dsn,这里可以使用 t2t.DB() 代替,参数为 *sql.DB 对象</span></span><br><span class="line">Dsn(<span class="string">&quot;root:root@tcp(localhost:3306)/test?charset=utf8&quot;</span>).</span><br><span class="line"><span class="comment">// 执行</span></span><br><span class="line">Run()</span><br><span class="line"></span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> model</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;time&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span> &#123;</span><br><span class="line">Id         <span class="type">int</span>     <span class="string">`json:&quot;Id&quot; orm:&quot;Id&quot;`</span></span><br><span class="line">Email      <span class="type">string</span>  <span class="string">`json:&quot;Email&quot; orm:&quot;Email&quot;`</span>           <span class="comment">// 邮箱</span></span><br><span class="line">Password   <span class="type">string</span>  <span class="string">`json:&quot;Password&quot; orm:&quot;Password&quot;`</span>     <span class="comment">// 密码</span></span><br><span class="line">CreatedAt  <span class="type">string</span>  <span class="string">`json:&quot;CreatedAt&quot; orm:&quot;CreatedAt&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*User)</span></span> TableName() <span class="type">string</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;user&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>收藏吧！希望你用到的时候还能想起它。</p><hr>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;原文链接：&lt;/strong&gt; &lt;a href=&quot;https://mp.weixin.qq.com/s/3GLMLhegB3wF5_62mpmePA&quot;&gt;推荐三个实用的 Go 开发工具&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;孙悟空在花果山称王的时候，特意去了一趟东海，在那里淘到</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
  </entry>
  
  <entry>
    <title>rabbitmq基本操作</title>
    <link href="https://timmy6.github.io/2020/07/05/rabbitmq%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <id>https://timmy6.github.io/2020/07/05/rabbitmq%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</id>
    <published>2020-07-05T14:15:10.000Z</published>
    <updated>2022-05-17T07:03:05.181Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.toutiao.com/i6826959307888656899/">https://www.toutiao.com/i6826959307888656899/</a></li><li><a href="https://www.cnblogs.com/Zhangcsc/p/11739754.html">https://www.cnblogs.com/Zhangcsc/p/11739754.html</a></li></ul><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="交换机exchange"><a href="#交换机exchange" class="headerlink" title="交换机exchange"></a>交换机exchange</h3><p>接收消息，并根据路由键转发消息到所绑定的队列</p><h3 id="交换机的4种类型"><a href="#交换机的4种类型" class="headerlink" title="交换机的4种类型"></a>交换机的4种类型</h3><ul><li>topic 对路由键进行模式匹配，将消息转发到匹配上的队列上，其中<code>*</code> 表示匹配任意一个单词，<code>#</code> 表示匹配任意一个或多个单词，使用<code>.</code>分割单词，例如路由键<code>quick.orange.rabbit</code>，可以匹配上绑定键<code>quick.#</code>,<code>*.orange.rabbit</code></li><li>direct 要求路由键必须与绑定key完全匹配，这样才会被转发对应的队列</li><li>fanout 不处理路由键。你只需要简单的将队列绑定到交换机上，一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上</li><li>headers 不处理路由键，而是根据消息内容中的headers属性进行匹配</li></ul><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><code>basic.consume</code>持续订阅,自动接收下一条消息</li><li><code>basic.get</code>获取单条消息</li><li><code>basic.ack</code>确认收到消息,或者消费者在订阅到队列的时候就将<code>auto ack</code>设置为true</li><li><code>basic.reject</code>丢弃消息,如果将<code>reject</code>命令的<code>requeue</code>参数设置为true的话,<code>rabbitmq</code>会将消息投递给下个消费者,否则会立即从队列删除消息并且存放到死信队列</li><li><code>queue.declare</code>创建队列,如果不指定名称则随机分配一个名称,作为匿名队列<ul><li><code>exclusive</code>限制只有由一个消费者够消费</li><li><code>auto-delete</code>当最后一个消费者取消订阅时候,队列会自动移除</li><li>当重复声明一个已存在的队列,若声明参数完全匹配现存队列,rabbit什么都不会做并返回成功</li><li>设置<code>queue.declare</code>的<code>passive</code>为<code>true</code>时,如果队列已存在,<code>queue.declare</code>返回成功,如果队列不存在,<code>queue.declare</code>命令不会创建队列而会返回一个错误</li></ul></li></ul><h2 id="应该由生成者还是消费者创建队列呢"><a href="#应该由生成者还是消费者创建队列呢" class="headerlink" title="应该由生成者还是消费者创建队列呢?"></a>应该由生成者还是消费者创建队列呢?</h2><p>假设由消费者创建队列,若生成者先投递消息,此时还没有消费者,这个时候消息会怎么样?当有消费者了并且创建队列了会怎么样?<br>答: 消息会提示发送成功,但是事实上它已经丢失了,即时消费者创建队列了也不能消费之前的发布的消息,最好的做法是消费者和生成者都要尝试创建队列,并且绑定队列和交换器</p><h2 id="生产消息"><a href="#生产消息" class="headerlink" title="生产消息"></a>生产消息</h2><ul><li>AMQP_NOPARAM 无</li><li>AMQP_DURABLE 持久化exchange</li><li>AMQP_PASSIVE 声明一个已存在的交换器的，如果不存在将抛出异常，这个一般用在consume端。因为一般produce端创建,在consume端建议设置成AMQP_PASSIVE,防止consume创建exchange</li><li>AMQP_AUTODELETE 该交换器将在没有消息队列绑定时自动删除</li></ul><h2 id="为什么要用信道channel"><a href="#为什么要用信道channel" class="headerlink" title="为什么要用信道channel"></a>为什么要用信道channel</h2><p>为了减少tcp连接开销,多个通道可以共享tcp连接???</p><h2 id="什么是消息幂等性？"><a href="#什么是消息幂等性？" class="headerlink" title="什么是消息幂等性？"></a>什么是消息幂等性？</h2><p>无论一条消息被消费多少次，消费的结果都是一样的。</p><h2 id="什么是confirm消息确认机制？"><a href="#什么是confirm消息确认机制？" class="headerlink" title="什么是confirm消息确认机制？"></a>什么是confirm消息确认机制？</h2><p>生成者生成消息，Broker收到消息就会给生产者一个应答，生产者接受应答来确认broker是否收到消息。</p><h3 id="如何实现confirm确认消息？"><a href="#如何实现confirm确认消息？" class="headerlink" title="如何实现confirm确认消息？"></a>如何实现confirm确认消息？</h3><ul><li>在Channel上开启确认模式：<code>channel.confirmSelect()</code></li><li>在channel上添加监听：<code>addConfirmListener</code>，监听成功和失败的结果，具体结果对消息进行重新发送或者记录日志。</li></ul><h2 id="如何生成的消息匹配不到队列会怎么样？"><a href="#如何生成的消息匹配不到队列会怎么样？" class="headerlink" title="如何生成的消息匹配不到队列会怎么样？"></a>如何生成的消息匹配不到队列会怎么样？</h2><p>如果<code>Mandatory</code>设置为true，如果找不到队列，则broker会调用<code>basic.return</code>方法将消息返还给生产者;当<code>mandatory</code>设置为false时，出现上述情况broker会直接将消息丢弃;通俗的讲，mandatory标志告诉broker代理服务器至少将消息route到一个队列中，否则就将消息return给发送者;<br><strong>Mandatory设置为true只有在confirm模式有效</strong></p><h3 id="如何获得被return回来的消息？"><a href="#如何获得被return回来的消息？" class="headerlink" title="如何获得被return回来的消息？"></a>如何获得被return回来的消息？</h3><p>通过为channel信道设置<code>ReturnListener</code>监听器来实现</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="keyword">__DIR__</span> . <span class="string">&#x27;/vendor/autoload.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Connection</span>\<span class="title">AMQPStreamConnection</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Message</span>\<span class="title">AMQPMessage</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$connection</span> = <span class="keyword">new</span> <span class="title class_">AMQPStreamConnection</span>(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">5672</span>, <span class="string">&#x27;guest&#x27;</span>, <span class="string">&#x27;guest&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="variable">$channel</span> = <span class="variable">$connection</span>-&gt;<span class="title function_ invoke__">channel</span>();</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">set_return_listener</span>(function (<span class="variable">$i</span>,<span class="variable">$msg</span>,<span class="variable">$exchange</span>,<span class="variable">$routeKey</span>,AMQPMessage <span class="variable">$message</span>) &#123;</span><br><span class="line">   <span class="title function_ invoke__">print_r</span>(<span class="variable">$message</span>-&gt;body);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">confirm_select</span>();</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">set_ack_handler</span>(function (AMQPMessage <span class="variable">$message</span>) &#123;</span><br><span class="line">    <span class="title function_ invoke__">print_r</span>(<span class="variable">$message</span>-&gt;body);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">exchange_declare</span>(<span class="string">&#x27;hyperf&#x27;</span>, <span class="string">&#x27;topic&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_declare</span>(<span class="string">&#x27;kt-test&#x27;</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_bind</span>(<span class="string">&#x27;kt-test&#x27;</span>, <span class="string">&#x27;kt-test&#x27;</span>, <span class="string">&#x27;kt-test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">2</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="keyword">new</span> <span class="title class_">AMQPMessage</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">    <span class="comment">//设置一个匹配不到队列的路由键，mandatory设置为true</span></span><br><span class="line">    <span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">basic_publish</span>(<span class="variable">$msg</span>, <span class="string">&#x27;hyperf&#x27;</span>, <span class="string">&#x27;kjfwelf&#x27;</span>,<span class="literal">true</span>); </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot; [x] Sent &#x27;Hello World!&#x27;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">wait_for_pending_acks_returns</span>(<span class="number">10</span>); <span class="comment">//等待</span></span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line"><span class="variable">$connection</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br></pre></td></tr></table></figure><h2 id="什么是消费端的限流？"><a href="#什么是消费端的限流？" class="headerlink" title="什么是消费端的限流？"></a>什么是消费端的限流？</h2><p>rabbitMQ提供了一种<code>qos</code>的功能，即非自动确认消息的前提下，如果有一定数目的消息（通过consumer或者Channel设置qos）未被确认，不进行新的消费。</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">basic_qos</span>(<span class="variable">$prefetch_size</span>, <span class="variable">$prefetch_count</span>, <span class="variable">$a_global</span>);</span><br></pre></td></tr></table></figure><ul><li>prefetchSize:0 单条消息的大小限制。0就是不限制，一般都是不限制。</li><li>prefetchCount: 设置一个固定的值，一旦有N个消息还没有ack，则consumer将block掉，直到有消息ack</li><li>global：是否将上面的设置用于channel，也是就是说上面设置的限制是用于channel级别的还是consumer的级别的。</li></ul><h2 id="什么是TTL队列-x2F-消息？"><a href="#什么是TTL队列-x2F-消息？" class="headerlink" title="什么是TTL队列&#x2F;消息？"></a>什么是TTL队列&#x2F;消息？</h2><ul><li>支持消息的过期时间，在消息发送时可以指定。</li><li>支持队列过期时间，在消息入队列开始计算时间，只要超过了队列的超时时间配置，那么消息就会自动的清除。</li></ul><h2 id="什么是死信队列？"><a href="#什么是死信队列？" class="headerlink" title="什么是死信队列？"></a>什么是死信队列？</h2><p>死信队列：DLX，Dead-Letter-Exchange</p><h3 id="消息变为死信的几种情况："><a href="#消息变为死信的几种情况：" class="headerlink" title="消息变为死信的几种情况："></a>消息变为死信的几种情况：</h3><ul><li>消息被拒绝（basic.reject&#x2F;basic.nack）同时requeue&#x3D;false（不重回队列）</li><li>TTL过期</li><li>队列达到最大长度<br><a href="https://www.cnblogs.com/Zhangcsc/p/11739754.html">https://www.cnblogs.com/Zhangcsc/p/11739754.html</a><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require_once</span> <span class="keyword">__DIR__</span> . <span class="string">&#x27;/vendor/autoload.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Connection</span>\<span class="title">AMQPStreamConnection</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Message</span>\<span class="title">AMQPMessage</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">PhpAmqpLib</span>\<span class="title">Wire</span>\<span class="title">AMQPTable</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable">$connection</span> = <span class="keyword">new</span> <span class="title class_">AMQPStreamConnection</span>(<span class="string">&#x27;localhost&#x27;</span>, <span class="number">5672</span>, <span class="string">&#x27;guest&#x27;</span>, <span class="string">&#x27;guest&#x27;</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line"><span class="variable">$channel</span> = <span class="variable">$connection</span>-&gt;<span class="title function_ invoke__">channel</span>();</span><br><span class="line"></span><br><span class="line"><span class="variable">$args</span> = <span class="keyword">new</span> <span class="title class_">AMQPTable</span>();</span><br><span class="line"><span class="comment">// 消息过期方式：设置 queue.normal 队列中的消息10s之后过期</span></span><br><span class="line"><span class="variable">$args</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;x-message-ttl&#x27;</span>, <span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 设置队列最大长度方式： x-max-length</span></span><br><span class="line"><span class="comment">//$args-&gt;set(&#x27;x-max-length&#x27;, 1);</span></span><br><span class="line"><span class="variable">$args</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;x-dead-letter-exchange&#x27;</span>, <span class="string">&#x27;exchange.dlx&#x27;</span>);</span><br><span class="line"><span class="variable">$args</span>-&gt;<span class="title function_ invoke__">set</span>(<span class="string">&#x27;x-dead-letter-routing-key&#x27;</span>, <span class="string">&#x27;routingkey&#x27;</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">exchange_declare</span>(<span class="string">&#x27;exchange.dlx&#x27;</span>, <span class="string">&#x27;direct&#x27;</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_declare</span>(<span class="string">&#x27;queue.dlx&#x27;</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_bind</span>(<span class="string">&#x27;queue.dlx&#x27;</span>, <span class="string">&#x27;exchange.dlx&#x27;</span>, <span class="string">&#x27;routingkey&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">exchange_declare</span>(<span class="string">&#x27;hyperf&#x27;</span>, <span class="string">&#x27;topic&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_declare</span>(<span class="string">&#x27;test-ttl&#x27;</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>,<span class="literal">false</span>,<span class="variable">$args</span>);</span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">queue_bind</span>(<span class="string">&#x27;test-ttl&#x27;</span>, <span class="string">&#x27;hyperf&#x27;</span>, <span class="string">&#x27;kt-test&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="variable">$i</span> = <span class="number">0</span>; <span class="variable">$i</span> &lt; <span class="number">2</span>; <span class="variable">$i</span>++) &#123;</span><br><span class="line">    <span class="variable">$msg</span> = <span class="keyword">new</span> <span class="title class_">AMQPMessage</span>(<span class="string">&#x27;Hello World!&#x27;</span>);</span><br><span class="line">    <span class="comment">//设置一个匹配不到队列的路由键，mandatory设置为true</span></span><br><span class="line">    <span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">basic_publish</span>(<span class="variable">$msg</span>, <span class="string">&#x27;hyperf&#x27;</span>, <span class="string">&#x27;kt-test&#x27;</span>,<span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot; [x] Sent &#x27;Hello World!&#x27;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$channel</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br><span class="line"><span class="variable">$connection</span>-&gt;<span class="title function_ invoke__">close</span>();</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.toutiao.com/i6826959307888656899/&quot;&gt;https://</summary>
      
    
    
    
    <category term="rabbitmq" scheme="https://timmy6.github.io/categories/rabbitmq/"/>
    
    
  </entry>
  
  <entry>
    <title>微服务</title>
    <link href="https://timmy6.github.io/2020/06/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    <id>https://timmy6.github.io/2020/06/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1/</id>
    <published>2020-06-02T14:15:10.000Z</published>
    <updated>2022-05-17T06:52:16.315Z</updated>
    
    <content type="html"><![CDATA[<h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>每个子业务独立部署，不会互相影响</li><li>每个子业务可以使用不同的开发语言</li></ul><h2 id="grpc和protobuf"><a href="#grpc和protobuf" class="headerlink" title="grpc和protobuf"></a>grpc和protobuf</h2><ul><li>gRPC 是谷歌开源的轻量级 RPC 通信框架，其中的通信协议基于二进制数据流，支持 HTTP 2.0 协议，还可以为通信双方建立持续的双向数据流</li><li>protobuf 两个微服务之间通过基于 HTTP 2.0 二进制数据帧通信，那么如何约定二进制数据的格式呢？答案是使用 gRPC 内置的 protobuf 协议，其 DSL 语法 可清晰定义服务间通信的数据结构</li></ul><h2 id="docker容器"><a href="#docker容器" class="headerlink" title="docker容器"></a>docker容器</h2><p>多个容器共享宿主主机的 kernel，多个容器之间相互隔离</p><h2 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h2><p>它作为一个注册中心会记录每个微服务的 IP 和端口，各微服务上线时会在它那注册，下线时会注销</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/micro/protobuf/proto</span><br><span class="line">go get -u github.com/micro/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure><h2 id="微服务的优点"><a href="#微服务的优点" class="headerlink" title="微服务的优点"></a>微服务的优点</h2><ul><li>各个子模块互相独立，可以选用不同的技术栈，独立开发和维护。</li><li>故障隔离，一个服务挂掉不会影响其他服务。</li></ul><h2 id="微服务的缺点"><a href="#微服务的缺点" class="headerlink" title="微服务的缺点"></a>微服务的缺点</h2><ul><li>数据一致性</li><li>事务问题</li><li>session一致性问题</li><li>锁问题</li><li>单个服务不可用导致整个系统崩溃（熔断器）</li><li>不同开发团队需要紧密协作。</li><li>定位问题难，问题日志可能分布在多台nginx上</li><li>系统变得更加复杂，运维也是个问题。</li></ul><h2 id="如何保障微服务架构下的数据一致性？"><a href="#如何保障微服务架构下的数据一致性？" class="headerlink" title="如何保障微服务架构下的数据一致性？"></a>如何保障微服务架构下的数据一致性？</h2><p><a href="https://www.cnblogs.com/mahatmasmile/p/8530077.html">https://www.cnblogs.com/mahatmasmile/p/8530077.html</a><br>CAP理论，c一致性，a可用性，p分区容错性<br>具体表现为在一定时间内，可能模块之间数据是不一致的，但是通过自动或手动补偿后能够达到最终的一致。<br>二阶段提交协议<br>可靠消息最终一致性</p><ul><li>上游应用将本地业务执行和消息发送绑定在同一个本地事务中，保证要么本地操作成功并发送 MQ 消息</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;优点&quot;&gt;&lt;a href=&quot;#优点&quot; class=&quot;headerlink&quot; title=&quot;优点&quot;&gt;&lt;/a&gt;优点&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;每个子业务独立部署，不会互相影响&lt;/li&gt;
&lt;li&gt;每个子业务可以使用不同的开发语言&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;gr</summary>
      
    
    
    
    <category term="微服务" scheme="https://timmy6.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
  </entry>
  
  <entry>
    <title>程序常用算法</title>
    <link href="https://timmy6.github.io/2020/05/20/%E7%A8%8B%E5%BA%8F%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/"/>
    <id>https://timmy6.github.io/2020/05/20/%E7%A8%8B%E5%BA%8F%E5%B8%B8%E7%94%A8%E7%AE%97%E6%B3%95/</id>
    <published>2020-05-20T15:15:10.000Z</published>
    <updated>2022-05-17T06:50:09.882Z</updated>
    
    <content type="html"><![CDATA[<h2 id="给定一个数组-找最大元素值"><a href="#给定一个数组-找最大元素值" class="headerlink" title="给定一个数组,找最大元素值"></a>给定一个数组,找最大元素值</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> arr = []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">45</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;</span><br><span class="line"><span class="keyword">var</span> beginPtr = <span class="number">0</span></span><br><span class="line"><span class="keyword">var</span> endPtr = <span class="built_in">len</span>(arr) - <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> beginPtr &lt; endPtr &#123; <span class="comment">// 知道两个位置重叠,这个数即为最大值(最小值)</span></span><br><span class="line"><span class="keyword">if</span> arr[beginPtr] &gt; arr[endPtr] &#123;</span><br><span class="line">endPtr--</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">beginPtr++</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">&quot;max value:&quot;</span>, arr[beginPtr])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="给定一个数组-随机找其中几个不重复的元素"><a href="#给定一个数组-随机找其中几个不重复的元素" class="headerlink" title="给定一个数组,随机找其中几个不重复的元素"></a>给定一个数组,随机找其中几个不重复的元素</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;math/rand&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">rand.Seed(time.Now().Unix())</span><br><span class="line"><span class="keyword">var</span> arr = []<span class="type">int</span>&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;</span><br><span class="line"><span class="keyword">var</span> total = <span class="built_in">len</span>(arr)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">4</span>; i++ &#123;</span><br><span class="line">j := rand.Int()%total + i <span class="comment">// 从剩余元素中随机抽取一个元素</span></span><br><span class="line">arr[i], arr[j] = arr[j], arr[i] <span class="comment">// 将随机抽取的元素替换掉开头的元素</span></span><br><span class="line">total-- </span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(arr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>任何数字和某个数字a求余时,其结果不会超过a</li><li><code>rand.Int()%total</code>,随着total递减,所以改表达式求值结果最大值不会超过剩余元素个数</li><li><code>rand.Int()%total + i</code>,加<code>i</code>的目的是让元素位置往后移动</li><li><code>arr[i], arr[j] = arr[j], arr[i]</code>,后面的随机数会替换掉前面的数字</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;给定一个数组-找最大元素值&quot;&gt;&lt;a href=&quot;#给定一个数组-找最大元素值&quot; class=&quot;headerlink&quot; title=&quot;给定一个数组,找最大元素值&quot;&gt;&lt;/a&gt;给定一个数组,找最大元素值&lt;/h2&gt;&lt;figure class=&quot;highlight go&quot;&gt;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://timmy6.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="https://timmy6.github.io/2020/05/10/%E9%93%BE%E8%A1%A8/"/>
    <id>https://timmy6.github.io/2020/05/10/%E9%93%BE%E8%A1%A8/</id>
    <published>2020-05-10T15:15:10.000Z</published>
    <updated>2022-05-17T06:48:49.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><ul><li>相对于数组,链表不需要连续的存储地址</li><li>每一个节点会记录下一个节点的地址</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://blog.csdn.net/weixin_41582192/article/details/81181077">https://blog.csdn.net/weixin_41582192/article/details/81181077</a></li></ul><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="节点内部结构"><a href="#节点内部结构" class="headerlink" title="节点内部结构"></a>节点内部结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">int</span></span><br><span class="line">    Next *node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>头节点没有data,有next</li><li>尾节点有data,没有next</li></ul><h3 id="删除节点"><a href="#删除节点" class="headerlink" title="删除节点"></a>删除节点</h3><p>例如<code>a-&gt;b-&gt;c</code>,删除b,流程如下:</p><ul><li>根据b.next获取c的地址</li><li>要怎么找到a,并将a.next赋值为c的地址<h3 id="插入节点"><a href="#插入节点" class="headerlink" title="插入节点"></a>插入节点</h3>例如<code>a-&gt;c</code>之间插入b,流程如下:</li><li>创建b节点</li><li>根据a.next获取c的地址,然后赋值为b.next</li><li>将b的地址赋值给a.next</li></ul><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h3 id="节点内部结构-1"><a href="#节点内部结构-1" class="headerlink" title="节点内部结构"></a>节点内部结构</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> node <span class="keyword">struct</span> &#123;</span><br><span class="line">    Data <span class="type">int</span></span><br><span class="line">    Next *node</span><br><span class="line">    Prev *node</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;链表&quot;&gt;&lt;a href=&quot;#链表&quot; class=&quot;headerlink&quot; title=&quot;链表&quot;&gt;&lt;/a&gt;链表&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;相对于数组,链表不需要连续的存储地址&lt;/li&gt;
&lt;li&gt;每一个节点会记录下一个节点的地址&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;</summary>
      
    
    
    
    <category term="数据结构与算法" scheme="https://timmy6.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>redis架构模式</title>
    <link href="https://timmy6.github.io/2020/04/12/redis%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    <id>https://timmy6.github.io/2020/04/12/redis%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-04-12T14:15:10.000Z</published>
    <updated>2022-05-17T06:41:01.553Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Redis-有哪些架构模式？讲讲各自的特点"><a href="#Redis-有哪些架构模式？讲讲各自的特点" class="headerlink" title="Redis 有哪些架构模式？讲讲各自的特点"></a>Redis 有哪些架构模式？讲讲各自的特点</h2><ul><li>单机版</li><li>主从复制</li><li>哨兵模式（监控主从服务器，主服务器下线能够自动进行故障转移）</li><li>集群</li></ul><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>大概两个过程：</p><ul><li>从节点发送sync给主节点，主节点发送rdb快照文件给从节点，从节点从快照文件同步数据</li><li>主节点每写一个命令就会同步到从节点，从节点接收并执行收到的命令</li></ul><h2 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h2><p>一般使用3个哨兵，1主2从</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>监控主节点和从节点的状态</li><li>当主节点发送故障，会自动将从节点转换为主节点，整个过程不需要人工参与<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3></li><li>哨兵节点会向所有主从节点和其他哨兵节点发送ping消息，如果主节点在一定时间内（down-after-milliseconds）没有得到回复，则会被哨兵节点标记为主观下线（SDOWN）。</li><li>当有足够数据量的哨兵节点标记主节点为主观下线，则主节点会标记为客观下线。</li><li>主节点会进行故障转移，选取一个从节点来替换主节点。<h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3>准备节点：3个哨兵，1主，2从；</li><li>主从节点主要配置如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使得Redis服务器可以跨网络访问</span></span><br><span class="line"><span class="built_in">bind</span> 0.0.0.0</span><br><span class="line"><span class="comment"># 设置密码</span></span><br><span class="line">requirepass <span class="string">&quot;123456&quot;</span></span><br><span class="line"><span class="comment"># 指定主服务器，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置</span></span><br><span class="line">slaveof 192.168.11.128 6379</span><br><span class="line"><span class="comment"># 主服务器密码，注意：有关slaveof的配置只是配置从服务器，主服务器不需要配置</span></span><br><span class="line">masterauth 123456</span><br></pre></td></tr></table></figure></li><li>哨兵节点配置如下：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 禁止保护模式</span></span><br><span class="line">protected-mode no</span><br><span class="line"><span class="comment"># 配置监听的主服务器，这里sentinel monitor代表监控，mymaster代表服务器的名称，可以自定义，192.168.11.128代表监控的主服务器，6379代表端口，2代表只有两个或两个以上的哨兵认为主服务器不可用的时候，才会进行failover操作。</span></span><br><span class="line">sentinel monitor mymaster 192.168.11.128 6379 2</span><br><span class="line"><span class="comment"># sentinel author-pass定义服务的密码，mymaster是服务名称，123456是Redis服务器密码</span></span><br><span class="line"><span class="comment"># sentinel auth-pass &lt;master-name&gt; &lt;password&gt;</span></span><br><span class="line">sentinel auth-pass mymaster 123456</span><br></pre></td></tr></table></figure></li><li>启动哨兵节点和主从节点<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> /data/wwwroot/redis/redis_sentinel</span><br><span class="line"><span class="comment">#启动redis</span></span><br><span class="line">redis-server redis_6480/redis.conf <span class="comment">#这个是主节点</span></span><br><span class="line">redis-server redis_6481/redis.conf</span><br><span class="line">redis-server redis_6482/redis.conf</span><br><span class="line"><span class="comment">#查看主从是否启动成功</span></span><br><span class="line">redis-cli -h 127.0.0.1 -p 6480 ping</span><br><span class="line">redis-cli -h 127.0.0.1 -p 6480 info replication</span><br><span class="line"><span class="comment">#启动哨兵</span></span><br><span class="line">redis-sentinel sentinel_26379/sentinel.conf</span><br><span class="line">redis-sentinel sentinel_26380/sentinel.conf</span><br><span class="line">redis-sentinel sentinel_26381/sentinel.conf</span><br><span class="line"><span class="comment">#确认哨兵是否启用成功</span></span><br><span class="line">redis-cli -p 26379 info sentinel</span><br></pre></td></tr></table></figure></li></ul><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>redis的集群采用无中心结构，所有redis节点彼此互联（PING—PONG机制），当某个节点失败时需要集群中超过半数节点检测失效才会生效。客户端与redis节点直连，不需要借助中间代理层，客户端不需要连接集群所有节点,连接集群中任何一个可用节点即可。</p><h3 id="集群数据分布"><a href="#集群数据分布" class="headerlink" title="集群数据分布"></a>集群数据分布</h3><p>每一个节点负责维护一部分槽和槽存放的数据，槽的范围是0到16383<br>key -&gt; 槽 -&gt; 节点</p><h3 id="集群请求路由"><a href="#集群请求路由" class="headerlink" title="集群请求路由"></a>集群请求路由</h3><ul><li>先计算key对应的槽，可以通过<code>cluster keyslot &#123;key&#125;</code>查看对应哪个槽</li><li>找槽对应的节点</li><li>若不是本节点，则回复move重定向错误，通知客户端请求正确的节点<br>cli模式下重定向，加上<code>-c</code>参数，例如<code>redis-cli -p 6481 -c</code><h3 id="如何解决集群mget问题？"><a href="#如何解决集群mget问题？" class="headerlink" title="如何解决集群mget问题？"></a>如何解决集群mget问题？</h3></li></ul><p>集群带来的一个问题是，无法批处理，例如当我们提交了一批命令，往Redis中存储一批键，那么这些键一般会被映射到不同的slot，而不同的slot又可能在Redis Cluster中不同的节点上，这样就和的预期有点不同，有没有办法将这批键映射到同一个slot呢？</p><p>可以使用<code>hash_tag</code>，哈希标签是确保两个键都在同一个哈希槽里的一种方式。</p><ul><li>比如这两个键 {user1000}.following 和 {user1000}.followers 会被哈希到同一个哈希槽里，因为只有 user1000 这个子串会被用来计算哈希值。</li><li>对于 foo{}{bar} 这个键，整个键都会被用来计算哈希值，因为第一个出现的 { 和它右边第一个出现的 } 之间没有任何字符。</li><li>对于 foo{bar}{zap} 这个键，用来计算哈希值的是 bar 这个子串，因为算法会在第一次有效或无效（比如中间没有任何字节）地匹配到 { 和 } 的时候停止。</li></ul><p><img src="/assets/1615987751665.png" alt="1615987751665"></p><h3 id="集群是如何扩容"><a href="#集群是如何扩容" class="headerlink" title="集群是如何扩容?"></a>集群是如何扩容?</h3><ul><li>添加新节点，<code>redis-trib.rb add-node new_host:new_port exitsing_host:existing_port</code> ，新加入节点刚开始都是主节点状态，没有负责槽，不能接收任何读写操作，需要导入槽和数据，或者是设置为从节点</li><li>迁移过程<code>redis-trib.rb reshard &#123;existing_ip:existing_port&#125;</code><ul><li>目标节点准备导入槽</li><li>源节点准备导出槽</li><li>获取槽下n个key</li><li>批量迁移相关key的数据</li><li>循环迁移key</li><li>通知槽分配给目标节点</li></ul></li><li>新节点设置成从节点，具体进入从节点命令行，执行cluster replicate master_id</li></ul><h3 id="集群是如何缩容？"><a href="#集群是如何缩容？" class="headerlink" title="集群是如何缩容？"></a>集群是如何缩容？</h3><ul><li>下线节点是否有负责的槽 ，如果有的话需要先迁移到其他节点上，命令<code>使用redis-trib.rb reshared &#123;existing_ip:existing_port&#125;</code></li><li>当下线节点不再负责槽或者本身是从节点就可以通知集群其他节点忘记下线节点，命令<code>使用redis-trib.rb del-node &#123;host:port&#125; &#123;downNodeId&#125; 忘记节点</code></li><li>下线节点正常关闭</li></ul><h3 id="集群是如何故障转移的？"><a href="#集群是如何故障转移的？" class="headerlink" title="集群是如何故障转移的？"></a>集群是如何故障转移的？</h3><ul><li>首先，如果一个节点在规定时间内没有回复，会被其他节点标记为主观下线</li><li>如果被超过半数的节点标记为主观下线，则故障节点会被标为客观下线</li><li>资格检查；当从节点通过内部定时任务发现自身复制的主节点进入客观下线时，则会触发选举，触发条件：断线时间不超过<code>cluster-node-time*cluster-slave-validity-fator</code>，目的是剔除太久没有同步主节点数据的从节点</li><li>准备选举时间；一个故障主节点可能会有多个从节点，这就需要有发起选举的优先级，主要根据复制偏移量来设置延迟选举时间，复制偏移量越大，排名越靠前，延迟时间越低，越有机会才会主节点</li><li>选举投票；<ul><li>只有持有槽的主节点才能参与选举投票</li><li>只有一个从节点获得n&#x2F;2+1的选票才能选举成功</li><li>在<code>clsuter-node-timeout*2</code>内从节点没有获取足够数量的投票，选举作废</li></ul></li><li>替换主节点，接管故障节点的槽和通知集群</li></ul><h3 id="迁移槽命令参数"><a href="#迁移槽命令参数" class="headerlink" title="迁移槽命令参数"></a>迁移槽命令参数</h3><p><code>redis-trib.rb reshard &#123;existing_ip:existing_port&#125;</code></p><ul><li>–slots 需要确定迁移槽的总数量，总槽数&#x2F;总节点</li><li>–from 多个源节点，迁出槽</li><li>–to 一个目标节点，迁入槽</li><li>–timeout 控制每次migrate操作的超时时间，默认为60000毫秒</li><li>–pipeline 控制每次批量迁移键的数量，默认为10</li><li>host:port 集群中任意一个节点的地址</li></ul><h2 id="docker安装redis"><a href="#docker安装redis" class="headerlink" title="docker安装redis"></a>docker安装redis</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --name redis -p 6379:6379 redis</span><br></pre></td></tr></table></figure><h2 id="配置文件修改"><a href="#配置文件修改" class="headerlink" title="配置文件修改"></a>配置文件修改</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">port 6481</span><br><span class="line">cluster-enabled <span class="built_in">yes</span></span><br><span class="line"><span class="comment">#集群内部配置文件</span></span><br><span class="line">cluster-config-file nodes-6481.conf</span><br><span class="line"><span class="comment">#节点超时时间，单位毫秒</span></span><br><span class="line">cluster-node-timeout 15000</span><br><span class="line">logfile <span class="string">&quot;/data/wwwroot/redis/redis_cluster/6481/log/redis-6481.log&quot;</span></span><br><span class="line">pidfile /data/wwwroot/redis/redis_cluster/redis-6481.pid</span><br></pre></td></tr></table></figure><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#启动节点</span></span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6481/redis-6481.conf</span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6482/redis-6482.conf</span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6483/redis-6483.conf</span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6484/redis-6484.conf</span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6485/redis-6485.conf</span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6486/redis-6486.conf</span><br><span class="line"></span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6487/redis-6487.conf</span><br><span class="line">redis-server /data/wwwroot/redis/redis_cluster/6488/redis-6488.conf</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建集群</span></span><br><span class="line"><span class="comment">#--replicas 1表示每个主节点配备几个从节点</span></span><br><span class="line">redis-trib.rb create --replicas 1 127.0.0.1:6481 127.0.0.1:6482 127.0.0.1:6483 127.0.0.1:6484 127.0.0.1:6485 127.0.0.1:6486</span><br><span class="line"></span><br><span class="line"><span class="comment">#检测集群完整性</span></span><br><span class="line"><span class="comment">#只要16384个槽中有一个没有分配给节点则表示集群不完整</span></span><br><span class="line"><span class="comment">#可以对集群中任意一个节点发起检测</span></span><br><span class="line">redis-trib.rb check 127.0.0.1:6481</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看集群所有节点</span></span><br><span class="line">cluster nodes</span><br><span class="line"></span><br><span class="line"><span class="comment">#集群扩容</span></span><br><span class="line"><span class="comment">#6487是新节点，6481是已存在节点</span></span><br><span class="line"><span class="comment">#如果新节点已存在数据，则会添加失败</span></span><br><span class="line"><span class="comment">#redis-trib.rb add-node &#123;new_ip:new_port&#125; &#123;existing_ip:existing_port&#125;</span></span><br><span class="line">redis-trib.rb add-node 127.0.0.1:6487 127.0.0.1:6481</span><br><span class="line"><span class="comment">#迁移槽和数据，127.0.0.1:6481为集群中任意一个节点</span></span><br><span class="line">redis-trib.rb reshard 127.0.0.1:6481</span><br><span class="line"></span><br><span class="line"><span class="comment">#集群缩容</span></span><br><span class="line"><span class="comment">#迁移槽</span></span><br><span class="line">redis-trib.rb reshard 127.0.0.1:6481</span><br><span class="line"><span class="comment">#忘记节点</span></span><br><span class="line">redis-trib.rb del-node 127.0.0.1:6487 d4aafc5465d0f85a55ccd648e045cedcb46478cd</span><br><span class="line"></span><br><span class="line"><span class="comment">#请求路由</span></span><br><span class="line"><span class="comment">#查看key对应的槽</span></span><br><span class="line">cluster keyslot &#123;key&#125;</span><br><span class="line"><span class="comment">#cli模式下加上-c可以重定向到正确节点</span></span><br><span class="line">redis-cli -p 6481 -c</span><br></pre></td></tr></table></figure><h2 id="新节点迁移槽和数据"><a href="#新节点迁移槽和数据" class="headerlink" title="新节点迁移槽和数据"></a>新节点迁移槽和数据</h2><h2 id="日志输出"><a href="#日志输出" class="headerlink" title="日志输出"></a>日志输出</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">M: b079123bb42e1de36e9bc21d0473f8ceda6f7265 127.0.0.1:6481</span><br><span class="line">   slots:0-5460 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">M: bcbb401d25543cfc6384546ad24b46eb264b426e 127.0.0.1:6483</span><br><span class="line">   slots:10923-16383 (5461 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 8f2f21cb11d1986da9137f099e938bdb4e0f230e 127.0.0.1:6484</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates fa0015a21a575b170f5e39f463cc62fdb3a6e667</span><br><span class="line">S: af886e91bf0f42e36627d16d35bc270c0b6fb35e 127.0.0.1:6486</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates b079123bb42e1de36e9bc21d0473f8ceda6f7265</span><br><span class="line">M: fa0015a21a575b170f5e39f463cc62fdb3a6e667 127.0.0.1:6482</span><br><span class="line">   slots:5461-10922 (5462 slots) master</span><br><span class="line">   1 additional replica(s)</span><br><span class="line">S: 41e8cc7350b94185fca11ce243183f414307b037 127.0.0.1:6485</span><br><span class="line">   slots: (0 slots) slave</span><br><span class="line">   replicates bcbb401d25543cfc6384546ad24b46eb264b426e</span><br><span class="line">[OK] All nodes agree about slots configuration.</span><br><span class="line">&gt;&gt;&gt; Check <span class="keyword">for</span> open slots...</span><br><span class="line">&gt;&gt;&gt; Check slots coverage...</span><br><span class="line">[OK] All 16384 slots covered.</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Redis-有哪些架构模式？讲讲各自的特点&quot;&gt;&lt;a href=&quot;#Redis-有哪些架构模式？讲讲各自的特点&quot; class=&quot;headerlink&quot; title=&quot;Redis 有哪些架构模式？讲讲各自的特点&quot;&gt;&lt;/a&gt;Redis 有哪些架构模式？讲讲各自的特点&lt;/</summary>
      
    
    
    
    <category term="redis" scheme="https://timmy6.github.io/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>redis持久化</title>
    <link href="https://timmy6.github.io/2020/03/03/redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>https://timmy6.github.io/2020/03/03/redis%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2020-03-03T14:15:10.000Z</published>
    <updated>2022-05-17T06:33:50.875Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.jianshu.com/p/bab8f4b26445">https://www.jianshu.com/p/bab8f4b26445</a></li><li><a href="https://www.cnblogs.com/lizhimin123/p/10192217.html">https://www.cnblogs.com/lizhimin123/p/10192217.html</a></li></ul><blockquote><p>相对于memcache,redis的是数据可以做持久化处理,主要有两种方式,快照rdb和追加文件aof,redis是持久化处理是比较耗时,一般在主从模式中,master不做持久化处理,由slave处理</p></blockquote><h2 id="什么是Redis持久化？"><a href="#什么是Redis持久化？" class="headerlink" title="什么是Redis持久化？"></a>什么是Redis持久化？</h2><p>持久化就是把内存的数据写到磁盘中去，防止服务宕机了内存数据丢失。</p><h2 id="快照rdb"><a href="#快照rdb" class="headerlink" title="快照rdb"></a>快照rdb</h2><ul><li>redis使用操作系统的多进程COW机制(Copy On Write)复制写机制来实现快照的持久化</li><li>由子进程进行持久操作，子进程刚刚产生时，和父进程共享内存里面的代码段和数据段</li><li>子进程会</li></ul><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>持久化有两个命令，<code>save</code>和<code>bgsave</code>，<code>save</code>会阻塞服务进程，直到持久化完成，<code>bgsave</code>会fork子进程，由子进程去完成持久化，<code>bgsave</code>对应配置如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 满足以上三个条件中的任意一个，则自动触发 BGSAVE 操作 </span><br><span class="line">save 900 1       // 服务器在900秒之内，对数据库执行了至少1次修改 </span><br><span class="line">save 300 10      // 服务器在300秒之内，对数据库执行了至少10修改 </span><br><span class="line">save 60  1000    // 服务器在60秒之内，对数据库执行了至少1000修改</span><br></pre></td></tr></table></figure><h3 id="rdb文件结构"><a href="#rdb文件结构" class="headerlink" title="rdb文件结构"></a>rdb文件结构</h3><p><a href="https://www.cnblogs.com/lizhimin123/p/10192217.html">https://www.cnblogs.com/lizhimin123/p/10192217.html</a><br><img src="https://img2018.cnblogs.com/blog/1522047/201812/1522047-20181229102040895-1225006452.png" alt="https://img2018.cnblogs.com/blog/1522047/201812/1522047-20181229102040895-1225006452.png"></p><ul><li>REDIS：5字节，保存着 “REDIS” 五个字符</li><li>db_version：4字节，RDB文件的版本号</li><li>database 0：数据库中的键值对<ul><li>SELECTDB：1字节常量</li><li>db_number：数据库号码</li><li>key_value_pairs：键值对<ul><li>type: 记录类对象的编码类型，程序会根据 TYPE 属性来决定如何读入和解释value数据</li><li>key</li><li>value</li></ul></li></ul></li><li>EOF：RDB文件的结束标志</li><li>check_sum：校验和（CRC64），用来检查RDB文件是否出错</li></ul><h3 id="rdb问题"><a href="#rdb问题" class="headerlink" title="rdb问题"></a>rdb问题</h3><ul><li>持久化过程中数据发生改变？<br>rdb文件被成为快照文件，子进程所看到的数据在它被创建的一瞬间就固定下来了，父进程修改的某个数据只是该数据的复制品。（父子进程共享内存，数据发生写时会另外复制一份数据进行修改）<br><img src="https://upload-images.jianshu.io/upload_images/7789414-016d9f4ff4c14e33.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1196/format/webp" alt="https://upload-images.jianshu.io/upload_images/7789414-016d9f4ff4c14e33.png?imageMogr2/auto-orient/strip|imageView2/2/w/1196/format/webp"></li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点:"></a>优点:</h3><ul><li>性能好  <h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点:"></a>缺点:</h3></li><li>实时性差</li></ul><h2 id="追加日志aof"><a href="#追加日志aof" class="headerlink" title="追加日志aof"></a>追加日志aof</h2><p>redis将指令追加到日志，通过回放指令来恢复数据，随着时间的增大会有日志文件变大的问题，这就需要重写日志</p><h2 id="aof重写日志的过程是怎么样的？"><a href="#aof重写日志的过程是怎么样的？" class="headerlink" title="aof重写日志的过程是怎么样的？"></a>aof重写日志的过程是怎么样的？</h2><p><img src="https://upload-images.jianshu.io/upload_images/7789414-42813796f197b274.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/957/format/webp" alt="https://upload-images.jianshu.io/upload_images/7789414-42813796f197b274.png?imageMogr2/auto-orient/strip|imageView2/2/w/957/format/webp"></p><ul><li>fork子进程</li><li>子进程遍历内存数据写到新的aof文件</li><li>在生成新的aof文件的过程中，如果收到新指令，则继续保存在系统内存缓存中</li><li>完成新的aof文件之后，将系统内存缓存数据追加到新的aof文件</li><li>新的aof文件代替旧的aof文件</li></ul><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点:"></a>优点:</h3><ul><li>实时性小  <h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点:"></a>缺点:</h3></li><li>需要重写日志文件</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.jianshu.com/p/bab8f4b26445&quot;&gt;https://www.jia</summary>
      
    
    
    
    <category term="redis" scheme="https://timmy6.github.io/categories/redis/"/>
    
    
  </entry>
  
  <entry>
    <title>redis常见问题</title>
    <link href="https://timmy6.github.io/2020/02/03/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://timmy6.github.io/2020/02/03/redis%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2020-02-03T14:15:10.000Z</published>
    <updated>2022-05-17T06:30:07.515Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/jasontec/p/9699242.html">https://www.cnblogs.com/jasontec/p/9699242.html</a></li><li><a href="https://zhuanlan.zhihu.com/p/79778696">https://zhuanlan.zhihu.com/p/79778696</a></li></ul><h2 id="使用过Redis分布式锁么，它是怎么实现的？"><a href="#使用过Redis分布式锁么，它是怎么实现的？" class="headerlink" title="使用过Redis分布式锁么，它是怎么实现的？"></a>使用过Redis分布式锁么，它是怎么实现的？</h2><p>redis的分布式锁主要使用<code>set</code>命令的<code>nx</code>选项抢占锁，以及<code>ex</code>设置过期时间，先nx获得锁并且设置过期时间，这两个过程是原子性的，中间不会被其他命令打断；<br>另外防止锁超时过期误删锁，一般使用<code>set</code>获得锁时会设置一个唯一值，释放锁的时候需要匹配一下两个值是否一致</p><h2 id="什么是一致性哈希算法？什么是哈希槽？"><a href="#什么是一致性哈希算法？什么是哈希槽？" class="headerlink" title="什么是一致性哈希算法？什么是哈希槽？"></a>什么是一致性哈希算法？什么是哈希槽？</h2><p><a href="https://www.jianshu.com/p/6ad87a1f070e">https://www.jianshu.com/p/6ad87a1f070e</a></p><p>redis 的 custer 提供了两个功能：</p><ul><li>自动对数据分片，落到各个节点上</li><li>即使集群部分节点失效或者连接不上，依然可以继续处理命令</li></ul><p>普通哈希算法是<code>hash(key)%number</code>对数量进行取余获得key所在节点位置，如果改变数量会导致原有节点上的数据发生变化；</p><p>在一致性哈希算法中，整个哈希空间是一个虚拟圆环。 对节点取哈希值，然后分配到哈希环上。对某个值进行搜索的时候按顺时针搜索找到key第一个存在的节点，即使发生节点数据变化，也只是影响一小部分区间的数据；</p><p>一致性哈希算法对于容错性和扩展性有非常好的支持。但一致性哈希算法也有一个严重的问题，就是数据倾斜。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><ul><li>对每个真实节点增加多个虚拟节点，然后维护一个虚拟节点和真实节点的映射关系表；（即环上都是）<a href="https://geektutu.com/post/geecache-day4.html">https://geektutu.com/post/geecache-day4.html</a></li><li>rredis 集群（cluster）并没有选用上面一致性哈希，而是采用了哈希槽（slot）的这种概念。每个redis节点会维护一部分槽以及槽上的数据，总的槽大概一万六千多，槽可以均匀分布在多个节点</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> --net=host --name redis-manager  \</span><br><span class="line">-e DATASOURCE_DATABASE=<span class="string">&#x27;redis_manager&#x27;</span> \</span><br><span class="line">-e DATASOURCE_URL=<span class="string">&#x27;jdbc:mysql://127.0.0.1:3306/redis_manager?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=GMT%2b8&#x27;</span> \</span><br><span class="line">-e DATASOURCE_USERNAME=<span class="string">&#x27;root&#x27;</span> \</span><br><span class="line">-e DATASOURCE_PASSWORD=<span class="string">&#x27;123456&#x27;</span> \</span><br><span class="line">reasonduan/redis-manager</span><br></pre></td></tr></table></figure><p><a href="https://www.fengpt.cn/archives/redis%E9%9B%86%E7%BE%A4%E5%9C%A8%E6%9F%A5%E6%89%BEkey%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%AF%E7%94%B1%E7%9A%84">https://www.fengpt.cn/archives/redis%E9%9B%86%E7%BE%A4%E5%9C%A8%E6%9F%A5%E6%89%BEkey%E7%9A%84%E6%97%B6%E5%80%99%E6%98%AF%E5%A6%82%E4%BD%95%E8%B7%AF%E7%94%B1%E7%9A%84</a></p><h2 id="redis集群哈希槽"><a href="#redis集群哈希槽" class="headerlink" title="redis集群哈希槽"></a>redis集群哈希槽</h2><p>redis cluster 包含了16384个哈希槽，每个 key 通过计算后都会落在具体一个槽位上，而这个槽位是属于哪个存储节点的，则由用户自己定义分配。例如机器硬盘小的，可以分配少一点槽位，硬盘大的可以分配多一点。如果节点硬盘都差不多则可以平均分配。所以哈希槽这种概念很好地解决了一致性哈希的弊端。</p><p>在容错性和扩展性上，redis对槽位的转移，把故障节点负责的槽位转移到其他正常的节点上。 </p><p>但一定要注意的是，对于槽位的转移和分派，redis 集群是不会自动进行的，而是需要人工配置的。所以 redis 集群的高可用是依赖于节点的主从复制与主从间的自动故障转移。</p><h2 id="使用过Redis做异步队列么，你是怎么用的？有什么缺点？"><a href="#使用过Redis做异步队列么，你是怎么用的？有什么缺点？" class="headerlink" title="使用过Redis做异步队列么，你是怎么用的？有什么缺点？"></a>使用过Redis做异步队列么，你是怎么用的？有什么缺点？</h2><p>可以是使用<code>blpop</code>和<code>rpush</code>，<code>blpop</code>会移除列表头部元素，如果列表没有元素会阻塞直到等待超时或发现元素为止，<code>rpush</code>从尾部写入数据；缺点如下：</p><ul><li>消息容易丢失</li><li>消息分发策略没有专业的mq丰富，例如kafka的分区，rabbitmq的路由键等等</li></ul><h2 id="什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？"><a href="#什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？" class="headerlink" title="什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？"></a>什么是缓存穿透？如何避免？什么是缓存雪崩？何如避免？</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>一般缓存系统会先查缓存，值不存在的时候再查数据库；一些恶意的请求会故意查询不存在的key,请求量很大，就会对后端系统造成很大的压力。这就叫做缓存穿透。如何避免？</p><ul><li>对查询结果为空的情况也进行缓存，缓存时间设置短一点</li><li>对一定不存在的key进行过滤，可以把所有的可能存在的key放到一个大的Bitmap中，查询时通过该bitmap过滤（布尔过滤器）<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3>当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，会给后端系统带来很大压力。导致系统崩溃。如何避免？</li><li>在缓存失效后，通过加锁或者队列来控制读数据库写缓存的线程数量</li><li>不同的key，设置不同的过期时间，让缓存失效的时间点尽量均匀。</li></ul><h2 id="Redis的字典是如何实现的？简述渐进式rehash的过程？"><a href="#Redis的字典是如何实现的？简述渐进式rehash的过程？" class="headerlink" title="Redis的字典是如何实现的？简述渐进式rehash的过程？"></a>Redis的字典是如何实现的？简述渐进式rehash的过程？</h2><p><a href="https://www.jianshu.com/p/e2697fecac0d">https://www.jianshu.com/p/e2697fecac0d</a><br><a href="https://www.cnblogs.com/neooelric/p/9621736.html">https://www.cnblogs.com/neooelric/p/9621736.html</a></p><h2 id="Redis事务是怎么样的？"><a href="#Redis事务是怎么样的？" class="headerlink" title="Redis事务是怎么样的？"></a>Redis事务是怎么样的？</h2><p>redis的事务是通过mutil实现的，mutil开始一个事务，然后将多个命令入队到事务中，最后执行exec命令触发事务。redis的事务有一些不足：</p><ul><li>事务可以理解为一个打包的批量执行脚本，但批量指令并非原子化的操作，中间某条指令的失败不会导致前面已做指令的回滚，也不会造成后续的指令不做</li><li>同的key是有可能分配在不同的Redis节点上的，在这种情况下Redis的事务机制是不生效的</li></ul><h2 id="集群可以使用lua脚本吗？"><a href="#集群可以使用lua脚本吗？" class="headerlink" title="集群可以使用lua脚本吗？"></a>集群可以使用lua脚本吗？</h2><p>不可以，除非key在同一个redis节点上，可以使用<code>&#123;hash_tag&#125;</code>来是不同的key落到同一个节点上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; CLUSTER KEYSLOT somekey</span><br><span class="line">11058</span><br><span class="line">&gt; CLUSTER KEYSLOT foo&#123;hash_tag&#125;</span><br><span class="line">(<span class="built_in">integer</span>) 2515</span><br><span class="line">&gt; CLUSTER KEYSLOT bar&#123;hash_tag&#125;</span><br><span class="line">(<span class="built_in">integer</span>) 2515</span><br></pre></td></tr></table></figure><p>keySlot算法中，如果key包含{}，就会使用第一个{}内部的字符串作为hash key，这样就可以保证拥有同样{}内部字符串的key就会拥有相同slot</p><h2 id="Redis的多数据库机制，了解多少？"><a href="#Redis的多数据库机制，了解多少？" class="headerlink" title="Redis的多数据库机制，了解多少？"></a>Redis的多数据库机制，了解多少？</h2><p>单机版有16个数据库，每个数据库的数据相互隔离，集群版只有一个数据库</p><h2 id="谈谈你对分布式和集群，微服务的理解？两则之间有什么关系？"><a href="#谈谈你对分布式和集群，微服务的理解？两则之间有什么关系？" class="headerlink" title="谈谈你对分布式和集群，微服务的理解？两则之间有什么关系？"></a>谈谈你对分布式和集群，微服务的理解？两则之间有什么关系？</h2><ul><li>分布式是将一个业务拆分多个子业务，多个子业务可以部署不同机器上面，子业务之间通过rpc或消息中间件或其他方式进行通信，如果有一个子业务不可用，那么整个业务就不可用</li><li>微服务是将一个业务拆分多个子业务，多个子业务可以部署在不同机器或统一机器上面（和分布式的区别）。</li><li>集群是同一个业务部署到多个机器上面，比如用nginx做负载均衡。</li><li>分布式下每个子业务都可以做集群，分布式和微服务类似，只是部署方式不一样</li></ul><h2 id="redis集群有什么限制"><a href="#redis集群有什么限制" class="headerlink" title="redis集群有什么限制"></a>redis集群有什么限制</h2><ul><li>不能批量处理key</li><li>不支持事务，多数据库</li><li>一些大的键值对象不能映射到不同的节点上</li></ul><h2 id="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"><a href="#假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？" class="headerlink" title="假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？"></a>假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？</h2><ul><li>使用keys 指定模式可以获得key列表</li><li>因为redis是单线程模式，使用keys命令会导致线程阻塞一段时间，线上服务会停顿，直到命令执行完毕才能恢复</li><li>可以用scan命令，无阻塞的，但是会有一定的重复概率</li></ul><h2 id="bgsave的原理是什么？"><a href="#bgsave的原理是什么？" class="headerlink" title="bgsave的原理是什么？"></a>bgsave的原理是什么？</h2><p>fork是指redis通过创建子进程来进行bgsave操作，cow指的是copy on write，子进程创建后，父子进程共享数据段，父进程继续提供读写服务，写脏的页面数据会逐渐和子进程分离开来。</p><h2 id="Pipeline有什么好处，为什么要用pipeline？"><a href="#Pipeline有什么好处，为什么要用pipeline？" class="headerlink" title="Pipeline有什么好处，为什么要用pipeline？"></a>Pipeline有什么好处，为什么要用pipeline？</h2><p>可以将多次IO往返的时间缩减为一次</p><h2 id="Redis的同步机制了解么？"><a href="#Redis的同步机制了解么？" class="headerlink" title="Redis的同步机制了解么？"></a>Redis的同步机制了解么？</h2><ul><li>第一次同步时，主节点做一次bgsave，并同时将后续修改操作记录到内存buffer，待完成后将rdb文件全量同步到复制节点，复制节点接受完成后将rdb镜像加载到内存。</li><li>加载完成后，再通知主节点将期间修改的操作记录同步到复制节点进行重放就完成了同步过程。</li></ul><h2 id="是否使用过Redis集群，集群的原理是什么？"><a href="#是否使用过Redis集群，集群的原理是什么？" class="headerlink" title="是否使用过Redis集群，集群的原理是什么？"></a>是否使用过Redis集群，集群的原理是什么？</h2><p>Redis Sentinal着眼于高可用，在master宕机时会自动将slave提升为master，继续提供服务。<br>Redis Cluster着眼于扩展性，在单个redis内存不足时，使用Cluster进行分片存储。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.cnblogs.com/jasontec/p/9699242.html&quot;&gt;https:</summary>
      
    
    
    
    <category term="redis" scheme="https://timmy6.github.io/categories/redis/"/>
    
    
  </entry>
  
</feed>
