<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="https://timmy6.github.io/atom.xml" rel="self"/>
  
  <link href="https://timmy6.github.io/"/>
  <updated>2022-05-13T09:46:42.880Z</updated>
  <id>https://timmy6.github.io/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>路由中间件 - 捕获异常</title>
    <link href="https://timmy6.github.io/2019/03/25/catch-error/"/>
    <id>https://timmy6.github.io/2019/03/25/catch-error/</id>
    <published>2019-03-25T13:25:20.000Z</published>
    <updated>2022-05-13T09:46:42.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先同步下项目概况：</p><p><img src="/images/gin/4_api_1.png"></p><p>上篇文章分享了，路由中间件 - 日志记录，这篇文章咱们分享：路由中间件 - 捕获异常。当系统发生异常时，提示 “系统异常，请联系管理员！”，同时并发送 panic 告警邮件。</p><p><img src="/images/gin/4_api_2.png"></p><h2 id="什么是异常？"><a href="#什么是异常？" class="headerlink" title="什么是异常？"></a>什么是异常？</h2><p>在 Go 中异常就是 panic，它是在程序运行的时候抛出的，当 panic 抛出之后，如果在程序里没有添加任何保护措施的话，控制台就会在打印出 panic 的详细情况，然后终止运行。</p><p>我们可以将 panic 分为两种：</p><p>一种是有意抛出的，比如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">panic(&quot;自定义的 panic 信息&quot;)</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019/09/10 20:25:27 http: panic serving [::1]:61547: 自定义的 panic 信息</span><br><span class="line">goroutine 8 [running]:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>一种是无意抛出的，写程序马虎造成，比如，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var slice = [] int &#123;1, 2, 3, 4, 5&#125;</span><br><span class="line"></span><br><span class="line">slice[6] = 6</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2019/09/10 15:27:05 http: panic serving [::1]:61616: runtime error: index out of range</span><br><span class="line">goroutine 6 [running]:</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>想象一下，如果在线上环境出现了 panic，命令行输出的，因为咱们无法捕获就无法定位问题呀，想想都可怕，那么问题来了，怎么捕获异常？</p><h2 id="怎么捕获异常？"><a href="#怎么捕获异常？" class="headerlink" title="怎么捕获异常？"></a>怎么捕获异常？</h2><p>当程序发生 panic 后，在 defer(延迟函数) 内部可以调用 recover 进行捕获。</p><p>不多说，直接上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">defer func() &#123;</span><br><span class="line">if err := recover(); err != nil &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br></pre></td></tr></table></figure><p>在运行一下 “无意抛出的 panic ”，输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runtime error: index out of range</span><br></pre></td></tr></table></figure><p>OK，错误捕获到了，这时我们可以进行做文章了。</p><p>做啥文章，大家应该都知道了吧：</p><ul><li>获取运行时的调用栈（debug.Stack()）</li><li>获取当时的 Request 数据</li><li>组装数据，进行发邮件</li></ul><p>那么，Go 怎么发邮件呀，有没有开源包呀？</p><p>当然有，请往下看。</p><h2 id="封装发邮件方法"><a href="#封装发邮件方法" class="headerlink" title="封装发邮件方法"></a>封装发邮件方法</h2><p>使用包：<code>gopkg.in/gomail.v2</code></p><p>直接上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func SendMail(mailTo string, subject string, body string) error &#123;</span><br><span class="line"></span><br><span class="line">if config.ErrorNotifyOpen != 1 &#123;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m := gomail.NewMessage()</span><br><span class="line"></span><br><span class="line">//设置发件人</span><br><span class="line">m.SetHeader(&quot;From&quot;, config.SystemEmailUser)</span><br><span class="line"></span><br><span class="line">//设置发送给多个用户</span><br><span class="line">mailArrTo := strings.Split(mailTo, &quot;,&quot;)</span><br><span class="line">m.SetHeader(&quot;To&quot;, mailArrTo...)</span><br><span class="line"></span><br><span class="line">//设置邮件主题</span><br><span class="line">m.SetHeader(&quot;Subject&quot;, subject)</span><br><span class="line"></span><br><span class="line">//设置邮件正文</span><br><span class="line">m.SetBody(&quot;text/html&quot;, body)</span><br><span class="line"></span><br><span class="line">d := gomail.NewDialer(config.SystemEmailHost, config.SystemEmailPort, config.SystemEmailUser, config.SystemEmailPass)</span><br><span class="line"></span><br><span class="line">err := d.DialAndSend(m)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">return err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这块我加了一个开关，想开想关，您随意。</p><p>现在会发送邮件了，再整个邮件模板就完美了。</p><h2 id="自定义邮件模板"><a href="#自定义邮件模板" class="headerlink" title="自定义邮件模板"></a>自定义邮件模板</h2><p>如图：</p><p><img src="/images/gin/4_api_3.png"></p><p>这就是告警邮件的模板，还不错吧，大家还想记录什么，可以自定义去修改。</p><h2 id="封装一个中间件"><a href="#封装一个中间件" class="headerlink" title="封装一个中间件"></a>封装一个中间件</h2><p>最后，封装一下。</p><p>直接上代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">func SetUp() gin.HandlerFunc &#123;</span><br><span class="line"></span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">if err := recover(); err != nil &#123;</span><br><span class="line"></span><br><span class="line">DebugStack := &quot;&quot;</span><br><span class="line">for _, v := range strings.Split(string(debug.Stack()), &quot;\n&quot;) &#123;</span><br><span class="line">DebugStack += v + &quot;&lt;br&gt;&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">subject := fmt.Sprintf(&quot;【重要错误】%s 项目出错了！&quot;, config.AppName)</span><br><span class="line"></span><br><span class="line">body := strings.ReplaceAll(MailTemplate, &quot;&#123;ErrorMsg&#125;&quot;, fmt.Sprintf(&quot;%s&quot;, err))</span><br><span class="line">body  = strings.ReplaceAll(body, &quot;&#123;RequestTime&#125;&quot;, util.GetCurrentDate())</span><br><span class="line">body  = strings.ReplaceAll(body, &quot;&#123;RequestURL&#125;&quot;, c.Request.Method + &quot;  &quot; + c.Request.Host + c.Request.RequestURI)</span><br><span class="line">body  = strings.ReplaceAll(body, &quot;&#123;RequestUA&#125;&quot;, c.Request.UserAgent())</span><br><span class="line">body  = strings.ReplaceAll(body, &quot;&#123;RequestIP&#125;&quot;, c.ClientIP())</span><br><span class="line">body  = strings.ReplaceAll(body, &quot;&#123;DebugStack&#125;&quot;, DebugStack)</span><br><span class="line"></span><br><span class="line">_ = util.SendMail(config.ErrorNotifyUser, subject, body)</span><br><span class="line"></span><br><span class="line">utilGin := util.Gin&#123;Ctx: c&#125;</span><br><span class="line">utilGin.Response(500, &quot;系统异常，请联系管理员！&quot;, nil)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">c.Next()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当发生 panic 异常时，输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 500,</span><br><span class="line">    &quot;msg&quot;: &quot;系统异常，请联系管理员！&quot;,</span><br><span class="line">    &quot;data&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时，还会收到一封 panic 告警邮件。</p><p><img src="/images/gin/4_api_4.png"></p><p>便于截图，DebugStack 删减了一些信息。</p><p>到这，就结束了。</p><p><img src="/images/gin/4_api_5.jpeg"></p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ul><li>发邮件的地方，可以调整为异步发送。</li><li>文章中仅贴了部分代码，相关代码请查阅 github。</li><li>测试发邮件时，一定要配置邮箱信息。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先同步下项目概况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/gin/4_api_1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上篇文章分享了，路</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="gin框架" scheme="https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>路由中间件 - 日志记录</title>
    <link href="https://timmy6.github.io/2019/03/10/gin-log-1/"/>
    <id>https://timmy6.github.io/2019/03/10/gin-log-1/</id>
    <published>2019-03-10T11:22:20.000Z</published>
    <updated>2022-05-13T09:40:47.454Z</updated>
    
    <content type="html"><![CDATA[<p>首先同步下项目概况：</p><p><img src="/images/gin/3_api_1.png"></p><p>上篇文章分享了，规划项目目录和参数验证，其中参数验证使用的是 validator.v8 版本，现已更新到 validator.v9 版本，最新代码查看 github 即可。</p><p>这篇文章咱们分享：路由中间件 - 日志记录。</p><p>日志是特别重要的一个东西，方便我们对问题进行排查，这篇文章我们实现将日志记录到文本文件中。</p><p>这是我规划的，需要记录的参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- request 请求数据</span><br><span class="line">    - request_time</span><br><span class="line">    - request_method</span><br><span class="line">    - request_uri</span><br><span class="line">    - request_proto</span><br><span class="line">    - request_ua</span><br><span class="line">    - request_referer</span><br><span class="line">    - request_post_data</span><br><span class="line">    - request_client_ip</span><br><span class="line">    </span><br><span class="line">- response 返回数据</span><br><span class="line">    - response_time</span><br><span class="line">    - response_code</span><br><span class="line">    - response_msg</span><br><span class="line">    - response_data</span><br><span class="line">    </span><br><span class="line">- cost_time 花费时间</span><br></pre></td></tr></table></figure><p>Gin 框架中自带 Logger 中间件，我们了解下框架中自带的 Logger 中间件是否满足我们的需求？</p><h2 id="gin-Logger"><a href="#gin-Logger" class="headerlink" title="gin.Logger()"></a>gin.Logger()</h2><p>我们先使用 gin.Logger() 看看效果。</p><p>在 route.go SetupRouter 方法中增加代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">engine.Use(gin.Logger())</span><br></pre></td></tr></table></figure><p>运行后多请求几次，日志输出在命令行中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GIN] 2019/08/30 - 21:24:16 | 200 |     178.072µs |             ::1 | GET      /ping</span><br><span class="line">[GIN] 2019/08/30 - 21:24:27 | 200 |     367.997µs |             ::1 | POST     /product</span><br><span class="line">[GIN] 2019/08/30 - 21:24:28 | 200 |    2.521592ms |             ::1 | POST     /product</span><br></pre></td></tr></table></figure><p>先解决第一个问题，怎么将日志输出到文本中？</p><p>在 route.go SetupRouter 方法中增加代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f, _ := os.Create(config.AppAccessLogName)</span><br><span class="line">gin.DefaultWriter = io.MultiWriter(f)</span><br><span class="line">engine.Use(gin.Logger())</span><br></pre></td></tr></table></figure><p>运行后多请求几次，日志输出在文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[GIN] 2019/08/30 - 21:36:07 | 200 |     369.023µs |             ::1 | GET      /ping</span><br><span class="line">[GIN] 2019/08/30 - 21:36:08 | 200 |      27.585µs |             ::1 | GET      /ping</span><br><span class="line">[GIN] 2019/08/30 - 21:36:10 | 200 |      14.302µs |             ::1 | POST     /product</span><br></pre></td></tr></table></figure><p>虽然记录到文件成功了，但是记录的参数不是我们想要的样子。</p><p>怎么办呢？</p><p>我们需要自定义一个日志中间件，按照我们需要的参数进行记录。</p><h2 id="自定义-Logger"><a href="#自定义-Logger" class="headerlink" title="自定义 Logger()"></a>自定义 Logger()</h2><p><strong>middleware&#x2F;logger&#x2F;logger.go</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line">package logger</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;bytes&quot;</span><br><span class="line">&quot;encoding/json&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">&quot;go-gin-api/app/config&quot;</span><br><span class="line">&quot;go-gin-api/app/util&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type bodyLogWriter struct &#123;</span><br><span class="line">gin.ResponseWriter</span><br><span class="line">body *bytes.Buffer</span><br><span class="line">&#125;</span><br><span class="line">func (w bodyLogWriter) Write(b []byte) (int, error) &#123;</span><br><span class="line">w.body.Write(b)</span><br><span class="line">return w.ResponseWriter.Write(b)</span><br><span class="line">&#125;</span><br><span class="line">func (w bodyLogWriter) WriteString(s string) (int, error) &#123;</span><br><span class="line">w.body.WriteString(s)</span><br><span class="line">return w.ResponseWriter.WriteString(s)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func SetUp() gin.HandlerFunc &#123;</span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line">bodyLogWriter := &amp;bodyLogWriter&#123;body: bytes.NewBufferString(&quot;&quot;), ResponseWriter: c.Writer&#125;</span><br><span class="line">c.Writer = bodyLogWriter</span><br><span class="line"></span><br><span class="line">//开始时间</span><br><span class="line">startTime := util.GetCurrentMilliTime()</span><br><span class="line"></span><br><span class="line">//处理请求</span><br><span class="line">c.Next()</span><br><span class="line"></span><br><span class="line">responseBody := bodyLogWriter.body.String()</span><br><span class="line"></span><br><span class="line">var responseCode int</span><br><span class="line">var responseMsg  string</span><br><span class="line">var responseData interface&#123;&#125;</span><br><span class="line"></span><br><span class="line">if responseBody != &quot;&quot; &#123;</span><br><span class="line">response := util.Response&#123;&#125;</span><br><span class="line">err := json.Unmarshal([]byte(responseBody), &amp;response)</span><br><span class="line">if err == nil &#123;</span><br><span class="line">responseCode = response.Code</span><br><span class="line">responseMsg  = response.Message</span><br><span class="line">responseData = response.Data</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//结束时间</span><br><span class="line">endTime := util.GetCurrentMilliTime()</span><br><span class="line"></span><br><span class="line">if c.Request.Method == &quot;POST&quot; &#123;</span><br><span class="line">c.Request.ParseForm()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//日志格式</span><br><span class="line">accessLogMap := make(map[string]interface&#123;&#125;)</span><br><span class="line"></span><br><span class="line">accessLogMap[&quot;request_time&quot;]      = startTime</span><br><span class="line">accessLogMap[&quot;request_method&quot;]    = c.Request.Method</span><br><span class="line">accessLogMap[&quot;request_uri&quot;]       = c.Request.RequestURI</span><br><span class="line">accessLogMap[&quot;request_proto&quot;]     = c.Request.Proto</span><br><span class="line">accessLogMap[&quot;request_ua&quot;]        = c.Request.UserAgent()</span><br><span class="line">accessLogMap[&quot;request_referer&quot;]   = c.Request.Referer()</span><br><span class="line">accessLogMap[&quot;request_post_data&quot;] = c.Request.PostForm.Encode()</span><br><span class="line">accessLogMap[&quot;request_client_ip&quot;] = c.ClientIP()</span><br><span class="line"></span><br><span class="line">accessLogMap[&quot;response_time&quot;] = endTime</span><br><span class="line">accessLogMap[&quot;response_code&quot;] = responseCode</span><br><span class="line">accessLogMap[&quot;response_msg&quot;]  = responseMsg</span><br><span class="line">accessLogMap[&quot;response_data&quot;] = responseData</span><br><span class="line"></span><br><span class="line">accessLogMap[&quot;cost_time&quot;] = fmt.Sprintf(&quot;%vms&quot;, endTime - startTime)</span><br><span class="line"></span><br><span class="line">accessLogJson, _ := util.JsonEncode(accessLogMap)</span><br><span class="line"></span><br><span class="line">if f, err := os.OpenFile(config.AppAccessLogName, os.O_WRONLY|os.O_APPEND|os.O_CREATE, 0666); err != nil &#123;</span><br><span class="line">log.Println(err)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">f.WriteString(accessLogJson + &quot;\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行后多请求几次，日志输出在文件中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;cost_time&quot;:&quot;0ms&quot;,&quot;request_client_ip&quot;:&quot;::1&quot;,&quot;request_method&quot;:&quot;GET&quot;,&quot;request_post_data&quot;:&quot;&quot;,&quot;request_proto&quot;:&quot;HTTP/1.1&quot;,&quot;request_referer&quot;:&quot;&quot;,&quot;request_time&quot;:1567172568233,&quot;request_ua&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36&quot;,&quot;request_uri&quot;:&quot;/ping&quot;,&quot;response_code&quot;:1,&quot;response_data&quot;:null,&quot;response_msg&quot;:&quot;pong&quot;,&quot;response_time&quot;:1567172568233&#125;</span><br><span class="line">&#123;&quot;cost_time&quot;:&quot;0ms&quot;,&quot;request_client_ip&quot;:&quot;::1&quot;,&quot;request_method&quot;:&quot;GET&quot;,&quot;request_post_data&quot;:&quot;&quot;,&quot;request_proto&quot;:&quot;HTTP/1.1&quot;,&quot;request_referer&quot;:&quot;&quot;,&quot;request_time&quot;:1567172569158,&quot;request_ua&quot;:&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_13_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.142 Safari/537.36&quot;,&quot;request_uri&quot;:&quot;/ping&quot;,&quot;response_code&quot;:1,&quot;response_data&quot;:null,&quot;response_msg&quot;:&quot;pong&quot;,&quot;response_time&quot;:1567172569158&#125;</span><br><span class="line">&#123;&quot;cost_time&quot;:&quot;0ms&quot;,&quot;request_client_ip&quot;:&quot;::1&quot;,&quot;request_method&quot;:&quot;POST&quot;,&quot;request_post_data&quot;:&quot;name=admin&quot;,&quot;request_proto&quot;:&quot;HTTP/1.1&quot;,&quot;request_referer&quot;:&quot;&quot;,&quot;request_time&quot;:1567172629565,&quot;request_ua&quot;:&quot;PostmanRuntime/7.6.0&quot;,&quot;request_uri&quot;:&quot;/product&quot;,&quot;response_code&quot;:-1,&quot;response_data&quot;:null,&quot;response_msg&quot;:&quot;Key: &#x27;ProductAdd.Name&#x27; Error:Field validation for &#x27;Name&#x27; failed on the &#x27;NameValid&#x27; tag&quot;,&quot;response_time&quot;:1567172629565&#125;</span><br></pre></td></tr></table></figure><p>OK，咱们想要的所有参数全都记录了！</p><p>抛出几个问题吧：</p><p>1、有没有开源的日志记录工具？</p><p>当然有，其中 logrus 是用的最多的，这个工具功能强大。</p><p>2、为什么将日志记录到文本中？</p><p>因为，日志平台可以使用的是 ELK。</p><p>使用 Logstash 进行收集文本文件，使用 Elasticsearch 引擎进行搜索分析，最终在 Kibana 平台展示出来。</p><p>3、当大量请求过来时，写入文件会不会出问题？</p><p>可能会，这块可以使用异步，咱们可以用下 go 的 chan。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;首先同步下项目概况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/gin/3_api_1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上篇文章分享了，规划项目目录和参数验证，其中参数验证使用的是 validator.v8 版本，现已更新到 validator.v9 版本，最新代码查看 </summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="gin框架" scheme="https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>规划项目目录和参数验证</title>
    <link href="https://timmy6.github.io/2019/02/25/gin-modules2/"/>
    <id>https://timmy6.github.io/2019/02/25/gin-modules2/</id>
    <published>2019-02-25T11:22:20.000Z</published>
    <updated>2022-05-13T07:48:43.346Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>首先同步下项目概况：</p><p><img src="/images/gin/2_api_1.png"></p><p>上篇文章分享了，使用 go modules 初始化项目，这篇文章咱们分享：</p><ul><li>规划目录结构</li><li>模型绑定和验证</li><li>自定义验证器</li><li>制定 API 返回结构</li></ul><p>废话不多说，咱们开始吧。</p><h2 id="规划目录结构"><a href="#规划目录结构" class="headerlink" title="规划目录结构"></a>规划目录结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">├─ go-gin-api</span><br><span class="line">│  ├─ app</span><br><span class="line">│     ├─ config           //配置文件</span><br><span class="line">│        ├─ config.go</span><br><span class="line">│     ├─ controller       //控制器层</span><br><span class="line">│        ├─ param_bind</span><br><span class="line">│        ├─ param_verify</span><br><span class="line">│        ├─ ...</span><br><span class="line">│     ├─ model            //数据库ORM</span><br><span class="line">│        ├─ proto</span><br><span class="line">│        ├─ ...</span><br><span class="line">│     ├─ repository       //数据库操作层</span><br><span class="line">│        ├─ ...</span><br><span class="line">│     ├─ route            //路由</span><br><span class="line">│        ├─ middleware</span><br><span class="line">│        ├─ route.go</span><br><span class="line">│     ├─ service          //业务层</span><br><span class="line">│        ├─ ...</span><br><span class="line">│     ├─ util             //工具包</span><br><span class="line">│        ├─ ...</span><br><span class="line">│  ├─ vendor  //依赖包</span><br><span class="line">│     ├─ ...</span><br><span class="line">│  ├─ go.mod</span><br><span class="line">│  ├─ go.sum</span><br><span class="line">│  ├─ main.go //入口文件</span><br></pre></td></tr></table></figure><p>上面的目录结构是我自定义的，大家也可以根据自己的习惯去定义。</p><p>controller 控制器层主要对提交过来的数据进行验证，然后将验证完成的数据传递给 service 处理。</p><p>在 gin 框架中，参数验证有两种：</p><p>1、模型绑定和验证。</p><p>2、自定义验证器。</p><p>其中目录 <code>param_bind</code>，存储的是参数绑定的数据，目录<code>param_verify</code> 存储的是自定义验证器。</p><p>接下来，让咱们进行简单实现。</p><h2 id="模型绑定和验证"><a href="#模型绑定和验证" class="headerlink" title="模型绑定和验证"></a>模型绑定和验证</h2><p>比如，有一个创建商品的接口，商品名称不能为空。</p><p>配置路由(route.go)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">ProductRouter := engine.Group(&quot;&quot;)</span><br><span class="line">&#123;</span><br><span class="line">// 新增产品</span><br><span class="line">ProductRouter.POST(&quot;/product&quot;, product.Add)</span><br><span class="line"></span><br><span class="line">// 更新产品</span><br><span class="line">ProductRouter.PUT(&quot;/product/:id&quot;, product.Edit)</span><br><span class="line"></span><br><span class="line">// 删除产品</span><br><span class="line">ProductRouter.DELETE(&quot;/product/:id&quot;, product.Delete)</span><br><span class="line"></span><br><span class="line">// 获取产品详情</span><br><span class="line">ProductRouter.GET(&quot;/product/:id&quot;, product.Detail)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数绑定(param_bind&#x2F;product.go)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type ProductAdd struct &#123;</span><br><span class="line">Name string `form:&quot;name&quot; json:&quot;name&quot; binding:&quot;required&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器调用(controller&#x2F;product.go)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if err := c.ShouldBind(&amp;param_bind.ProductAdd&#123;&#125;); err != nil &#123;</span><br><span class="line">utilGin.Response(-1, err.Error(), nil)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咱们用 Postman 模拟 post 请求时，name 参数不传或传递为空，会出现：</p><p>Key: ‘ProductAdd.Name’ Error:Field validation for ‘Name’ failed on the ‘required’ tag</p><p>这就使用到了参数设置的 <code>binding:&quot;required&quot;</code>。</p><p>那么还能使用 binding 哪些参数，有文档吗？</p><p>有。Gin 使用 go-playground&#x2F;validator.v8 进行验证，相关文档：</p><p><a href="https://godoc.org/gopkg.in/go-playground/validator.v8">https://godoc.org/gopkg.in/go-playground/validator.v8</a></p><p>接下来，咱们实现一下自定义验证器。</p><h2 id="自定义验证器"><a href="#自定义验证器" class="headerlink" title="自定义验证器"></a>自定义验证器</h2><p>比如，有一个创建商品的接口，商品名称不能为空并且参数名称不能等于 admin。</p><p>类似于这种业务需求，无法 binding 现成的方法，需要我们自己写验证方法，才能实现。</p><p>自定义验证方法(param_verify&#x2F;product.go)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func NameValid (</span><br><span class="line">v *validator.Validate, topStruct reflect.Value, currentStructOrField reflect.Value,</span><br><span class="line">field reflect.Value, fieldType reflect.Type, fieldKind reflect.Kind, param string,</span><br><span class="line">) bool &#123;</span><br><span class="line">if s, ok := field.Interface().(string); ok &#123;</span><br><span class="line">if s == &quot;admin&quot; &#123;</span><br><span class="line">return false</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数绑定(param_bind&#x2F;product.go)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type ProductAdd struct &#123;</span><br><span class="line">Name string `form:&quot;name&quot; json:&quot;name&quot; binding:&quot;required,NameValid&quot;`</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时还要绑定验证器:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 绑定验证器</span><br><span class="line">if v, ok := binding.Validator.Engine().(*validator.Validate); ok &#123;</span><br><span class="line">v.RegisterValidation(&quot;NameValid&quot;, param_verify.NameValid)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咱们用 Postman 模拟 post 请求时，name 参数不传或传递为空，会出现：</p><p>Key: ‘ProductAdd.Name’ Error:Field validation for ‘Name’ failed on the ‘required’ tag</p><p>name&#x3D;admin 时：</p><p>Key: ‘ProductAdd.Name’ Error:Field validation for ‘Name’ failed on the ‘NameValid’ tag</p><p>OK，上面两个验证都生效了！</p><p>上面的输出都是在控制台，能不能返回一个 Json 结构的数据呀？</p><p>能。接下来咱们制定 API 返回结构。</p><h2 id="制定-API-返回结构"><a href="#制定-API-返回结构" class="headerlink" title="制定 API 返回结构"></a>制定 API 返回结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 1,</span><br><span class="line">    &quot;msg&quot;: &quot;&quot;,</span><br><span class="line">    &quot;data&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>API 接口的返回的结构基本都是这三个字段。</p><p>比如 code&#x3D;1 表示成功，code&#x3D;-1 表示失败。</p><p>msg 表示提示信息。</p><p>data 表示要返回的数据。</p><p>那么，我们怎么在 gin 框架中实现它，其实很简单 基于 <code>c.JSON()</code> 方法进行封装即可，直接看代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package util</span><br><span class="line"></span><br><span class="line">import &quot;github.com/gin-gonic/gin&quot;</span><br><span class="line"></span><br><span class="line">type Gin struct &#123;</span><br><span class="line">Ctx *gin.Context</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type response struct &#123;</span><br><span class="line">Code     int         `json:&quot;code&quot;`</span><br><span class="line">Message  string      `json:&quot;msg&quot;`</span><br><span class="line">Data     interface&#123;&#125; `json:&quot;data&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (g *Gin)Response(code int, msg string, data interface&#123;&#125;) &#123;</span><br><span class="line">g.Ctx.JSON(200, response&#123;</span><br><span class="line">Code    : code,</span><br><span class="line">Message : msg,</span><br><span class="line">Data    : data,</span><br><span class="line">&#125;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制器调用(controller&#x2F;product.go)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">utilGin := util.Gin&#123;Ctx:c&#125;</span><br><span class="line">if err := c.ShouldBind(&amp;param_bind.ProductAdd&#123;&#125;); err != nil &#123;</span><br><span class="line">utilGin.Response(-1, err.Error(), nil)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>咱们用 Postman 模拟 post 请求时，name 参数不传或传递为空，会出现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: -1,</span><br><span class="line">    &quot;msg&quot;: &quot;Key: &#x27;ProductAdd.Name&#x27; Error:Field validation for &#x27;Name&#x27; failed on the &#x27;required&#x27; tag&quot;,</span><br><span class="line">    &quot;data&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>name&#x3D;admin 时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: -1,</span><br><span class="line">    &quot;msg&quot;: &quot;Key: &#x27;ProductAdd.Name&#x27; Error:Field validation for &#x27;Name&#x27; failed on the &#x27;NameValid&#x27; tag&quot;,</span><br><span class="line">    &quot;data&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK，上面两个验证都生效了！</p><h2 id="源码地址"><a href="#源码地址" class="headerlink" title="源码地址"></a>源码地址</h2><p><a href="https://github.com/xinliangnote/go-gin-api">https://github.com/xinliangnote/go-gin-api</a></p><h2 id="go-gin-api-系列文章"><a href="#go-gin-api-系列文章" class="headerlink" title="go-gin-api 系列文章"></a>go-gin-api 系列文章</h2><ul><li><a href="https://mp.weixin.qq.com/s/1XNTEgZ0XGZZdxFOfR5f_A">1. 使用 go modules 初始化项目</a></li></ul><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><p><strong>Gin 模型验证 Validator 升级：validator.v8 升级为 validator.v9，已提交到 github !!!</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;首先同步下项目概况：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/gin/2_api_1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;上篇文章分享了，使</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="gin框架" scheme="https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>使用 go modules 初始化项目</title>
    <link href="https://timmy6.github.io/2019/02/15/gin-modules/"/>
    <id>https://timmy6.github.io/2019/02/15/gin-modules/</id>
    <published>2019-02-15T13:12:50.000Z</published>
    <updated>2022-05-13T07:42:06.370Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>我想实现一个开箱即用的 API 框架的轮子，这个轮子是基于 Gin 基础上开发的。</p><p>为什么是开箱即用，它会集成哪些功能？</p><p><img src="/images/gin/1_api_1.png"></p><p>以上功能点，都是常用的，后期可能还会增加。</p><p>废话不多说，咱们开始吧。</p><p>创建一个项目，咱们首先要考虑一个依赖包的管理工具。</p><p>常见的包管理有，dep、go vendor、glide、go modules 等。</p><p>最开始，使用过 dep，当时被朋友 diss 了，推荐我使用 go modules 。</p><p>现在来说一下 go modules ，这个是随着 Go 1.11 的发布和我们见面的，这是官方提倡的新的包管理。</p><p>说一个环境变量：GO111MODULE，默认值为 auto 。</p><p>当项目中有 go.mod 时，使用 go modules 管理，反之使用 旧的 GOPATH 和 vendor机制。</p><p>如果就想使用 go modules ，可以将 GO111MODULE 设置为 on 。</p><p>直接上手吧。</p><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>咱们在 GOPATH 之外的地方，新建一个空文件夹 <code>go-gin-api</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd go-gin-api &amp;&amp; go mod init go-gin-api</span><br></pre></td></tr></table></figure><p>输出：</p><p>go: creating new go.mod: module go-gin-api</p><p>这时目录中多一个 go.mod 文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module go-gin-api</span><br><span class="line"></span><br><span class="line">go 1.12</span><br></pre></td></tr></table></figure><p>到这，go mod 初始化就完成，接下来添加依赖包 - gin。</p><h2 id="添加依赖包"><a href="#添加依赖包" class="headerlink" title="添加依赖包"></a>添加依赖包</h2><p>在目录中创建一个 <code>main.go</code> 的文件，放上如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;github.com/gin-gonic/gin&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">r := gin.Default()</span><br><span class="line">r.GET(&quot;/ping&quot;, func(c *gin.Context) &#123;</span><br><span class="line">c.JSON(200, gin.H&#123;</span><br><span class="line">&quot;message&quot;: &quot;pong&quot;,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">r.Run() // listen and serve on 0.0.0.0:8080</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这代码没什么特别的，就是官方的入门Demo。</p><p>接下来，开始下载依赖包。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod tidy</span><br></pre></td></tr></table></figure><p>执行完成后，看一下 <code>go.mod</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">module go-gin-api</span><br><span class="line"></span><br><span class="line">go 1.12</span><br><span class="line"></span><br><span class="line">require github.com/gin-gonic/gin v1.4.0</span><br></pre></td></tr></table></figure><p>这时，看到新增一个 gin v1.4.0 的包。</p><p>还生成了一个 go.sum 的文件，这个文件可以暂时先不管。</p><p>这时发现了 2 个问题。</p><p>1、目录中没发现 gin 包，包下载到哪了？</p><p>下载到了 GOPATH&#x2F;pkg&#x2F;mod 目录中。</p><p>2、GoLand 编辑器中关于 Gin 的引用变红了？</p><p>在这里编辑器需要设置一下，如图：</p><p><img src="/images/gin/1_api_2.png"></p><p>点击 Apply 和 OK 即可。</p><p>如果这招不灵，还可以执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod vendor</span><br></pre></td></tr></table></figure><p>这个命令是将项目依赖的包，放到项目的 vendor 目录中，这肯定就可以了。</p><h2 id="go-mod-命令"><a href="#go-mod-命令" class="headerlink" title="go mod 命令"></a>go mod 命令</h2><p><strong>go mod tidy</strong></p><p>拉取缺少的模块，移除不用的模块。</p><p>我常用这个命令。</p><p><strong>go mod vendor</strong></p><p>将依赖复制到vendor下。</p><p>我常用这个命令。</p><p><strong>go mod download</strong></p><p>下载依赖包。</p><p><strong>go mod verify</strong></p><p>检验依赖。</p><p><strong>go mod graph</strong></p><p>打印模块依赖图。</p><p>其他命令，可以执行 <code>go mod</code> ，查看即可。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>这篇文章，分享了 go modules 的使用。</p><ul><li>使用 go modules 从零搭建一个项目。</li><li>GoLand 编辑器使用 go modules。</li></ul><p>今天就到这了，下一篇文章开始搭建 API 项目了，写参数验证。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;我想实现一个开箱即用的 API 框架的轮子，这个轮子是基于 Gin 基础上开发的。&lt;/p&gt;
&lt;p&gt;为什么是开箱即用，它会集成哪些功能？&lt;/p</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="gin框架" scheme="https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>gRPC 工具</title>
    <link href="https://timmy6.github.io/2019/02/10/grpc-tools/"/>
    <id>https://timmy6.github.io/2019/02/10/grpc-tools/</id>
    <published>2019-02-10T14:22:50.000Z</published>
    <updated>2022-05-13T07:37:45.866Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>当我们在写 HTTP 接口的时候，使用的是 Postman 进行接口调试，那么在写 gRPC 接口的时候，有没有类似于 Postman 的调试工具呢？</p><p><img src="/images/grpc/2_grpc_1.gif"></p><p>这是有的。</p><p>咱们一起看下 <code>grpcui</code>，源码地址：</p><p><a href="https://github.com/fullstorydev/grpcui">https://github.com/fullstorydev/grpcui</a></p><p>看下官方描述：</p><blockquote><p>grpcui is a command-line tool that lets you interact with gRPC servers via a browser. It’s sort of like Postman, but for gRPC APIs instead of REST.</p></blockquote><h2 id="写一个-gRPC-API"><a href="#写一个-gRPC-API" class="headerlink" title="写一个 gRPC API"></a>写一个 gRPC API</h2><p>端口：9901</p><p><code>.proto</code> 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;; // 指定 proto 版本</span><br><span class="line"></span><br><span class="line">package listen;     // 指定包名</span><br><span class="line"></span><br><span class="line">// 定义服务</span><br><span class="line">service Listen &#123;</span><br><span class="line"></span><br><span class="line">// 定义方法</span><br><span class="line">rpc ListenData(Request) returns (Response) &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Request 请求结构</span><br><span class="line">message Request &#123;</span><br><span class="line">string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Response 响应结构</span><br><span class="line">message Response &#123;</span><br><span class="line">    string message = 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很简单，这个大家一看就知道了。</p><ul><li>Service name 为 listen.Listen</li><li>Method name 为 ListenData</li></ul><p>再看下 ListenData 方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func (l *ListenController) ListenData(ctx context.Context, in *listen.Request) (*listen.Response, error) &#123;</span><br><span class="line">return &amp;listen.Response&#123;Message : fmt.Sprintf(&quot;[%s]&quot;, in.Name)&#125;, nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这表示，将 <code>Name</code> 直接返回。</p><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd listen &amp;&amp; go run main.go</span><br></pre></td></tr></table></figure><p>服务启动成功后，等待使用。</p><h2 id="grpcui-使用"><a href="#grpcui-使用" class="headerlink" title="grpcui 使用"></a>grpcui 使用</h2><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><p>根据官方 <code>README.md</code> 文档安装即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/fullstorydev/grpcui</span><br><span class="line">go install github.com/fullstorydev/grpcui/cmd/grpcui</span><br></pre></td></tr></table></figure><p>这时，在 <code>$GOPATH/bin</code> 目录下，生成一个 <code>grpcui</code> 可执行文件。</p><p>执行个命令，验证下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grpcui -help</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Usage:</span><br><span class="line">grpcui [flags] [address]</span><br><span class="line"></span><br><span class="line">......</span><br></pre></td></tr></table></figure><p>表示安装成功了。</p><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">grpcui -plaintext 127.0.0.1:9901</span><br><span class="line"></span><br><span class="line">Failed to compute set of methods to expose: server does not support the reflection API</span><br></pre></td></tr></table></figure><p>这种情况下，加个反射就可以了，在 listen 的 main.go 新增如下代码即可：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reflection.Register(s)</span><br></pre></td></tr></table></figure><p>在运行一次试试：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">grpcui -plaintext 127.0.0.1:9901</span><br><span class="line">gRPC Web UI available at http://127.0.0.1:63027/</span><br></pre></td></tr></table></figure><p>在浏览器中访问：<code>http://127.0.0.1:63027/</code></p><p><img src="/images/grpc/2_grpc_2.gif"></p><p>到这，我们看到 Service name、Method name 都出来了，传输参数直接在页面上进行操作即可。</p><p>当发起 Request “Tom”，也能获得 Response “Tom”。</p><p>当然，如果这个服务下面有多个 Service name，多个 Method name 也都会显示出来的，去试试吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;当我们在写 HTTP 接口的时候，使用的是 Postman 进行接口调试，那么在写 gRPC 接口的时候，有没有类似于 Postman 的调</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="gRPC" scheme="https://timmy6.github.io/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>gRPC Hello World</title>
    <link href="https://timmy6.github.io/2019/01/25/grpc-hello/"/>
    <id>https://timmy6.github.io/2019/01/25/grpc-hello/</id>
    <published>2019-01-25T13:22:50.000Z</published>
    <updated>2022-05-13T07:26:13.715Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>开始 gRPC 了，这篇文章学习使用 gRPC，输出一个 Hello World。</p><ul><li>用 Go 实现 gRPC 的服务端。</li><li>用 Go 实现 gRPC 的客户端。</li></ul><p>gRPC 支持 4 类服务方法，咱们这次实现 单项 RPC 和 服务端流式 RPC。</p><h2 id="四类服务方法"><a href="#四类服务方法" class="headerlink" title="四类服务方法"></a>四类服务方法</h2><p><strong>单项 RPC</strong></p><p>服务端发送一个请求给服务端，从服务端获取一个应答，就像一次普通的函数调用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc SayHello(HelloRequest) returns (HelloResponse)&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>服务端流式 RPC</strong></p><p>客户端发送一个请求给服务端，可获取一个数据流用来读取一系列消息。客户端从返回的数据流里一直读取直到没有更多消息为止。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse)&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>客户端流式 RPC</strong></p><p>客户端用提供的一个数据流写入并发送一系列消息给服务端。一旦客户端完成消息写入，就等待服务端读取这些消息并返回应答。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc LotsOfGreetings(stream HelloRequest) returns (HelloResponse) &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>双向流式 RPC</strong></p><p>两边都可以分别通过一个读写数据流来发送一系列消息。这两个数据流操作是相互独立的，所以客户端和服务端能按其希望的任意顺序读写，例如：服务端可以在写应答前等待所有的客户端消息，或者它可以先读一个消息再写一个消息，或者是读写相结合的其他方式。每个数据流里消息的顺序会被保持。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpc BidiHello(stream HelloRequest) returns (stream HelloResponse)&#123;&#125;</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><strong>安装 protobuf 编译器</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install protobuf</span><br></pre></td></tr></table></figure><p>验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protoc --version</span><br><span class="line"></span><br><span class="line">//输出：libprotoc 3.7.1</span><br></pre></td></tr></table></figure><p><strong>安装 Go protobuf 插件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go get -u github.com/golang/protobuf/proto</span><br><span class="line"></span><br><span class="line">go get -u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure><p><strong>安装 grpc-go</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go get -u google.golang.org/grpc</span><br></pre></td></tr></table></figure><h2 id="写个-Hello-World-服务"><a href="#写个-Hello-World-服务" class="headerlink" title="写个 Hello World 服务"></a>写个 Hello World 服务</h2><ul><li>编写服务端 <code>.proto</code> 文件</li><li>生成服务端 <code>.pb.go</code> 文件并同步给客户端</li><li>编写服务端提供接口的代码</li><li>编写客户端调用接口的代码</li></ul><p><strong>目录结构</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">├─ hello  -- 代码根目录</span><br><span class="line">│  ├─ go_client</span><br><span class="line">│     ├── main.go</span><br><span class="line">│     ├── proto</span><br><span class="line">│         ├── hello</span><br><span class="line">│            ├── hello.pb.go</span><br><span class="line">│  ├─ go_server</span><br><span class="line">│     ├── main.go</span><br><span class="line">│     ├── controller</span><br><span class="line">│         ├── hello_controller</span><br><span class="line">│            ├── hello_server.go</span><br><span class="line">│     ├── proto</span><br><span class="line">│         ├── hello</span><br><span class="line">│            ├── hello.pb.go</span><br><span class="line">│            ├── hello.proto</span><br></pre></td></tr></table></figure><p>这样创建目录是为了 go_client 和 go_server 后期可以拆成两个项目。</p><p><strong>编写服务端 hello.proto 文件</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;; // 指定 proto 版本</span><br><span class="line"></span><br><span class="line">package hello;     // 指定包名</span><br><span class="line"></span><br><span class="line">// 定义 Hello 服务</span><br><span class="line">service Hello &#123;</span><br><span class="line"></span><br><span class="line">// 定义 SayHello 方法</span><br><span class="line">rpc SayHello(HelloRequest) returns (HelloResponse) &#123;&#125;</span><br><span class="line"></span><br><span class="line">// 定义 LotsOfReplies 方法</span><br><span class="line">rpc LotsOfReplies(HelloRequest) returns (stream HelloResponse)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// HelloRequest 请求结构</span><br><span class="line">message HelloRequest &#123;</span><br><span class="line">string name = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// HelloResponse 响应结构</span><br><span class="line">message HelloResponse &#123;</span><br><span class="line">    string message = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>了解更多 Protobuf 语法，请查看：</p><p><a href="https://developers.google.com/protocol-buffers/">https://developers.google.com/protocol-buffers/</a></p><p><strong>生成服务端 <code>.pb.go</code></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">protoc -I . --go_out=plugins=grpc:. ./hello.proto</span><br></pre></td></tr></table></figure><p>同时将生成的 <code>hello.pb.go</code> 复制到客户端一份。</p><p>查看更多命令参数，执行 protoc，查看 OPTION 。</p><p><strong>编写服务端提供接口的代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// hello_server.go</span><br><span class="line">package hello_controller</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;golang.org/x/net/context&quot;</span><br><span class="line">&quot;hello/go_server/proto/hello&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type HelloController struct&#123;&#125;</span><br><span class="line"></span><br><span class="line">func (h *HelloController) SayHello(ctx context.Context, in *hello.HelloRequest) (*hello.HelloResponse, error) &#123;</span><br><span class="line">return &amp;hello.HelloResponse&#123;Message : fmt.Sprintf(&quot;%s&quot;, in.Name)&#125;, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (h *HelloController) LotsOfReplies(in *hello.HelloRequest, stream hello.Hello_LotsOfRepliesServer)  error &#123;</span><br><span class="line">for i := 0; i &lt; 10; i++ &#123;</span><br><span class="line">stream.Send(&amp;hello.HelloResponse&#123;Message : fmt.Sprintf(&quot;%s %s %d&quot;, in.Name, &quot;Reply&quot;, i)&#125;)</span><br><span class="line">&#125;</span><br><span class="line">return nil</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">// main.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;net&quot;</span><br><span class="line">&quot;hello/go_server/proto/hello&quot;</span><br><span class="line">&quot;hello/go_server/controller/hello_controller&quot;</span><br><span class="line">&quot;google.golang.org/grpc&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">Address = &quot;0.0.0.0:9090&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">listen, err := net.Listen(&quot;tcp&quot;, Address)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalf(&quot;Failed to listen: %v&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">s := grpc.NewServer()</span><br><span class="line"></span><br><span class="line">// 服务注册</span><br><span class="line">hello.RegisterHelloServer(s, &amp;hello_controller.HelloController&#123;&#125;)</span><br><span class="line"></span><br><span class="line">log.Println(&quot;Listen on &quot; + Address)</span><br><span class="line"></span><br><span class="line">if err := s.Serve(listen); err != nil &#123;</span><br><span class="line">log.Fatalf(&quot;Failed to serve: %v&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line">2019/07/28 17:51:20 Listen on 0.0.0.0:9090</span><br></pre></td></tr></table></figure><p><strong>编写客户端请求接口的代码</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;hello/go_client/proto/hello&quot;</span><br><span class="line">&quot;io&quot;</span><br><span class="line">&quot;log&quot;</span><br><span class="line">&quot;golang.org/x/net/context&quot;</span><br><span class="line">&quot;google.golang.org/grpc&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">// gRPC 服务地址</span><br><span class="line">Address = &quot;0.0.0.0:9090&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">conn, err := grpc.Dial(Address, grpc.WithInsecure())</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">defer conn.Close()</span><br><span class="line"></span><br><span class="line">// 初始化客户端</span><br><span class="line">c := hello.NewHelloClient(conn)</span><br><span class="line"></span><br><span class="line">// 调用 SayHello 方法</span><br><span class="line">res, err := c.SayHello(context.Background(), &amp;hello.HelloRequest&#123;Name: &quot;Hello World&quot;&#125;)</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Println(res.Message)</span><br><span class="line"></span><br><span class="line">// 调用 LotsOfReplies 方法</span><br><span class="line">stream, err := c.LotsOfReplies(context.Background(),&amp;hello.HelloRequest&#123;Name: &quot;Hello World&quot;&#125;)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for &#123;</span><br><span class="line">res, err := stream.Recv()</span><br><span class="line">if err == io.EOF &#123;</span><br><span class="line">break</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Printf(&quot;stream.Recv: %v&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log.Printf(&quot;%s&quot;, res.Message)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">go run main.go</span><br><span class="line"></span><br><span class="line">2019/07/28 17:58:13 Hello World</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 0</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 1</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 2</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 3</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 4</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 5</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 6</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 7</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 8</span><br><span class="line">2019/07/28 17:58:13 Hello World Reply 9</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;开始 gRPC 了，这篇文章学习使用 gRPC，输出一个 Hello World。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用 Go 实现 gRPC 的服</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="gRPC" scheme="https://timmy6.github.io/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>统一定义API错误码</title>
    <link href="https://timmy6.github.io/2019/01/15/error-code/"/>
    <id>https://timmy6.github.io/2019/01/15/error-code/</id>
    <published>2019-01-15T13:22:50.000Z</published>
    <updated>2022-05-13T07:22:22.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="改之前"><a href="#改之前" class="headerlink" title="改之前"></a>改之前</h2><p>在使用 <code>gin</code> 开发接口的时候，返回接口数据是这样写的。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">type response struct &#123;</span><br><span class="line">Code int         `json:&quot;code&quot;`</span><br><span class="line">Msg  string      `json:&quot;msg&quot;`</span><br><span class="line">Data interface&#123;&#125; `json:&quot;data&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// always return http.StatusOK</span><br><span class="line">c.JSON(http.StatusOK, response&#123;</span><br><span class="line">Code: 20101,</span><br><span class="line">Msg:  &quot;用户手机号不合法&quot;,</span><br><span class="line">Data: nil,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这种写法 <code>code</code>、<code>msg</code> 都是在哪需要返回在哪定义，没有进行统一管理。</p><h2 id="改之后"><a href="#改之后" class="headerlink" title="改之后"></a>改之后</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 比如，返回“用户手机号不合法”错误</span><br><span class="line">c.JSON(http.StatusOK, errno.ErrUserPhone.WithID(c.GetString(&quot;trace-id&quot;)))</span><br><span class="line"></span><br><span class="line">// 正确返回</span><br><span class="line">c.JSON(http.StatusOK, errno.OK.WithData(data).WithID(c.GetString(&quot;trace-id&quot;)))</span><br></pre></td></tr></table></figure><p><code>errno.ErrUserPhone</code>、<code>errno.OK</code> 表示自定义的错误码，下面会看到定义的地方。</p><p><code>.WithID()</code> 设置当前请求的唯一ID，也可以理解为链路ID，忽略也可以。</p><p><code>.WithData()</code> 设置成功时返回的数据。</p><p>下面分享下编写的 <code>errno</code> 包源码，非常简单，希望大家不要介意。</p><h2 id="errno-包源码"><a href="#errno-包源码" class="headerlink" title="errno 包源码"></a>errno 包源码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">// errno/errno.go</span><br><span class="line"></span><br><span class="line">package errno</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;encoding/json&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">var _ Error = (*err)(nil)</span><br><span class="line"></span><br><span class="line">type Error interface &#123;</span><br><span class="line">// i 为了避免被其他包实现</span><br><span class="line">i()</span><br><span class="line">// WithData 设置成功时返回的数据</span><br><span class="line">WithData(data interface&#123;&#125;) Error</span><br><span class="line">// WithID 设置当前请求的唯一ID</span><br><span class="line">WithID(id string) Error</span><br><span class="line">// ToString 返回 JSON 格式的错误详情</span><br><span class="line">ToString() string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type err struct &#123;</span><br><span class="line">Code int         `json:&quot;code&quot;`         // 业务编码</span><br><span class="line">Msg  string      `json:&quot;msg&quot;`          // 错误描述</span><br><span class="line">Data interface&#123;&#125; `json:&quot;data&quot;`         // 成功时返回的数据</span><br><span class="line">ID   string      `json:&quot;id,omitempty&quot;` // 当前请求的唯一ID，便于问题定位，忽略也可以</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func NewError(code int, msg string) Error &#123;</span><br><span class="line">return &amp;err&#123;</span><br><span class="line">Code: code,</span><br><span class="line">Msg:  msg,</span><br><span class="line">Data: nil,</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *err) i() &#123;&#125;</span><br><span class="line"></span><br><span class="line">func (e *err) WithData(data interface&#123;&#125;) Error &#123;</span><br><span class="line">e.Data = data</span><br><span class="line">return e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *err) WithID(id string) Error &#123;</span><br><span class="line">e.ID = id</span><br><span class="line">return e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// ToString 返回 JSON 格式的错误详情</span><br><span class="line">func (e *err) ToString() string &#123;</span><br><span class="line">err := &amp;struct &#123;</span><br><span class="line">Code int         `json:&quot;code&quot;`</span><br><span class="line">Msg  string      `json:&quot;msg&quot;`</span><br><span class="line">Data interface&#123;&#125; `json:&quot;data&quot;`</span><br><span class="line">ID   string      `json:&quot;id,omitempty&quot;`</span><br><span class="line">&#125;&#123;</span><br><span class="line">Code: e.Code,</span><br><span class="line">Msg:  e.Msg,</span><br><span class="line">Data: e.Data,</span><br><span class="line">ID:   e.ID,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">raw, _ := json.Marshal(err)</span><br><span class="line">return string(raw)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// errno/code.go</span><br><span class="line"></span><br><span class="line">package errno</span><br><span class="line"></span><br><span class="line">var (</span><br><span class="line">// OK</span><br><span class="line">OK = NewError(0, &quot;OK&quot;)</span><br><span class="line"></span><br><span class="line">// 服务级错误码</span><br><span class="line">ErrServer    = NewError(10001, &quot;服务异常，请联系管理员&quot;)</span><br><span class="line">ErrParam     = NewError(10002, &quot;参数有误&quot;)</span><br><span class="line">ErrSignParam = NewError(10003, &quot;签名参数有误&quot;)</span><br><span class="line"></span><br><span class="line">// 模块级错误码 - 用户模块</span><br><span class="line">ErrUserPhone   = NewError(20101, &quot;用户手机号不合法&quot;)</span><br><span class="line">ErrUserCaptcha = NewError(20102, &quot;用户验证码有误&quot;)</span><br><span class="line"></span><br><span class="line">// ...</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="错误码规则"><a href="#错误码规则" class="headerlink" title="错误码规则"></a>错误码规则</h2><ul><li>错误码需在 <code>code.go</code> 文件中定义。</li><li>错误码需为 &gt; 0 的数，反之表示正确。</li></ul><h4 id="错误码为-5-位数"><a href="#错误码为-5-位数" class="headerlink" title="错误码为 5 位数"></a>错误码为 5 位数</h4><table><thead><tr><th align="left">1</th><th align="left">01</th><th align="left">01</th></tr></thead><tbody><tr><td align="left">服务级错误码</td><td align="left">模块级错误码</td><td align="left">具体错误码</td></tr></tbody></table><ul><li>服务级别错误码：1 位数进行表示，比如 1 为系统级错误；2 为普通错误，通常是由用户非法操作引起。</li><li>模块级错误码：2 位数进行表示，比如 01 为用户模块；02 为订单模块。</li><li>具体错误码：2 位数进行表示，比如 01 为手机号不合法；02 为验证码输入错误。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;改之前&quot;&gt;&lt;a href=&quot;#改之前&quot; class=&quot;headerlink&quot; title=&quot;改之前&quot;&gt;&lt;/a&gt;改之前&lt;/h2&gt;&lt;p&gt;在使用 &lt;code&gt;gin&lt;/code&gt; 开发接口的时候，返回接口数据是这样写的。&lt;/p&gt;
&lt;figure class=&quot;highl</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="gin框架" scheme="https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>自定义错误处理</title>
    <link href="https://timmy6.github.io/2019/01/10/custom-err/"/>
    <id>https://timmy6.github.io/2019/01/10/custom-err/</id>
    <published>2019-01-10T13:22:50.000Z</published>
    <updated>2022-05-13T07:16:06.972Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>开始今天的文章，为什么要自定义错误处理？默认的错误处理方式是什么？</p><p>那好，咱们就先说下默认的错误处理。</p><p>默认的错误处理是 <code>errors.New(&quot;错误信息&quot;)</code>，这个信息通过 error 类型的返回值进行返回。</p><p>举个简单的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func hello(name string) (str string, err error) &#123;</span><br><span class="line">if name == &quot;&quot; &#123;</span><br><span class="line">err = errors.New(&quot;name 不能为空&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">str = fmt.Sprintf(&quot;hello: %s&quot;, name)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当调用这个方法时：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var name = &quot;&quot;</span><br><span class="line">str, err :=  hello(name)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这就是默认的错误处理，下面还会用这个例子进行说。</p><p>这个默认的错误处理，只是得到了一个错误信息的字符串。</p><p>然而…</p><p>我还想得到发生错误时的 <code>时间</code>、<code>文件名</code>、<code>方法名</code>、<code>行号</code> 等信息。</p><p>我还想得到错误时进行告警，比如 <code>短信告警</code>、<code>邮件告警</code>、<code>微信告警</code> 等。</p><p>我还想调用的时候，不那么复杂，就和默认错误处理类似，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alarm.WeChat(&quot;错误信息&quot;)</span><br><span class="line">return</span><br></pre></td></tr></table></figure><p>这样，我们就得到了我们想要的信息（<code>时间</code>、<code>文件名</code>、<code>方法名</code>、<code>行号</code>），并通过 <code>微信</code> 的方式进行告警通知我们。</p><p>同理，<code>alarm.Email(&quot;错误信息&quot;)</code>、<code>alarm.Sms(&quot;错误信息&quot;)</code> 我们得到的信息是一样的，只是告警方式不同而已。</p><p>还要保证，我们业务逻辑中，获取错误的时候，只获取错误信息即可。</p><p>上面这些想出来的，就是今天要实现的，自定义错误处理，我们就实现之前，先说下 Go 的错误处理。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;errors&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func hello(name string) (str string, err error) &#123;</span><br><span class="line">if name == &quot;&quot; &#123;</span><br><span class="line">err = errors.New(&quot;name 不能为空&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">str = fmt.Sprintf(&quot;hello: %s&quot;, name)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">var name = &quot;&quot;</span><br><span class="line">fmt.Println(&quot;param:&quot;, name)</span><br><span class="line"></span><br><span class="line">str, err := hello(name)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(err.Error())</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">param: Tom</span><br><span class="line">hello: Tom</span><br></pre></td></tr></table></figure><p>当 name &#x3D; “” 时，输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">param:</span><br><span class="line">name 不能为空</span><br></pre></td></tr></table></figure><p>建议每个函数都要有错误处理，error 应该为最后一个返回值。</p><p>咱们一起看下官方 errors.go</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">// Copyright 2011 The Go Authors. All rights reserved.</span><br><span class="line">// Use of this source code is governed by a BSD-style</span><br><span class="line">// license that can be found in the LICENSE file.</span><br><span class="line"></span><br><span class="line">// Package errors implements functions to manipulate errors.</span><br><span class="line">package errors</span><br><span class="line"></span><br><span class="line">// New returns an error that formats as the given text.</span><br><span class="line">func New(text string) error &#123;</span><br><span class="line">return &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// errorString is a trivial implementation of error.</span><br><span class="line">type errorString struct &#123;</span><br><span class="line">s string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *errorString) Error() string &#123;</span><br><span class="line">return e.s</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码，并不复杂，参照上面的，咱们进行写一个自定义错误处理。</p><h2 id="自定义错误处理"><a href="#自定义错误处理" class="headerlink" title="自定义错误处理"></a>自定义错误处理</h2><p>咱们定义一个 alarm.go，用于处理告警。</p><p>废话不多说，直接看代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">package alarm</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;encoding/json&quot;</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;ginDemo/common/function&quot;</span><br><span class="line">&quot;path/filepath&quot;</span><br><span class="line">&quot;runtime&quot;</span><br><span class="line">&quot;strings&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type errorString struct &#123;</span><br><span class="line">s string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">type errorInfo struct &#123;</span><br><span class="line">Time     string `json:&quot;time&quot;`</span><br><span class="line">Alarm    string `json:&quot;alarm&quot;`</span><br><span class="line">Message  string `json:&quot;message&quot;`</span><br><span class="line">Filename string `json:&quot;filename&quot;`</span><br><span class="line">Line     int    `json:&quot;line&quot;`</span><br><span class="line">Funcname string `json:&quot;funcname&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (e *errorString) Error() string &#123;</span><br><span class="line">return e.s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func New (text string) error &#123;</span><br><span class="line">alarm(&quot;INFO&quot;, text)</span><br><span class="line">return &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 发邮件</span><br><span class="line">func Email (text string) error &#123;</span><br><span class="line">alarm(&quot;EMAIL&quot;, text)</span><br><span class="line">return &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 发短信</span><br><span class="line">func Sms (text string) error &#123;</span><br><span class="line">alarm(&quot;SMS&quot;, text)</span><br><span class="line">return &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 发微信</span><br><span class="line">func WeChat (text string) error &#123;</span><br><span class="line">alarm(&quot;WX&quot;, text)</span><br><span class="line">return &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 告警方法</span><br><span class="line">func  alarm(level string, str string) &#123;</span><br><span class="line">// 当前时间</span><br><span class="line">currentTime := function.GetTimeStr()</span><br><span class="line"></span><br><span class="line">// 定义 文件名、行号、方法名</span><br><span class="line">fileName, line, functionName := &quot;?&quot;, 0 , &quot;?&quot;</span><br><span class="line"></span><br><span class="line">pc, fileName, line, ok := runtime.Caller(2)</span><br><span class="line">if ok &#123;</span><br><span class="line">functionName = runtime.FuncForPC(pc).Name()</span><br><span class="line">functionName = filepath.Ext(functionName)</span><br><span class="line">functionName = strings.TrimPrefix(functionName, &quot;.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var msg = errorInfo &#123;</span><br><span class="line">Time     : currentTime,</span><br><span class="line">Alarm    : level,</span><br><span class="line">Message  : str,</span><br><span class="line">Filename : fileName,</span><br><span class="line">Line     : line,</span><br><span class="line">Funcname : functionName,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsons, errs := json.Marshal(msg)</span><br><span class="line"></span><br><span class="line">if errs != nil &#123;</span><br><span class="line">fmt.Println(&quot;json marshal error:&quot;, errs)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">errorJsonInfo := string(jsons)</span><br><span class="line"></span><br><span class="line">fmt.Println(errorJsonInfo)</span><br><span class="line"></span><br><span class="line">if level == &quot;EMAIL&quot; &#123;</span><br><span class="line">// 执行发邮件</span><br><span class="line"></span><br><span class="line">&#125; else if level == &quot;SMS&quot; &#123;</span><br><span class="line">// 执行发短信</span><br><span class="line"></span><br><span class="line">&#125; else if level == &quot;WX&quot; &#123;</span><br><span class="line">// 执行发微信</span><br><span class="line"></span><br><span class="line">&#125; else if level == &quot;INFO&quot; &#123;</span><br><span class="line">// 执行记日志</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看下如何调用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package v1</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;ginDemo/common/alarm&quot;</span><br><span class="line">&quot;ginDemo/entity&quot;</span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func AddProduct(c *gin.Context)  &#123;</span><br><span class="line">// 获取 Get 参数</span><br><span class="line">name := c.Query(&quot;name&quot;)</span><br><span class="line"></span><br><span class="line">var res = entity.Result&#123;&#125;</span><br><span class="line"></span><br><span class="line">str, err := hello(name)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">res.SetCode(entity.CODE_ERROR)</span><br><span class="line">res.SetMessage(err.Error())</span><br><span class="line">c.JSON(http.StatusOK, res)</span><br><span class="line">c.Abort()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res.SetCode(entity.CODE_SUCCESS)</span><br><span class="line">res.SetMessage(str)</span><br><span class="line">c.JSON(http.StatusOK, res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func hello(name string) (str string, err error) &#123;</span><br><span class="line">if name == &quot;&quot; &#123;</span><br><span class="line">err = alarm.WeChat(&quot;name 不能为空&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">str = fmt.Sprintf(&quot;hello: %s&quot;, name)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问：<code>http://localhost:8080/v1/product/add?name=a</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: 1,</span><br><span class="line">    &quot;msg&quot;: &quot;hello: a&quot;,</span><br><span class="line">    &quot;data&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>未抛出错误，不会输出信息。</p><p>访问：<code>http://localhost:8080/v1/product/add</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;code&quot;: -1,</span><br><span class="line">    &quot;msg&quot;: &quot;name 不能为空&quot;,</span><br><span class="line">    &quot;data&quot;: null</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抛出了错误，输出信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;time&quot;:&quot;2019-07-23 22:19:17&quot;,&quot;alarm&quot;:&quot;WX&quot;,&quot;message&quot;:&quot;name 不能为空&quot;,&quot;filename&quot;:&quot;绝对路径/ginDemo/router/v1/product.go&quot;,&quot;line&quot;:33,&quot;funcname&quot;:&quot;hello&quot;&#125;</span><br></pre></td></tr></table></figure><p>这只是个例子，大家可以在一些复杂的业务逻辑判断场景中使用自定义错误处理”。</p><p>到这里，报错时我们收到了 <code>时间</code>、<code>错误信息</code>、<code>文件名</code>、<code>行号</code>、<code>方法名</code> 了。</p><p>调用起来，也比较简单。</p><p>虽然标记了告警方式，还是没有进行告警通知呀。</p><p>我想说，在这里存储数据到队列中，再执行异步任务具体去消耗，这块就不实现了，大家可以去完善。</p><p>读取 <code>文件名</code>、<code>方法名</code>、<code>行号</code> 使用的是 <code>runtime.Caller()</code>。</p><p>我们还知道，Go 有 <code>panic</code> 和 <code>recover</code>，它们是干什么的呢，接下来咱们就说说。</p><h2 id="panic-和-recover"><a href="#panic-和-recover" class="headerlink" title="panic 和 recover"></a>panic 和 recover</h2><p>当程序不能继续运行的时候，才应该使用 panic 抛出错误。</p><p>当程序发生 panic 后，在 defer(延迟函数) 内部可以调用 recover 进行控制，不过有个前提条件，只有在相同的 Go 协程中才可以。</p><p>panic 分两个，一种是有意抛出的，一种是无意的写程序马虎造成的，咱们一个个说。</p><p>有意抛出的 panic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;-- 1 --&quot;)</span><br><span class="line"></span><br><span class="line">defer func() &#123;</span><br><span class="line">if r := recover(); r != nil &#123;</span><br><span class="line">fmt.Printf(&quot;panic: %s\n&quot;, r)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;-- 2 --&quot;)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">panic(&quot;i am panic&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 1 --</span><br><span class="line">panic: i am panic</span><br><span class="line">-- 2 --</span><br></pre></td></tr></table></figure><p>无意抛出的 panic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;-- 1 --&quot;)</span><br><span class="line"></span><br><span class="line">defer func() &#123;</span><br><span class="line">if r := recover(); r != nil &#123;</span><br><span class="line">fmt.Printf(&quot;panic: %s\n&quot;, r)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;-- 2 --&quot;)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">var slice = [] int &#123;1, 2, 3, 4, 5&#125;</span><br><span class="line"></span><br><span class="line">slice[6] = 6</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-- 1 --</span><br><span class="line">panic: runtime error: index out of range</span><br><span class="line">-- 2 --</span><br></pre></td></tr></table></figure><p>上面的两个我们都通过 <code>recover</code> 捕获到了，那我们如何在 Gin 框架中使用呢？如果收到 <code>panic</code> 时，也想进行告警怎么实现呢？ </p><p>既然想实现告警，先在 ararm.go 中定义一个 <code>Panic()</code> 方法，当项目发生 <code>panic</code> 异常时，调用这个方法，这样就实现告警了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// Panic 异常</span><br><span class="line">func Panic (text string) error &#123;</span><br><span class="line">alarm(&quot;PANIC&quot;, text)</span><br><span class="line">return &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们怎么捕获到呢？</p><p>使用中间件进行捕获，写一个 <code>recover</code> 中间件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package recover</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;ginDemo/common/alarm&quot;</span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func Recover()  gin.HandlerFunc &#123;</span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">if r := recover(); r != nil &#123;</span><br><span class="line">alarm.Panic(fmt.Sprintf(&quot;%s&quot;, r))</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">c.Next()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由调用中间件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">r.Use(logger.LoggerToFile(), recover.Recover())</span><br><span class="line"></span><br><span class="line">//Use 可以传递多个中间件。</span><br></pre></td></tr></table></figure><p>验证下吧，咱们先抛出两个异常，看看能否捕获到？</p><p>还是修改 product.go 这个文件吧。</p><p>有意抛出 panic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">package v1</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;ginDemo/entity&quot;</span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">&quot;net/http&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func AddProduct(c *gin.Context)  &#123;</span><br><span class="line">// 获取 Get 参数</span><br><span class="line">name := c.Query(&quot;name&quot;)</span><br><span class="line"></span><br><span class="line">var res = entity.Result&#123;&#125;</span><br><span class="line"></span><br><span class="line">str, err := hello(name)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">res.SetCode(entity.CODE_ERROR)</span><br><span class="line">res.SetMessage(err.Error())</span><br><span class="line">c.JSON(http.StatusOK, res)</span><br><span class="line">c.Abort()</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">res.SetCode(entity.CODE_SUCCESS)</span><br><span class="line">res.SetMessage(str)</span><br><span class="line">c.JSON(http.StatusOK, res)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func hello(name string) (str string, err error) &#123;</span><br><span class="line">if name == &quot;&quot; &#123;</span><br><span class="line">// 有意抛出 panic</span><br><span class="line">panic(&quot;i am panic&quot;)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">str = fmt.Sprintf(&quot;hello: %s&quot;, name)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问：<code>http://localhost:8080/v1/product/add</code></p><p>界面是空白的。</p><p>抛出了异常，输出信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;time&quot;:&quot;2019-07-23 22:42:37&quot;,&quot;alarm&quot;:&quot;PANIC&quot;,&quot;message&quot;:&quot;i am panic&quot;,&quot;filename&quot;:&quot;绝对路径/ginDemo/middleware/recover/recover.go&quot;,&quot;line&quot;:13,&quot;funcname&quot;:&quot;1&quot;&#125;</span><br></pre></td></tr></table></figure><p>很显然，定位的文件名、方法名、行号不是我们想要的。</p><p>需要调整 <code>runtime.Caller(2)</code>，这个代码在 <code>alarm.go 的 alarm</code> 方法中。</p><p>将 2 调整成 4 ，看下输出信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;time&quot;:&quot;2019-07-23 22:45:24&quot;,&quot;alarm&quot;:&quot;PANIC&quot;,&quot;message&quot;:&quot;i am panic&quot;,&quot;filename&quot;:&quot;绝对路径/ginDemo/router/v1/product.go&quot;,&quot;line&quot;:33,&quot;funcname&quot;:&quot;hello&quot;&#125;</span><br></pre></td></tr></table></figure><p>这就对了。</p><p>无意抛出 panic：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 上面代码不变</span><br><span class="line"></span><br><span class="line">func hello(name string) (str string, err error) &#123;</span><br><span class="line">if name == &quot;&quot; &#123;</span><br><span class="line">// 无意抛出 panic</span><br><span class="line">var slice = [] int &#123;1, 2, 3, 4, 5&#125;</span><br><span class="line">slice[6] = 6</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">str = fmt.Sprintf(&quot;hello: %s&quot;, name)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问：<code>http://localhost:8080/v1/product/add</code></p><p>界面是空白的。</p><p>抛出了异常，输出信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;time&quot;:&quot;2019-07-23 22:50:06&quot;,&quot;alarm&quot;:&quot;PANIC&quot;,&quot;message&quot;:&quot;runtime error: index out of range&quot;,&quot;filename&quot;:&quot;绝对路径/runtime/panic.go&quot;,&quot;line&quot;:44,&quot;funcname&quot;:&quot;panicindex&quot;&#125;</span><br></pre></td></tr></table></figure><p>很显然，定位的文件名、方法名、行号也不是我们想要的。</p><p>将 4 调整成 5 ，看下输出信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;time&quot;:&quot;2019-07-23 22:55:27&quot;,&quot;alarm&quot;:&quot;PANIC&quot;,&quot;message&quot;:&quot;runtime error: index out of range&quot;,&quot;filename&quot;:&quot;绝对路径/ginDemo/router/v1/product.go&quot;,&quot;line&quot;:34,&quot;funcname&quot;:&quot;hello&quot;&#125;</span><br></pre></td></tr></table></figure><p>这就对了。</p><p>奇怪了，这是为什么？</p><p>在这里，有必要说下 <code>runtime.Caller(skip)</code> 了。</p><p>skip 指的调用的深度。</p><p>为 0 时，打印当前调用文件及行数。</p><p>为 1 时，打印上级调用的文件及行数。</p><p>依次类推…</p><p>在这块，调用的时候需要注意下，我现在还没有好的解决方案。</p><p>我是将 skip（调用深度），当一个参数传递进去。</p><p>比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 发微信</span><br><span class="line">func WeChat (text string) error &#123;</span><br><span class="line">alarm(&quot;WX&quot;, text, 2)</span><br><span class="line">return &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Panic 异常</span><br><span class="line">func Panic (text string) error &#123;</span><br><span class="line">alarm(&quot;PANIC&quot;, text, 5)</span><br><span class="line">return &amp;errorString&#123;text&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的代码就不贴了。</p><p>但是，有意抛出 Panic 和 无意抛出 Panic 的调用深度又不同，怎么办？</p><p>1、尽量将有意抛出的 Panic 改成抛出错误的方式。</p><p>2、想其他办法搞定它。</p><p>就到这吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;开始今天的文章，为什么要自定义错误处理？默认的错误处理方式是什么？&lt;/p&gt;
&lt;p&gt;那好，咱们就先说下默认的错误处理。&lt;/p&gt;
&lt;p&gt;默认的错</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="gin框架" scheme="https://timmy6.github.io/tags/gin%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>gin日志记录</title>
    <link href="https://timmy6.github.io/2019/01/05/gin-log/"/>
    <id>https://timmy6.github.io/2019/01/05/gin-log/</id>
    <published>2019-01-05T13:22:50.000Z</published>
    <updated>2022-05-11T09:47:16.798Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>上篇文章分享了 Gin 框架的路由配置，这篇文章分享日志记录。</p><p>查了很多资料，Go 的日志记录用的最多的还是 <code>github.com/sirupsen/logrus</code>。</p><blockquote><p>Logrus is a structured logger for Go (golang), completely API compatible with the standard library logger.</p></blockquote><p>Gin 框架的日志默认只会在控制台输出，咱们利用 <code>Logrus</code> 封装一个中间件，将日志记录到文件中。</p><p>这篇文章就是学习和使用 <code>Logrus</code> 。</p><h2 id="日志格式"><a href="#日志格式" class="headerlink" title="日志格式"></a>日志格式</h2><p>比如，我们约定日志格式为 Text，包含字段如下：</p><p><code>请求时间</code>、<code>日志级别</code>、<code>状态码</code>、<code>执行时间</code>、<code>请求IP</code>、<code>请求方式</code>、<code>请求路由</code>。</p><p>接下来，咱们利用 <code>Logrus</code> 实现它。</p><h2 id="Logrus-使用"><a href="#Logrus-使用" class="headerlink" title="Logrus 使用"></a>Logrus 使用</h2><p>用 <code>dep</code> 方式进行安装。</p><p>在 <code>Gopkg.toml</code> 文件新增：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[[constraint]]</span><br><span class="line">  name = &quot;github.com/sirupsen/logrus&quot;</span><br><span class="line">  version = &quot;1.4.2&quot;</span><br></pre></td></tr></table></figure><p>在项目中导入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import &quot;github.com/sirupsen/logrus&quot;</span><br></pre></td></tr></table></figure><p>在项目命令行执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dep ensure</span><br></pre></td></tr></table></figure><p>这时，在 <code>vendor/github.com/</code> 目录中就会看到 <code>sirupsen</code> 目录。</p><p>准备上手用了，上手之前咱们先规划一下，将这个功能设置成一个中间件，比如：<code>logger.go</code>。</p><p>日志可以记录到 File 中，定义一个 <code>LoggerToFile</code> 方法。</p><p>日志可以记录到 MongoDB 中，定义一个 <code>LoggerToMongo</code> 方法。</p><p>日志可以记录到 ES 中，定义一个 <code>LoggerToES</code> 方法。</p><p>日志可以记录到 MQ 中，定义一个 <code>LoggerToMQ</code> 方法。</p><p>…</p><p>这次咱们先实现记录到文件， 实现 <code>LoggerToFile</code> 方法，其他的可以根据自己的需求进行实现。</p><p>这个 <code>logger</code> 中间件，创建好了，可以任意在其他项目中进行迁移使用。</p><p>废话不多说，直接看代码。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line">package middleware</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;ginDemo/config&quot;</span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">&quot;github.com/sirupsen/logrus&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;path&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 日志记录到文件</span><br><span class="line">func LoggerToFile() gin.HandlerFunc &#123;</span><br><span class="line"></span><br><span class="line">logFilePath := config.Log_FILE_PATH</span><br><span class="line">logFileName := config.LOG_FILE_NAME</span><br><span class="line"></span><br><span class="line">//日志文件</span><br><span class="line">fileName := path.Join(logFilePath, logFileName)</span><br><span class="line"></span><br><span class="line">//写入文件</span><br><span class="line">src, err := os.OpenFile(fileName, os.O_APPEND|os.O_WRONLY, os.ModeAppend)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;err&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实例化</span><br><span class="line">logger := logrus.New()</span><br><span class="line"></span><br><span class="line">//设置输出</span><br><span class="line">logger.Out = src</span><br><span class="line"></span><br><span class="line">//设置日志级别</span><br><span class="line">logger.SetLevel(logrus.DebugLevel)</span><br><span class="line"></span><br><span class="line">//设置日志格式</span><br><span class="line">logger.SetFormatter(&amp;logrus.TextFormatter&#123;&#125;)</span><br><span class="line"></span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line">// 开始时间</span><br><span class="line">startTime := time.Now()</span><br><span class="line"></span><br><span class="line">// 处理请求</span><br><span class="line">c.Next()</span><br><span class="line"></span><br><span class="line">// 结束时间</span><br><span class="line">endTime := time.Now()</span><br><span class="line"></span><br><span class="line">// 执行时间</span><br><span class="line">latencyTime := endTime.Sub(startTime)</span><br><span class="line"></span><br><span class="line">// 请求方式</span><br><span class="line">reqMethod := c.Request.Method</span><br><span class="line"></span><br><span class="line">// 请求路由</span><br><span class="line">reqUri := c.Request.RequestURI</span><br><span class="line"></span><br><span class="line">// 状态码</span><br><span class="line">statusCode := c.Writer.Status()</span><br><span class="line"></span><br><span class="line">// 请求IP</span><br><span class="line">clientIP := c.ClientIP()</span><br><span class="line"></span><br><span class="line">// 日志格式</span><br><span class="line">logger.Infof(&quot;| %3d | %13v | %15s | %s | %s |&quot;,</span><br><span class="line">statusCode,</span><br><span class="line">latencyTime,</span><br><span class="line">clientIP,</span><br><span class="line">reqMethod,</span><br><span class="line">reqUri,</span><br><span class="line">)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 日志记录到 MongoDB</span><br><span class="line">func LoggerToMongo() gin.HandlerFunc &#123;</span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 日志记录到 ES</span><br><span class="line">func LoggerToES() gin.HandlerFunc &#123;</span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 日志记录到 MQ</span><br><span class="line">func LoggerToMQ() gin.HandlerFunc &#123;</span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>日志中间件写好了，怎么调用呢？</p><p>只需在 main.go 中新增：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">engine := gin.Default() //在这行后新增</span><br><span class="line">engine.Use(middleware.LoggerToFile())</span><br></pre></td></tr></table></figure><p>运行一下，看看日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time=&quot;2019-07-17T22:10:45+08:00&quot; level=info msg=&quot;| 200 |      27.698µs |             ::1 | GET | /v1/product/add?name=a&amp;price=10 |&quot;</span><br><span class="line">time=&quot;2019-07-17T22:10:46+08:00&quot; level=info msg=&quot;| 200 |      27.239µs |             ::1 | GET | /v1/product/add?name=a&amp;price=10 |&quot;</span><br></pre></td></tr></table></figure><p><strong>这个 <code>time=&quot;2019-07-17T22:10:45+08:00&quot;</code>  ，这个时间格式不是咱们想要的，怎么办？</strong></p><p>时间需要格式化一下，修改 <code>logger.SetFormatter</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置日志格式</span><br><span class="line">logger.SetFormatter(&amp;logrus.TextFormatter&#123;</span><br><span class="line">TimestampFormat:&quot;2006-01-02 15:04:05&quot;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行以下，再看日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">time=&quot;2019-07-17 22:15:57&quot; level=info msg=&quot;| 200 |     185.027µs |             ::1 | GET | /v1/product/add?name=a&amp;price=10 |&quot;</span><br><span class="line">time=&quot;2019-07-17 22:15:58&quot; level=info msg=&quot;| 200 |      56.989µs |             ::1 | GET | /v1/product/add?name=a&amp;price=10 |&quot;</span><br></pre></td></tr></table></figure><p>时间变得正常了。</p><p><strong>我不喜欢文本格式，喜欢 JSON 格式，怎么办？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//设置日志格式</span><br><span class="line">logger.SetFormatter(&amp;logrus.JSONFormatter&#123;</span><br><span class="line">TimestampFormat:&quot;2006-01-02 15:04:05&quot;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>执行以下，再看日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;| 200 |       24.78µs |             ::1 | GET | /v1/product/add?name=a\u0026price=10 |&quot;,&quot;time&quot;:&quot;2019-07-17 22:23:55&quot;&#125;</span><br><span class="line">&#123;&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;| 200 |      26.946µs |             ::1 | GET | /v1/product/add?name=a\u0026price=10 |&quot;,&quot;time&quot;:&quot;2019-07-17 22:23:56&quot;&#125;</span><br></pre></td></tr></table></figure><p><strong>msg 信息太多，不方便看，怎么办？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 日志格式</span><br><span class="line">logger.WithFields(logrus.Fields&#123;</span><br><span class="line">&quot;status_code&quot;  : statusCode,</span><br><span class="line">&quot;latency_time&quot; : latencyTime,</span><br><span class="line">&quot;client_ip&quot;    : clientIP,</span><br><span class="line">&quot;req_method&quot;   : reqMethod,</span><br><span class="line">&quot;req_uri&quot;      : reqUri,</span><br><span class="line">&#125;).Info()</span><br></pre></td></tr></table></figure><p>执行以下，再看日志：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;client_ip&quot;:&quot;::1&quot;,&quot;latency_time&quot;:26681,&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;&quot;,&quot;req_method&quot;:&quot;GET&quot;,&quot;req_uri&quot;:&quot;/v1/product/add?name=a\u0026price=10&quot;,&quot;status_code&quot;:200,&quot;time&quot;:&quot;2019-07-17 22:37:54&quot;&#125;</span><br><span class="line">&#123;&quot;client_ip&quot;:&quot;::1&quot;,&quot;latency_time&quot;:24315,&quot;level&quot;:&quot;info&quot;,&quot;msg&quot;:&quot;&quot;,&quot;req_method&quot;:&quot;GET&quot;,&quot;req_uri&quot;:&quot;/v1/product/add?name=a\u0026price=10&quot;,&quot;status_code&quot;:200,&quot;time&quot;:&quot;2019-07-17 22:37:55&quot;&#125;</span><br></pre></td></tr></table></figure><p>说明一下：<code>time</code>、<code>msg</code>、<code>level</code> 这些参数是 logrus 自动加上的。</p><p><strong>logrus 支持输出文件名和行号吗？</strong></p><p>不支持，作者的回复是太耗性能。</p><p>不过网上也有人通过 Hook 的方式实现了，选择在生产环境使用的时候，记得做性能测试。</p><p><strong>logrus 支持日志分割吗？</strong></p><p>不支持，但有办法实现它。</p><p>1、可以利用 <code>Linux logrotate</code>，统一由运维进行处理。</p><p>2、可以利用 <code>file-rotatelogs</code> 实现。</p><p>需要导入包：</p><p><code>github.com/lestrrat-go/file-rotatelogs</code></p><p><code>github.com/rifflock/lfshook</code></p><p>奉上完整代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">package middleware</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line">&quot;ginDemo/config&quot;</span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">rotatelogs &quot;github.com/lestrrat-go/file-rotatelogs&quot;</span><br><span class="line">&quot;github.com/rifflock/lfshook&quot;</span><br><span class="line">&quot;github.com/sirupsen/logrus&quot;</span><br><span class="line">&quot;os&quot;</span><br><span class="line">&quot;path&quot;</span><br><span class="line">&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">// 日志记录到文件</span><br><span class="line">func LoggerToFile() gin.HandlerFunc &#123;</span><br><span class="line"></span><br><span class="line">logFilePath := config.Log_FILE_PATH</span><br><span class="line">logFileName := config.LOG_FILE_NAME</span><br><span class="line"></span><br><span class="line">// 日志文件</span><br><span class="line">fileName := path.Join(logFilePath, logFileName)</span><br><span class="line"></span><br><span class="line">// 写入文件</span><br><span class="line">src, err := os.OpenFile(fileName, os.O_APPEND|os.O_WRONLY, os.ModeAppend)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(&quot;err&quot;, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 实例化</span><br><span class="line">logger := logrus.New()</span><br><span class="line"></span><br><span class="line">// 设置输出</span><br><span class="line">logger.Out = src</span><br><span class="line"></span><br><span class="line">// 设置日志级别</span><br><span class="line">logger.SetLevel(logrus.DebugLevel)</span><br><span class="line"></span><br><span class="line">// 设置 rotatelogs</span><br><span class="line">logWriter, err := rotatelogs.New(</span><br><span class="line">// 分割后的文件名称</span><br><span class="line">fileName + &quot;.%Y%m%d.log&quot;,</span><br><span class="line"></span><br><span class="line">// 生成软链，指向最新日志文件</span><br><span class="line">rotatelogs.WithLinkName(fileName),</span><br><span class="line"></span><br><span class="line">// 设置最大保存时间(7天)</span><br><span class="line">rotatelogs.WithMaxAge(7*24*time.Hour),</span><br><span class="line"></span><br><span class="line">// 设置日志切割时间间隔(1天)</span><br><span class="line">rotatelogs.WithRotationTime(24*time.Hour),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">writeMap := lfshook.WriterMap&#123;</span><br><span class="line">logrus.InfoLevel:  logWriter,</span><br><span class="line">logrus.FatalLevel: logWriter,</span><br><span class="line">logrus.DebugLevel: logWriter,</span><br><span class="line">logrus.WarnLevel:  logWriter,</span><br><span class="line">logrus.ErrorLevel: logWriter,</span><br><span class="line">logrus.PanicLevel: logWriter,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lfHook := lfshook.NewHook(writeMap, &amp;logrus.JSONFormatter&#123;</span><br><span class="line">TimestampFormat:&quot;2006-01-02 15:04:05&quot;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 新增 Hook</span><br><span class="line">logger.AddHook(lfHook)</span><br><span class="line"></span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line">// 开始时间</span><br><span class="line">startTime := time.Now()</span><br><span class="line"></span><br><span class="line">// 处理请求</span><br><span class="line">c.Next()</span><br><span class="line"></span><br><span class="line">// 结束时间</span><br><span class="line">endTime := time.Now()</span><br><span class="line"></span><br><span class="line">// 执行时间</span><br><span class="line">latencyTime := endTime.Sub(startTime)</span><br><span class="line"></span><br><span class="line">// 请求方式</span><br><span class="line">reqMethod := c.Request.Method</span><br><span class="line"></span><br><span class="line">// 请求路由</span><br><span class="line">reqUri := c.Request.RequestURI</span><br><span class="line"></span><br><span class="line">// 状态码</span><br><span class="line">statusCode := c.Writer.Status()</span><br><span class="line"></span><br><span class="line">// 请求IP</span><br><span class="line">clientIP := c.ClientIP()</span><br><span class="line"></span><br><span class="line">// 日志格式</span><br><span class="line">logger.WithFields(logrus.Fields&#123;</span><br><span class="line">&quot;status_code&quot;  : statusCode,</span><br><span class="line">&quot;latency_time&quot; : latencyTime,</span><br><span class="line">&quot;client_ip&quot;    : clientIP,</span><br><span class="line">&quot;req_method&quot;   : reqMethod,</span><br><span class="line">&quot;req_uri&quot;      : reqUri,</span><br><span class="line">&#125;).Info()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 日志记录到 MongoDB</span><br><span class="line">func LoggerToMongo() gin.HandlerFunc &#123;</span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 日志记录到 ES</span><br><span class="line">func LoggerToES() gin.HandlerFunc &#123;</span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 日志记录到 MQ</span><br><span class="line">func LoggerToMQ() gin.HandlerFunc &#123;</span><br><span class="line">return func(c *gin.Context) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这时会新生成一个文件 <code>system.log.20190717.log</code>，日志内容与上面的格式一致。</p><p>最后，<code>logrus</code> 可扩展的 Hook 很多，大家可以去网上查找。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;上篇文章分享了 Gin 框架的路由配置，这篇文章分享日志记录。&lt;/p&gt;
&lt;p&gt;查了很多资料，Go 的日志记录用的最多的还是 &lt;code&gt;gi</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>路由配置</title>
    <link href="https://timmy6.github.io/2018/12/20/gin-router/"/>
    <id>https://timmy6.github.io/2018/12/20/gin-router/</id>
    <published>2018-12-20T12:22:50.000Z</published>
    <updated>2022-05-11T09:47:11.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>这篇文章分享 Gin 的路由配置，主要包含的功能点如下：</p><ul><li>实现了，路由分组 v1版本、v2版本。</li><li>实现了，生成签名和验证验证。</li><li>实现了，在配置文件中读取配置。</li></ul><h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><p>比如我们的接口地址是这样的：</p><ul><li><code>/v1/product/add</code></li><li><code>/v1/member/add</code></li><li><code>/v2/product/add</code></li><li><code>/v2/member/add</code></li></ul><p>假设需求是这样的，接口支持多种请求方式，v1 不需签名验证，v2 需要签名验证，路由文件应该这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">package router</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;ginDemo/common&quot;</span><br><span class="line">&quot;ginDemo/controller/v1&quot;</span><br><span class="line">&quot;ginDemo/controller/v2&quot;</span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">&quot;net/url&quot;</span><br><span class="line">&quot;strconv&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func InitRouter(r *gin.Engine)  &#123;</span><br><span class="line"></span><br><span class="line">r.GET(&quot;/sn&quot;, SignDemo)</span><br><span class="line"></span><br><span class="line">// v1 版本</span><br><span class="line">GroupV1 := r.Group(&quot;/v1&quot;)</span><br><span class="line">&#123;</span><br><span class="line">GroupV1.Any(&quot;/product/add&quot;, v1.AddProduct)</span><br><span class="line">GroupV1.Any(&quot;/member/add&quot;, v1.AddMember)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// v2 版本</span><br><span class="line">GroupV2 := r.Group(&quot;/v2&quot;, common.VerifySign)</span><br><span class="line">&#123;</span><br><span class="line">GroupV2.Any(&quot;/product/add&quot;, v2.AddProduct)</span><br><span class="line">GroupV2.Any(&quot;/member/add&quot;, v2.AddMember)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func SignDemo(c *gin.Context) &#123;</span><br><span class="line">ts := strconv.FormatInt(common.GetTimeUnix(), 10)</span><br><span class="line">res := map[string]interface&#123;&#125;&#123;&#125;</span><br><span class="line">params := url.Values&#123;</span><br><span class="line">&quot;name&quot;  : []string&#123;&quot;a&quot;&#125;,</span><br><span class="line">&quot;price&quot; : []string&#123;&quot;10&quot;&#125;,</span><br><span class="line">&quot;ts&quot;    : []string&#123;ts&#125;,</span><br><span class="line">&#125;</span><br><span class="line">res[&quot;sn&quot;] = common.CreateSign(params)</span><br><span class="line">res[&quot;ts&quot;] = ts</span><br><span class="line">common.RetJson(&quot;200&quot;, &quot;&quot;, res, c)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>.Any</code> 表示支持多种请求方式。</p><p><code>controller/v1</code> 表示 v1 版本的文件。</p><p><code>controller/v2</code> 表示 v2 版本的文件。</p><p><code>SignDemo</code> 表示生成签名的Demo。</p><p>接下来，给出一些代码片段：</p><p>验证签名方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// 验证签名</span><br><span class="line">func VerifySign(c *gin.Context) &#123;</span><br><span class="line">var method = c.Request.Method</span><br><span class="line">var ts int64</span><br><span class="line">var sn string</span><br><span class="line">var req url.Values</span><br><span class="line"></span><br><span class="line">if method == &quot;GET&quot; &#123;</span><br><span class="line">req = c.Request.URL.Query()</span><br><span class="line">sn = c.Query(&quot;sn&quot;)</span><br><span class="line">ts, _  = strconv.ParseInt(c.Query(&quot;ts&quot;), 10, 64)</span><br><span class="line"></span><br><span class="line">&#125; else if method == &quot;POST&quot; &#123;</span><br><span class="line">req = c.Request.PostForm</span><br><span class="line">sn = c.PostForm(&quot;sn&quot;)</span><br><span class="line">ts, _  = strconv.ParseInt(c.PostForm(&quot;ts&quot;), 10, 64)</span><br><span class="line">&#125; else &#123;</span><br><span class="line">RetJson(&quot;500&quot;, &quot;Illegal requests&quot;, &quot;&quot;, c)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">exp, _ := strconv.ParseInt(config.API_EXPIRY, 10, 64)</span><br><span class="line"></span><br><span class="line">// 验证过期时间</span><br><span class="line">if ts &gt; GetTimeUnix() || GetTimeUnix() - ts &gt;= exp &#123;</span><br><span class="line">RetJson(&quot;500&quot;, &quot;Ts Error&quot;, &quot;&quot;, c)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 验证签名</span><br><span class="line">if sn == &quot;&quot; || sn != CreateSign(req) &#123;</span><br><span class="line">RetJson(&quot;500&quot;, &quot;Sn Error&quot;, &quot;&quot;, c)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>生成签名的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 生成签名</span><br><span class="line">func CreateSign(params url.Values) string &#123;</span><br><span class="line">var key []string</span><br><span class="line">var str = &quot;&quot;</span><br><span class="line">for k := range params &#123;</span><br><span class="line">if k != &quot;sn&quot; &#123;</span><br><span class="line">key = append(key, k)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">sort.Strings(key)</span><br><span class="line">for i := 0; i &lt; len(key); i++ &#123;</span><br><span class="line">if i == 0 &#123;</span><br><span class="line">str = fmt.Sprintf(&quot;%v=%v&quot;, key[i], params.Get(key[i]))</span><br><span class="line">&#125; else &#123;</span><br><span class="line">str = str + fmt.Sprintf(&quot;&amp;%v=%v&quot;, key[i], params.Get(key[i]))</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// 自定义签名算法</span><br><span class="line">sign := MD5(MD5(str) + MD5(config.APP_NAME + config.APP_SECRET))</span><br><span class="line">return sign</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>获取参数的方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 获取 Get 参数</span><br><span class="line">name := c.Query(&quot;name&quot;)</span><br><span class="line">price := c.DefaultQuery(&quot;price&quot;, &quot;100&quot;)</span><br><span class="line"></span><br><span class="line">// 获取 Post 参数</span><br><span class="line">name := c.PostForm(&quot;name&quot;)</span><br><span class="line">price := c.DefaultPostForm(&quot;price&quot;, &quot;100&quot;)</span><br><span class="line"></span><br><span class="line">// 获取 Get 所有参数</span><br><span class="line">ReqGet = c.Request.URL.Query()</span><br><span class="line"></span><br><span class="line">//获取 Post 所有参数</span><br><span class="line">ReqPost = c.Request.PostForm</span><br></pre></td></tr></table></figure><p>v1 业务代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">package v1</span><br><span class="line"></span><br><span class="line">import &quot;github.com/gin-gonic/gin&quot;</span><br><span class="line"></span><br><span class="line">func AddProduct(c *gin.Context)  &#123;</span><br><span class="line">// 获取 Get 参数</span><br><span class="line">name  := c.Query(&quot;name&quot;)</span><br><span class="line">price := c.DefaultQuery(&quot;price&quot;, &quot;100&quot;)</span><br><span class="line"></span><br><span class="line">c.JSON(200, gin.H&#123;</span><br><span class="line">&quot;v1&quot;    : &quot;AddProduct&quot;,</span><br><span class="line">&quot;name&quot;  : name,</span><br><span class="line">&quot;price&quot; : price,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>v2 业务代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">package v2</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;github.com/gin-gonic/gin&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func AddProduct(c *gin.Context)  &#123;</span><br><span class="line">// 获取 Get 参数</span><br><span class="line">name  := c.Query(&quot;name&quot;)</span><br><span class="line">price := c.DefaultQuery(&quot;price&quot;, &quot;100&quot;)</span><br><span class="line"></span><br><span class="line">c.JSON(200, gin.H&#123;</span><br><span class="line">&quot;v1&quot;    : &quot;AddProduct&quot;,</span><br><span class="line">&quot;name&quot;  : name,</span><br><span class="line">&quot;price&quot; : price,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>接下来，直接看效果吧。</p><p>访问 v1 接口：</p><p><img src="/images/%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/2_go_1.png"></p><p>访问后，直接返回数据，不走签名验证。</p><p>访问 v2 接口：</p><p><img src="/images/%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/2_go_2.png"></p><p>进入了这段验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 验证过期时间</span><br><span class="line">if ts &gt; GetTimeUnix() || GetTimeUnix() - ts &gt;= exp &#123;</span><br><span class="line">RetJson(&quot;500&quot;, &quot;Ts Error&quot;, &quot;&quot;, c)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改为合法的时间戳后：</p><p><img src="/images/%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/2_go_3.png"></p><p>进入了这段验证：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 验证签名</span><br><span class="line">if sn == &quot;&quot; || sn != CreateSign(req) &#123;</span><br><span class="line">RetJson(&quot;500&quot;, &quot;Sn Error&quot;, &quot;&quot;, c)</span><br><span class="line">return</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改为合法的签名后：</p><p><img src="/images/%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/2_go_4.png"></p><p>至此，简单的路由配置已经实现了。</p><p>对了，还有一个点没说，就是如何读取配置文件中的配置，我是这样做的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">package config</span><br><span class="line"></span><br><span class="line">const (</span><br><span class="line">PORT       = &quot;:8080&quot;</span><br><span class="line">APP_NAME   = &quot;ginDemo&quot;</span><br><span class="line">APP_SECRET = &quot;6YJSuc50uJ18zj45&quot;</span><br><span class="line">API_EXPIRY = &quot;120&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>引入 config 包，直接 <code>config.xx</code> 即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;这篇文章分享 Gin 的路由配置，主要包含的功能点如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实现了，路由分组 v1版本、v2版本。&lt;/li&gt;
&lt;li</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>使用 sync.WaitGroup 来实现并发操作</title>
    <link href="https://timmy6.github.io/2018/12/15/sync-WaitGroup/"/>
    <id>https://timmy6.github.io/2018/12/15/sync-WaitGroup/</id>
    <published>2018-12-15T12:22:50.000Z</published>
    <updated>2022-05-11T09:47:04.981Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>如果你有一个任务可以分解成多个子任务进行处理，同时每个子任务没有先后执行顺序的限制，等到全部子任务执行完毕后，再进行下一步处理。这时每个子任务的执行可以并发处理，这种情景下适合使用 <code>sync.WaitGroup</code>。</p><p>虽然 <code>sync.WaitGroup</code> 使用起来比较简单，但是一不留神很有可能踩到坑里。</p><h2 id="sync-WaitGroup-正确使用"><a href="#sync-WaitGroup-正确使用" class="headerlink" title="sync.WaitGroup 正确使用"></a>sync.WaitGroup 正确使用</h2><p>比如，有一个任务需要执行 3 个子任务，那么可以这样写：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">wg.Add(3)</span><br><span class="line"></span><br><span class="line">go handlerTask1(&amp;wg)</span><br><span class="line">go handlerTask2(&amp;wg)</span><br><span class="line">go handlerTask3(&amp;wg)</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;全部任务执行完毕.&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handlerTask1(wg *sync.WaitGroup) &#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">fmt.Println(&quot;执行任务 1&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handlerTask2(wg *sync.WaitGroup) &#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">fmt.Println(&quot;执行任务 2&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func handlerTask3(wg *sync.WaitGroup) &#123;</span><br><span class="line">defer wg.Done()</span><br><span class="line">fmt.Println(&quot;执行任务 3&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">执行任务 3</span><br><span class="line">执行任务 1</span><br><span class="line">执行任务 2</span><br><span class="line">全部任务执行完毕.</span><br></pre></td></tr></table></figure><h2 id="sync-WaitGroup-闭坑指南"><a href="#sync-WaitGroup-闭坑指南" class="headerlink" title="sync.WaitGroup 闭坑指南"></a>sync.WaitGroup 闭坑指南</h2><h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 正确</span><br><span class="line">go handlerTask1(&amp;wg)</span><br><span class="line"></span><br><span class="line">// 错误</span><br><span class="line">go handlerTask1(wg)</span><br></pre></td></tr></table></figure><p>执行子任务时，使用的 <code>sync.WaitGroup</code> 一定要是 <code>wg</code> 的引用类型！</p><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><p>注意不要将 <code>wg.Add()</code> 放在 <code>go handlerTask1(&amp;wg)</code> 中！</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 错误</span><br><span class="line">var wg sync.WaitGroup</span><br><span class="line"></span><br><span class="line">go handlerTask1(&amp;wg)</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">func handlerTask1(wg *sync.WaitGroup) &#123;</span><br><span class="line">wg.Add(1)</span><br><span class="line">defer wg.Done()</span><br><span class="line">fmt.Println(&quot;执行任务 1&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意 <code>wg.Add()</code> 一定要在 <code>wg.Wait()</code> 执行前执行！</p><h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><p>注意 <code>wg.Add()</code> 和 <code>wg.Done()</code> 的计数器保持一致！其实 <code>wg.Done()</code> 就是执行的 <code>wg.Add(-1)</code> 。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p><code>sync.WaitGroup</code> 使用起来比较简单，一定要注意不要踩到坑里。</p><p>其实 <code>sync.WaitGroup</code> 使用场景比较局限，仅适用于等待全部子任务执行完毕后，再进行下一步处理，如果需求是当第一个子任务执行失败时，通知其他子任务停止运行，这时 <code>sync.WaitGroup</code> 是无法满足的，需要使用到通知机制（<code>channel</code>）。</p><p>以上，希望对你能够有所帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;如果你有一个任务可以分解成多个子任务进行处理，同时每个子任务没有先后执行顺序的限制，等到全部子任务执行完毕后，再进行下一步处理。这时每个子任</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>使用sync.Map来解决map的并发操作问题</title>
    <link href="https://timmy6.github.io/2018/12/12/sync-map/"/>
    <id>https://timmy6.github.io/2018/12/12/sync-map/</id>
    <published>2018-12-12T12:22:50.000Z</published>
    <updated>2022-05-11T09:46:56.245Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在 <code>Golang</code> 中 <code>map</code> 不是并发安全的，自 1.9 才引入了 <code>sync.Map</code> ，<code>sync.Map</code> 的引入确实解决了 <code>map</code> 的并发安全问题，不过 <code>sync.Map</code> 却没有实现 <code>len()</code> 函数，如果想要计算 <code>sync.Map</code> 的长度，稍微有点麻烦，需要使用 <code>Range</code> 函数。</p><h2 id="map-并发操作出现问题"><a href="#map-并发操作出现问题" class="headerlink" title="map 并发操作出现问题"></a>map 并发操作出现问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">demo := make(map[int]int)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">for j := 0; j &lt; 1000; j++ &#123;</span><br><span class="line">demo[j] = j</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">for j := 0; j &lt; 1000; j++ &#123;</span><br><span class="line">fmt.Println(demo[j])</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second * 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fatal error: concurrent map read and map write</span><br></pre></td></tr></table></figure><h2 id="sync-Map-解决并发操作问题"><a href="#sync-Map-解决并发操作问题" class="headerlink" title="sync.Map 解决并发操作问题"></a>sync.Map 解决并发操作问题</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">demo := sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">for j := 0; j &lt; 1000; j++ &#123;</span><br><span class="line">demo.Store(j, j)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">for j := 0; j &lt; 1000; j++ &#123;</span><br><span class="line">fmt.Println(demo.Load(j))</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(time.Second * 1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;nil&gt; false</span><br><span class="line">1 true</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">999 true</span><br></pre></td></tr></table></figure><h2 id="计算-map-长度"><a href="#计算-map-长度" class="headerlink" title="计算 map 长度"></a>计算 map 长度</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">demo := make(map[int]int)</span><br><span class="line"></span><br><span class="line">for j := 0; j &lt; 1000; j++ &#123;</span><br><span class="line">demo[j] = j</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;len of demo:&quot;, len(demo))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len of demo: 1000</span><br></pre></td></tr></table></figure><h2 id="计算-sync-Map-长度"><a href="#计算-sync-Map-长度" class="headerlink" title="计算 sync.Map 长度"></a>计算 sync.Map 长度</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">demo := sync.Map&#123;&#125;</span><br><span class="line"></span><br><span class="line">for j := 0; j &lt; 1000; j++ &#123;</span><br><span class="line">demo.Store(j, j)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lens := 0</span><br><span class="line">demo.Range(func(key, value interface&#123;&#125;) bool &#123;</span><br><span class="line">lens++</span><br><span class="line">return true</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;len of demo:&quot;, lens)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">len of demo: 1000</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li><code>Load</code> 加载 key 数据</li><li><code>Store</code> 更新或新增 key 数据</li><li><code>Delete</code> 删除 key 数据</li><li><code>Range</code> 遍历数据</li><li><code>LoadOrStore</code> 如果存在 key 数据则返回，反之则设置</li><li><code>LoadAndDelete</code> 如果存在 key 数据则删除</li></ol><p>以上，希望对你能够有所帮助。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在 &lt;code&gt;Golang&lt;/code&gt; 中 &lt;code&gt;map&lt;/code&gt; 不是并发安全的，自 1.9 才引入了 &lt;code&gt;sync</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>基于逃逸分析来提升程序性能</title>
    <link href="https://timmy6.github.io/2018/12/10/escape/"/>
    <id>https://timmy6.github.io/2018/12/10/escape/</id>
    <published>2018-12-10T11:17:50.000Z</published>
    <updated>2022-05-11T09:46:49.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>为什么需要了解逃逸分析？</p><p>因为我们想要提升程序性能，通过逃逸分析我们能够知道变量是分配到堆上还是栈上，如果分配到栈上，内存的分配和释放都是由编译器进行管理，分配和释放的速度非常快，如果分配到堆上，堆不像栈那样可以自动清理，它会引起频繁地进行垃圾回收（<code>GC</code>），而垃圾回收会占用比较大的系统开销。</p><h2 id="什么是逃逸分析？"><a href="#什么是逃逸分析？" class="headerlink" title="什么是逃逸分析？"></a>什么是逃逸分析？</h2><blockquote><p>在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法，简单来说就是分析在程序的哪些地方可以访问到该指针。</p></blockquote><p>简单的说，它是在对变量放到堆上还是栈上进行分析，该分析在编译阶段完成。如果一个变量超过了函数调用的生命周期，也就是这个变量在函数外部存在引用，编译器会把这个变量分配到堆上，这时我们就说这个变量发生逃逸了。</p><h2 id="如何确定是否逃逸？"><a href="#如何确定是否逃逸？" class="headerlink" title="如何确定是否逃逸？"></a>如何确定是否逃逸？</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go run -gcflags &#x27;-m -l&#x27; main.go</span><br></pre></td></tr></table></figure><h2 id="可能出现逃逸的场景"><a href="#可能出现逃逸的场景" class="headerlink" title="可能出现逃逸的场景"></a>可能出现逃逸的场景</h2><h3 id="01"><a href="#01" class="headerlink" title="01"></a>01</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">Name interface&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">stu := new(Student)</span><br><span class="line">stu.Name = &quot;tom&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">go run -gcflags &#x27;-m -l&#x27; 01.go</span><br><span class="line"># command-line-arguments</span><br><span class="line">./01.go:8:12: new(Student) does not escape</span><br><span class="line">./01.go:9:11: &quot;tom&quot; escapes to heap</span><br></pre></td></tr></table></figure><p><code>interface&#123;&#125;</code> 赋值，会发生逃逸，优化方案是将类型设置为固定类型，例如：<code>string</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main()  &#123;</span><br><span class="line">stu := new(Student)</span><br><span class="line">stu.Name = &quot;tom&quot;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run -gcflags &#x27;-m -l&#x27; 01.go</span><br><span class="line"># command-line-arguments</span><br><span class="line">./01.go:8:12: new(Student) does not escape</span><br></pre></td></tr></table></figure><h3 id="02"><a href="#02" class="headerlink" title="02"></a>02</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">type Student struct &#123;</span><br><span class="line">Name string</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func GetStudent() *Student &#123;</span><br><span class="line">stu := new(Student)</span><br><span class="line">stu.Name = &quot;tom&quot;</span><br><span class="line">return stu</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">GetStudent()</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>分析结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run -gcflags &#x27;-m -l&#x27; 02.go</span><br><span class="line"># command-line-arguments</span><br><span class="line">./02.go:8:12: new(Student) escapes to heap</span><br></pre></td></tr></table></figure><p>返回指针类型，会发生逃逸，优化方案视情况而定。</p><p>函数传递指针和传值哪个效率高吗？我们知道传递指针可以减少底层值的拷贝，可以提高效率，但是如果拷贝的数据量小，由于指针传递会产生逃逸，可能会使用堆，也可能会增加 <code>GC</code> 的负担，所以传递指针不一定是高效的。</p><p>不要盲目使用变量指针作为参数，虽然减少了复制，但变量逃逸的开销可能更大。</p><h3 id="03"><a href="#03" class="headerlink" title="03"></a>03</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">nums := make([]int, 10000, 10000)</span><br><span class="line"></span><br><span class="line">for i := range nums &#123;</span><br><span class="line">nums[i] = i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go run -gcflags &#x27;-m -l&#x27; 03.go</span><br><span class="line"># command-line-arguments</span><br><span class="line">./03.go:4:14: make([]int, 10000, 10000) escapes to heap</span><br></pre></td></tr></table></figure><p>栈空间不足，会发生逃逸，优化方案尽量设置容量，如果容量实在过大那就没办法了。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>逃逸分析是编译器在静态编译时完成的。</li><li>逃逸分析后可以确定哪些变量可以分配在栈上，栈的性能好。</li></ol><p>以上，希望对你能够有所帮助。</p><h2 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h2><ul><li><a href="https://mp.weixin.qq.com/s/0NVp59uI8h9WTp68wtb7XQ">Go - 使用 sync.Pool 来减少 GC 压力</a></li><li><a href="https://mp.weixin.qq.com/s/jvSbZ0_g_EFqaR2TmjjO8w">Go - 使用 options 设计模式</a></li><li><a href="https://mp.weixin.qq.com/s/ykZCZb9IAXJaKAx_cO7YjA">Go - json.Unmarshal 遇到的小坑</a></li><li><a href="https://mp.weixin.qq.com/s/-QCG61vh6NVJUWz6tOY7Gw">Go - 两个在开发中需注意的小点</a></li><li><a href="https://mp.weixin.qq.com/s/1pFVaMaWItp8zCXotQ9iBg">Go - time.RFC3339 时间格式化</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;为什么需要了解逃逸分析？&lt;/p&gt;
&lt;p&gt;因为我们想要提升程序性能，通过逃逸分析我们能够知道变量是分配到堆上还是栈上，如果分配到栈上，内存的分</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>不要使用 + 和 fmt.Sprintf 操作字符串</title>
    <link href="https://timmy6.github.io/2018/12/05/string-append/"/>
    <id>https://timmy6.github.io/2018/12/05/string-append/</id>
    <published>2018-12-05T10:17:50.000Z</published>
    <updated>2022-05-11T09:46:44.447Z</updated>
    
    <content type="html"><![CDATA[<h2 id="不要使用-和-fmt-Sprintf-操作字符串"><a href="#不要使用-和-fmt-Sprintf-操作字符串" class="headerlink" title="不要使用 + 和 fmt.Sprintf 操作字符串"></a>不要使用 + 和 fmt.Sprintf 操作字符串</h2><p>不要使用 <code>+</code> 和 <code>fmt.Sprintf</code> 操作字符串，虽然很方便，但是真的很慢！</p><p>我们要使用 <code>bytes.NewBufferString</code> 进行处理。</p><p>基准测试如下：</p><h3 id=""><a href="#" class="headerlink" title="+"></a>+</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkStringOperation1(b *testing.B)  &#123;</span><br><span class="line">b.ResetTimer()</span><br><span class="line">str := &quot;&quot;</span><br><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">str += &quot;golang&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: demo/stringoperation</span><br><span class="line">cpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz</span><br><span class="line">BenchmarkStringOperation1</span><br><span class="line">BenchmarkStringOperation1-12      353318    114135 ns/op</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">Process finished with the exit code 0</span><br></pre></td></tr></table></figure><h3 id="fmt-Sprintf"><a href="#fmt-Sprintf" class="headerlink" title="fmt.Sprintf"></a>fmt.Sprintf</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkStringOperation2(b *testing.B)  &#123;</span><br><span class="line">b.ResetTimer()</span><br><span class="line">str := &quot;&quot;</span><br><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">str = fmt.Sprintf(&quot;%s%s&quot;, str, &quot;golang&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: demo/stringoperation</span><br><span class="line">cpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz</span><br><span class="line">BenchmarkStringOperation2</span><br><span class="line">BenchmarkStringOperation2-12      280140    214098 ns/op</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">Process finished with the exit code 0</span><br></pre></td></tr></table></figure><h3 id="bytes-NewBufferString"><a href="#bytes-NewBufferString" class="headerlink" title="bytes.NewBufferString"></a>bytes.NewBufferString</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkStringOperation3(b *testing.B)  &#123;</span><br><span class="line">b.ResetTimer()</span><br><span class="line">strBuf := bytes.NewBufferString(&quot;&quot;)</span><br><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">strBuf.WriteString(&quot;golang&quot;)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: demo/stringoperation</span><br><span class="line">cpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz</span><br><span class="line">BenchmarkStringOperation3</span><br><span class="line">BenchmarkStringOperation3-12    161292136         8.582 ns/op</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">Process finished with the exit code 0</span><br></pre></td></tr></table></figure><h2 id="对于固定字段的键值对，不要使用-map-string-interface"><a href="#对于固定字段的键值对，不要使用-map-string-interface" class="headerlink" title="对于固定字段的键值对，不要使用 map[string]interface{}"></a>对于固定字段的键值对，不要使用 map[string]interface{}</h2><p>对于固定字段的键值对，不要使用 <code>map[string]interface&#123;&#125;</code>!</p><p>我们要使用<code>临时 Struct</code>。</p><p>基准测试如下：</p><h3 id="map-string-interface"><a href="#map-string-interface" class="headerlink" title="map[string]interface{}"></a>map[string]interface{}</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkStructOperation1(b *testing.B) &#123;</span><br><span class="line">b.ResetTimer()</span><br><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">var demo = map[string]interface&#123;&#125;&#123;&#125;</span><br><span class="line">demo[&quot;Name&quot;] = &quot;Tom&quot;</span><br><span class="line">demo[&quot;Age&quot;] = 30</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">goos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: demo/structoperation</span><br><span class="line">cpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz</span><br><span class="line">BenchmarkStructOperation1</span><br><span class="line">BenchmarkStructOperation1-12    43300134        27.97 ns/op</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">Process finished with the exit code 0</span><br></pre></td></tr></table></figure><h3 id="临时-Struct"><a href="#临时-Struct" class="headerlink" title="临时 Struct"></a>临时 Struct</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">func BenchmarkStructOperation2(b *testing.B) &#123;</span><br><span class="line">b.ResetTimer()</span><br><span class="line">for i := 0; i &lt; b.N; i++ &#123;</span><br><span class="line">var demo struct &#123;</span><br><span class="line">Name string</span><br><span class="line">Age  int</span><br><span class="line">&#125;</span><br><span class="line">demo.Name = &quot;Tom&quot;</span><br><span class="line">demo.Age = 30</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">oos: darwin</span><br><span class="line">goarch: amd64</span><br><span class="line">pkg: demo/structoperation</span><br><span class="line">cpu: Intel(R) Core(TM) i7-8700B CPU @ 3.20GHz</span><br><span class="line">BenchmarkStructOperation2</span><br><span class="line">BenchmarkStructOperation2-12    1000000000         0.2388 ns/op</span><br><span class="line">PASS</span><br><span class="line"></span><br><span class="line">Process finished with the exit code 0</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>你有类似这样的注意点吗，欢迎留言~ </p><p>下面推荐阅读的这几篇文章也是关于开发中需要知道的小技术点，更多技术细节和代码讨论，可以加入到我的星球。</p><h3 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h3><ul><li><a href="https://mp.weixin.qq.com/s/jvSbZ0_g_EFqaR2TmjjO8w">函数的不定参数你是这样用吗？</a></li><li><a href="https://mp.weixin.qq.com/s/W_LsZtnjGIKQ-LB6EkRgBA">优雅地处理错误真是一门学问啊！</a></li><li><a href="https://mp.weixin.qq.com/s/6c6uapjIzJC9wmjUFyZuZA">如何设计 API 接口，实现统一格式返回？</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;不要使用-和-fmt-Sprintf-操作字符串&quot;&gt;&lt;a href=&quot;#不要使用-和-fmt-Sprintf-操作字符串&quot; class=&quot;headerlink&quot; title=&quot;不要使用 + 和 fmt.Sprintf 操作字符串&quot;&gt;&lt;/a&gt;不要使用 + 和 fmt</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>json.Unmarshal遇到的小坑</title>
    <link href="https://timmy6.github.io/2018/11/25/json-unmarshal/"/>
    <id>https://timmy6.github.io/2018/11/25/json-unmarshal/</id>
    <published>2018-11-25T10:17:50.000Z</published>
    <updated>2022-05-11T09:46:39.159Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-问题现象描述"><a href="#1-问题现象描述" class="headerlink" title="1.问题现象描述"></a>1.问题现象描述</h2><p>使用 <code>json.Unmarshal()</code>，反序列化时，出现了科学计数法，参考代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jsonStr := `&#123;&quot;number&quot;:1234567&#125;`</span><br><span class="line">result := make(map[string]interface&#123;&#125;)</span><br><span class="line">err := json.Unmarshal([]byte(jsonStr), &amp;result)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(result)</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// map[number:1.234567e+06]</span><br></pre></td></tr></table></figure><p>这个问题不是必现，只有当数字的位数大于 6 位时，才会变成了科学计数法。</p><h2 id="2-问题影响描述"><a href="#2-问题影响描述" class="headerlink" title="2.问题影响描述"></a>2.问题影响描述</h2><p>当数据结构未知，使用 <code>map[string]interface&#123;&#125;</code> 来接收反序列化结果时，如果数字的位数大于 6 位，都会变成科学计数法，用到的地方都会受到影响。</p><h2 id="3-引起问题的原因"><a href="#3-引起问题的原因" class="headerlink" title="3.引起问题的原因"></a>3.引起问题的原因</h2><p>从 <code>encoding/json</code> 可以找到答案，看一下这段注释：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// To unmarshal JSON into an interface value,</span><br><span class="line">// Unmarshal stores one of these in the interface value:</span><br><span class="line">//</span><br><span class="line">//bool, for JSON booleans</span><br><span class="line">//float64, for JSON numbers</span><br><span class="line">//string, for JSON strings</span><br><span class="line">//[]interface&#123;&#125;, for JSON arrays</span><br><span class="line">//map[string]interface&#123;&#125;, for JSON objects</span><br><span class="line">//nil for JSON null</span><br></pre></td></tr></table></figure><p>是因为当 <code>JSON</code> 中存在一个比较大的数字时，它会被解析成 <code>float64</code> 类型，就有可能会出现科学计数法的形式。</p><h2 id="4-问题的解决方案"><a href="#4-问题的解决方案" class="headerlink" title="4.问题的解决方案"></a>4.问题的解决方案</h2><p><strong>方案一</strong></p><p>强制类型转换，参考代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jsonStr := `&#123;&quot;number&quot;:1234567&#125;`</span><br><span class="line">result := make(map[string]interface&#123;&#125;)</span><br><span class="line">err := json.Unmarshal([]byte(jsonStr), &amp;result)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(int(result[&quot;number&quot;].(float64)))</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// 1234567</span><br></pre></td></tr></table></figure><p><strong>方案二</strong></p><p>尽量避免使用 <code>interface</code>，对 <code>json</code> 字符串结构定义结构体，快捷方法可使用在线工具：<code>https://mholt.github.io/json-to-go/</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">type Num struct &#123;</span><br><span class="line">Number int `json:&quot;number&quot;`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">jsonStr := `&#123;&quot;number&quot;:1234567&#125;`</span><br><span class="line">var result Num</span><br><span class="line">err := json.Unmarshal([]byte(jsonStr), &amp;result)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(result)</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// &#123;1234567&#125;</span><br></pre></td></tr></table></figure><p><strong>方案三</strong></p><p>使用 <code>UseNumber()</code> 方法。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jsonStr := `&#123;&quot;number&quot;:1234567&#125;`</span><br><span class="line">result := make(map[string]interface&#123;&#125;)</span><br><span class="line">d := json.NewDecoder(bytes.NewReader([]byte(jsonStr)))</span><br><span class="line">d.UseNumber()</span><br><span class="line">err := d.Decode(&amp;result)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">fmt.Println(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(result)</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// map[number:1234567]</span><br></pre></td></tr></table></figure><p>这时一定要注意 <code>result[&quot;number&quot;]</code> 的数据类型！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fmt.Println(fmt.Sprintf(&quot;type: %v&quot;, reflect.TypeOf(result[&quot;number&quot;])))</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// type: json.Number</span><br></pre></td></tr></table></figure><p>通过代码可以看出 <code>json.Number</code> 其实就是字符串类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// A Number represents a JSON number literal.</span><br><span class="line">type Number string</span><br></pre></td></tr></table></figure><p>如果转换其他类型，参考如下代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 转成 int64</span><br><span class="line">numInt, _ := result[&quot;number&quot;].(json.Number).Int64()</span><br><span class="line">fmt.Println(fmt.Sprintf(&quot;value: %v, type: %v&quot;, numInt, reflect.TypeOf(numInt)))</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// value: 1234567, type: int64</span><br><span class="line"></span><br><span class="line">// 转成 string</span><br><span class="line">numStr := result[&quot;number&quot;].(json.Number).String()</span><br><span class="line">fmt.Println(fmt.Sprintf(&quot;value: %v, type: %v&quot;, numStr, reflect.TypeOf(numStr)))</span><br><span class="line"></span><br><span class="line">// 输出</span><br><span class="line">// value: 1234567, type: string</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-问题现象描述&quot;&gt;&lt;a href=&quot;#1-问题现象描述&quot; class=&quot;headerlink&quot; title=&quot;1.问题现象描述&quot;&gt;&lt;/a&gt;1.问题现象描述&lt;/h2&gt;&lt;p&gt;使用 &lt;code&gt;json.Unmarshal()&lt;/code&gt;，反序列化时，出现了科学计数</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>defer 函数</title>
    <link href="https://timmy6.github.io/2018/11/15/defer/"/>
    <id>https://timmy6.github.io/2018/11/15/defer/</id>
    <published>2018-11-15T11:17:50.000Z</published>
    <updated>2022-05-11T09:46:33.357Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>defer 函数大家肯定都用过，它在声明时不会立刻去执行，而是在函数 return 后去执行的。</p><p>它的主要应用场景有异常处理、记录日志、清理数据、释放资源 等等。</p><p>这篇文章不是分享 defer 的应用场景，而是分享使用 defer 需要注意的点。</p><p>咱们先从一道题开始，一起来感受下 …</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">func calc(index string, a, b int) int &#123;</span><br><span class="line">ret := a + b</span><br><span class="line">fmt.Println(index, a, b, ret)</span><br><span class="line">return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">x := 1</span><br><span class="line">y := 2</span><br><span class="line">defer calc(&quot;A&quot;, x, calc(&quot;B&quot;, x, y))</span><br><span class="line">x = 3</span><br><span class="line">defer calc(&quot;C&quot;, x, calc(&quot;D&quot;, x, y))</span><br><span class="line">y = 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出什么？</p><p>…</p><p>接下来，先容我分享几个小例子，再进行作答。</p><h2 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">defer fmt.Println(&quot;1&quot;)</span><br><span class="line">defer fmt.Println(&quot;2&quot;)</span><br><span class="line">defer fmt.Println(&quot;3&quot;)</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;main&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">3</span><br><span class="line">2</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>结论：defer 函数定义的顺序 与 实际执的行顺序是相反的，也就是最先声明的最后才执行。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line"></span><br><span class="line">var a = 1</span><br><span class="line">var b = 2</span><br><span class="line"></span><br><span class="line">defer fmt.Println(a + b)</span><br><span class="line"></span><br><span class="line">a = 2</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;main&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>稍微修改一下，再看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var a = 1</span><br><span class="line">var b = 2</span><br><span class="line"></span><br><span class="line">defer func() &#123;</span><br><span class="line">fmt.Println(a + b)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">a = 2</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;main&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">4</span><br></pre></td></tr></table></figure><p>结论：闭包获取变量相当于引用传递，而非值传递。</p><p>稍微再修改一下，再看看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">var a = 1</span><br><span class="line">var b = 2</span><br><span class="line"></span><br><span class="line">defer func(a int, b int) &#123;</span><br><span class="line">fmt.Println(a + b)</span><br><span class="line">&#125;(a, b)</span><br><span class="line"></span><br><span class="line">a = 2</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;main&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main</span><br><span class="line">3</span><br></pre></td></tr></table></figure><p>结论：传参是值复制。</p><p>还可以理解为：defer 调用的函数，参数的值在 defer 定义时就确定了，看下代码</p><p><code>defer fmt.Println(a + b)</code>，在这时，参数的值已经确定了。</p><p>而 defer 函数内部所使用的变量的值需要在这个函数运行时才确定，看下代码</p><p><code>defer func() &#123; fmt.Println(a + b) &#125;()</code>，a 和 b 的值在函数运行时，才能确定。</p><h2 id="Return"><a href="#Return" class="headerlink" title="Return"></a>Return</h2><h4 id="一"><a href="#一" class="headerlink" title="一"></a>一</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func t1() int &#123;</span><br><span class="line">a := 1</span><br><span class="line">defer func() &#123;</span><br><span class="line">a++</span><br><span class="line">&#125;()</span><br><span class="line">return a</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：1</p><h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func t2() (a int) &#123;</span><br><span class="line">defer func() &#123;</span><br><span class="line">a++</span><br><span class="line">&#125;()</span><br><span class="line">return 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：2</p><h4 id="三"><a href="#三" class="headerlink" title="三"></a>三</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func t3() (b int) &#123;</span><br><span class="line">a := 1</span><br><span class="line">defer func() &#123;</span><br><span class="line">a++</span><br><span class="line">&#125;()</span><br><span class="line">return 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：1</p><h4 id="四"><a href="#四" class="headerlink" title="四"></a>四</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">func t4() (a int) &#123;</span><br><span class="line">defer func(a int) &#123;</span><br><span class="line">a++</span><br><span class="line">&#125;(a)</span><br><span class="line">return 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：1</p><p>结论：return 不是原子操作。</p><h2 id="os-Exit"><a href="#os-Exit" class="headerlink" title="os.Exit"></a>os.Exit</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">defer fmt.Println(&quot;1&quot;)</span><br><span class="line">fmt.Println(&quot;main&quot;)</span><br><span class="line">os.Exit(0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：main</p><p>结论：当<code>os.Exit()</code>方法退出程序时，defer不会被执行。</p><h2 id="不同协程"><a href="#不同协程" class="headerlink" title="不同协程"></a>不同协程</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">GoA()</span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">fmt.Println(&quot;main&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func GoA() &#123;</span><br><span class="line">defer (func()&#123;</span><br><span class="line">if err := recover(); err != nil &#123;</span><br><span class="line">fmt.Println(&quot;panic:&quot; + fmt.Sprintf(&quot;%s&quot;, err))</span><br><span class="line">&#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">go GoB()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func GoB() &#123;</span><br><span class="line">panic(&quot;error&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>GoB()</code> panic 捕获不到。</p><p>结论：defer 只对当前协程有效。</p><p>这个问题怎么解？咱们下回再说。</p><p>接下来，咱们分析下文章开头的问题吧。</p><h2 id="答案解析"><a href="#答案解析" class="headerlink" title="答案解析"></a>答案解析</h2><p>先列出答案：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">B 1 2 3</span><br><span class="line">D 3 2 5</span><br><span class="line">C 3 5 8</span><br><span class="line">A 1 3 4</span><br></pre></td></tr></table></figure><p>其实上面那道题，可以拆解为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">func calc(index string, a, b int) int &#123;</span><br><span class="line">ret := a + b</span><br><span class="line">fmt.Println(index, a, b, ret)</span><br><span class="line">return ret</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">x := 1</span><br><span class="line">y := 2</span><br><span class="line">tmp1 := calc(&quot;B&quot;, x, y)</span><br><span class="line">defer calc(&quot;A&quot;, x, tmp1)</span><br><span class="line">x = 3</span><br><span class="line">tmp2 := calc(&quot;D&quot;, x, y)</span><br><span class="line">defer calc(&quot;C&quot;, x, tmp2)</span><br><span class="line">y = 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以顺序就是：B D C A。</p><p>执行到 tmp1 时，输出：B 1 2 3。</p><p>执行到 tmp2 时，输出：D 3 2 5。</p><p>根据 defer 执行顺序原则，先声明的后执行，所以下一个该执行 C 了。</p><p>又因为传参是值赋值，所以在 A 的时候，无法用到 <code>x = 3</code> 和 <code>y = 4</code>，在 C 的时候，无法用到 <code>y = 4</code>。</p><p>执行到 C 时，输出：C 3 5 8</p><p>执行到 A 时，输出：A 1 3 4</p><p>到这，基本上 defer 就清楚了，大家可以根据自己的理解去记忆。</p><h2 id="go-gin-api-系列文章"><a href="#go-gin-api-系列文章" class="headerlink" title="go-gin-api 系列文章"></a>go-gin-api 系列文章</h2><ul><li><a href="https://mp.weixin.qq.com/s/0cozELotcpX3Gd6WPJiBbQ">7. 路由中间件 - 签名验证</a></li><li><a href="https://mp.weixin.qq.com/s/Ea28475_UTNaM9RNfgPqJA">6. 路由中间件 - Jaeger 链路追踪（实战篇）</a></li><li><a href="https://mp.weixin.qq.com/s/28UBEsLOAHDv530ePilKQA">5. 路由中间件 - Jaeger 链路追踪（理论篇）</a></li><li><a href="https://mp.weixin.qq.com/s/SconDXB_x7Gan6T0Awdh9A">4. 路由中间件 - 捕获异常</a></li><li><a href="https://mp.weixin.qq.com/s/eTygPXnrYM2xfrRQyfn8Tg">3. 路由中间件 - 日志记录</a></li><li><a href="https://mp.weixin.qq.com/s/11AuXptWGmL5QfiJArNLnA">2. 规划项目目录和参数验证</a></li><li><a href="https://mp.weixin.qq.com/s/1XNTEgZ0XGZZdxFOfR5f_A">1. 使用 go modules 初始化项目</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;defer 函数大家肯定都用过，它在声明时不会立刻去执行，而是在函数 return 后去执行的。&lt;/p&gt;
&lt;p&gt;它的主要应用场景有异常处理、</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>chan通道</title>
    <link href="https://timmy6.github.io/2018/11/05/chan/"/>
    <id>https://timmy6.github.io/2018/11/05/chan/</id>
    <published>2018-11-05T11:17:50.000Z</published>
    <updated>2022-05-11T09:46:27.420Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>chan 可以理解为队列，遵循先进先出的规则。</p><p>在说 chan 之前，咱们先说一下 go 关键字。</p><p>在 go 关键字后面加一个函数，就可以创建一个线程，函数可以为已经写好的函数，也可以是匿名函数。</p><p>举个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;main start&quot;)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">fmt.Println(&quot;goroutine&quot;)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;main end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">main end</span><br></pre></td></tr></table></figure><p>为什么没有输出 goroutine ？</p><p>首先，我们清楚 Go 语言的线程是并发机制，不是并行机制。</p><p>那么，什么是并发，什么是并行？</p><p>并发是不同的代码块交替执行，也就是交替可以做不同的事情。</p><p>并行是不同的代码块同时执行，也就是同时可以做不同的事情。</p><p>举个生活化场景的例子：</p><p>你正在家看书，忽然电话来了，然后你接电话，通话完成后继续看书，这就是并发，看书和接电话交替做。</p><p>如果电话来了，你一边看书一遍接电话，这就是并行，看书和接电话一起做。</p><p>说回上面的例子，为什么没有输出 goroutine ？</p><p>main 函数是一个主线程，是因为主线程执行太快了，子线程还没来得及执行，所以看不到输出。</p><p>现在让主线程休眠 1 秒钟，再试试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;main start&quot;)</span><br><span class="line"></span><br><span class="line">go func() &#123;</span><br><span class="line">fmt.Println(&quot;goroutine&quot;)</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line"></span><br><span class="line">fmt.Println(&quot;main end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">goroutine</span><br><span class="line">main end</span><br></pre></td></tr></table></figure><p>这就对了。</p><p>接下来，看看如何使用 chan 。</p><h2 id="声明-chan"><a href="#声明-chan" class="headerlink" title="声明 chan"></a>声明 chan</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">// 声明不带缓冲的通道</span><br><span class="line">ch1 := make(chan string)</span><br><span class="line"></span><br><span class="line">// 声明带10个缓冲的通道</span><br><span class="line">ch2 := make(chan string, 10)</span><br><span class="line"></span><br><span class="line">// 声明只读通道</span><br><span class="line">ch3 := make(&lt;-chan string)</span><br><span class="line"></span><br><span class="line">// 声明只写通道</span><br><span class="line">ch4 := make(chan&lt;- string)</span><br></pre></td></tr></table></figure><p>注意：</p><p>不带缓冲的通道，进和出都会阻塞。</p><p>带缓冲的通道，进一次长度 +1，出一次长度 -1，如果长度等于缓冲长度时，再进就会阻塞。</p><h2 id="写入-chan"><a href="#写入-chan" class="headerlink" title="写入 chan"></a>写入 chan</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ch1 := make(chan string, 10)</span><br><span class="line"></span><br><span class="line">ch1 &lt;- &quot;a&quot;</span><br></pre></td></tr></table></figure><h2 id="读取-chan"><a href="#读取-chan" class="headerlink" title="读取 chan"></a>读取 chan</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val, ok := &lt;- ch1</span><br><span class="line">// 或</span><br><span class="line">val := &lt;- ch1</span><br></pre></td></tr></table></figure><h2 id="关闭-chan"><a href="#关闭-chan" class="headerlink" title="关闭 chan"></a>关闭 chan</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">close(chan)</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>close 以后不能再写入，写入会出现 panic</li><li>重复 close 会出现 panic</li><li>只读的 chan 不能 close</li><li>close 以后还可以读取数据</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;main start&quot;)</span><br><span class="line">ch := make(chan string)</span><br><span class="line">ch &lt;- &quot;a&quot; // 入 chan</span><br><span class="line">go func() &#123;</span><br><span class="line">val := &lt;- ch // 出 chan</span><br><span class="line">fmt.Println(val)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(&quot;main end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">fatal error: all goroutines are asleep - deadlock!</span><br></pre></td></tr></table></figure><p>What ? 这是为啥，刚开始就出师不利呀？</p><p>因为，定义的是一个无缓冲的 chan，赋值后就陷入了阻塞。</p><p>怎么解决它？</p><p>声明一个有缓冲的 chan。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;main start&quot;)</span><br><span class="line">ch := make(chan string, 1)</span><br><span class="line">ch &lt;- &quot;a&quot; // 入 chan</span><br><span class="line">go func() &#123;</span><br><span class="line">val := &lt;- ch // 出 chan</span><br><span class="line">fmt.Println(val)</span><br><span class="line">&#125;()</span><br><span class="line">fmt.Println(&quot;main end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">main end</span><br></pre></td></tr></table></figure><p>为啥没有输出 a , 和前面一样，主线程执行太快了，加个休眠 1 秒钟，再试试。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;main start&quot;)</span><br><span class="line">ch := make(chan string, 1)</span><br><span class="line">ch &lt;- &quot;a&quot; // 入 chan</span><br><span class="line">go func() &#123;</span><br><span class="line">val := &lt;- ch // 出 chan</span><br><span class="line">fmt.Println(val)</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">fmt.Println(&quot;main end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">a</span><br><span class="line">main end</span><br></pre></td></tr></table></figure><p>这就对了。</p><p>再看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;main start&quot;)</span><br><span class="line">ch := make(chan string)</span><br><span class="line">go func() &#123;</span><br><span class="line">ch &lt;- &quot;a&quot; // 入 chan</span><br><span class="line">&#125;()</span><br><span class="line">go func() &#123;</span><br><span class="line">val := &lt;- ch // 出 chan</span><br><span class="line">fmt.Println(val)</span><br><span class="line">&#125;()</span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">fmt.Println(&quot;main end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">a</span><br><span class="line">main end</span><br></pre></td></tr></table></figure><p>再看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">func producer(ch chan string) &#123;</span><br><span class="line">fmt.Println(&quot;producer start&quot;)</span><br><span class="line">ch &lt;- &quot;a&quot;</span><br><span class="line">ch &lt;- &quot;b&quot;</span><br><span class="line">ch &lt;- &quot;c&quot;</span><br><span class="line">ch &lt;- &quot;d&quot;</span><br><span class="line">fmt.Println(&quot;producer end&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;main start&quot;)</span><br><span class="line">ch := make(chan string, 3)</span><br><span class="line">go producer(ch)</span><br><span class="line"></span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">fmt.Println(&quot;main end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">producer start</span><br><span class="line">main end</span><br></pre></td></tr></table></figure><p>带缓冲的通道，如果长度等于缓冲长度时，再进就会阻塞。</p><p>再看一个例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">func producer(ch chan string) &#123;</span><br><span class="line">fmt.Println(&quot;producer start&quot;)</span><br><span class="line">ch &lt;- &quot;a&quot;</span><br><span class="line">ch &lt;- &quot;b&quot;</span><br><span class="line">ch &lt;- &quot;c&quot;</span><br><span class="line">ch &lt;- &quot;d&quot;</span><br><span class="line">fmt.Println(&quot;producer end&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func customer(ch chan string) &#123;</span><br><span class="line">for &#123;</span><br><span class="line">msg := &lt;- ch</span><br><span class="line">fmt.Println(msg)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Println(&quot;main start&quot;)</span><br><span class="line">ch := make(chan string, 3)</span><br><span class="line">go producer(ch)</span><br><span class="line">go customer(ch)</span><br><span class="line"></span><br><span class="line">time.Sleep(1 * time.Second)</span><br><span class="line">fmt.Println(&quot;main end&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">main start</span><br><span class="line">producer start</span><br><span class="line">producer end</span><br><span class="line">a</span><br><span class="line">b</span><br><span class="line">c</span><br><span class="line">d</span><br><span class="line">main end</span><br></pre></td></tr></table></figure><p>就到这吧。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;chan 可以理解为队列，遵循先进先出的规则。&lt;/p&gt;
&lt;p&gt;在说 chan 之前，咱们先说一下 go 关键字。&lt;/p&gt;
&lt;p&gt;在 go 关</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>老项目迁移 go module 大型灾难记录</title>
    <link href="https://timmy6.github.io/2018/10/26/gomod/"/>
    <id>https://timmy6.github.io/2018/10/26/gomod/</id>
    <published>2018-10-26T08:17:50.000Z</published>
    <updated>2022-05-11T09:46:21.557Z</updated>
    
    <content type="html"><![CDATA[<p>最近在改造一个比较早期的一个项目，其中就涉及到用将原来 <code>Vendor</code> 管理依赖换成 <code>Go Modules</code> 来管理。 然而过程真是一波三折，在这里总结一下此次 <code>Go Modules</code> 改造中遇到的问题，以及解决方法。</p><span id="more"></span><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><ul><li><p>go version：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go version</span><br><span class="line">go version go1.16.5 darwin/amd64</span><br></pre></td></tr></table></figure></li><li><p>简化的 demo 如下,  很 “简单” 我们只要把 <code>hello world</code> 输出即可。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;github.com/coreos/etcd/pkg/transport&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/google/certificate-transparency-go/tls&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/qiniu/api.v7/auth/qbox&quot;</span></span><br><span class="line"><span class="string">&quot;go.etcd.io/etcd/clientv3&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;qiniupkg.com/x/log.v7&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">_ = transport.TLSInfo&#123;&#125;</span><br><span class="line"></span><br><span class="line">_ = clientv3.WatchResponse&#123;&#125;</span><br><span class="line"></span><br><span class="line">_, _ = clientv3.New(clientv3.Config&#123;&#125;)</span><br><span class="line"></span><br><span class="line">_ = qbox.NewMac(<span class="string">&quot;&quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line"></span><br><span class="line">_ = tls.DigitallySigned&#123;&#125;</span><br><span class="line"></span><br><span class="line">_ = grpc.ClientConn&#123;&#125;</span><br><span class="line"></span><br><span class="line">log.Info(<span class="string">&quot;hello world&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h3><p>直接初始化，并 tidy 一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">$ go mod init demo-go/gomod</span><br><span class="line">go: creating new go.mod: module demo-go/gomod</span><br><span class="line">go: to add module requirements and sums:</span><br><span class="line">        go mod tidy</span><br><span class="line">   </span><br><span class="line">$ go mod tidy</span><br><span class="line">go: finding module <span class="keyword">for</span> ...</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        qiniupkg.com/x/log.v7: module qiniupkg.com/x@latest found (v1.11.5), but does not contain package qiniupkg.com/x/log.v7</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        github.com/qiniu/api.v7/auth/qbox imports</span><br><span class="line">        github.com/qiniu/x/bytes.v7/seekable: module github.com/qiniu/x@latest found (v1.11.5), but does not contain package github.com/qiniu/x/bytes.v7/seekable</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 imports</span><br><span class="line">        github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context: package github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context provided by github.com/coreos/etcd at latest version v2.3.8+incompatible but not at required version v3.3.10+incompatible</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 imports</span><br><span class="line">        github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc: package github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc provided by github.com/coreos/etcd at latest version v2.3.8+incompatible but not at required version v3.3.10+incompatible</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 imports</span><br><span class="line">        github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/credentials: package github.com/coreos/etcd/Godeps/_workspace/src/google.golang.org/grpc/credentials provided by github.com/coreos/etcd at latest version v2.3.8+incompatible but not at required version v3.3.10+incompatible</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 imports</span><br><span class="line">        github.com/coreos/etcd/storage/storagepb: package github.com/coreos/etcd/storage/storagepb provided by github.com/coreos/etcd at latest version v2.3.8+incompatible but not at required version v3.3.10+incompatible</span><br></pre></td></tr></table></figure><p>好家伙，报错了。我们先看到前两行</p><ol><li><code>qiniupkg.com/x@latest</code>  中没有 <code>qiniupkg.com/x/log.v7</code>；</li><li><code>github.com/qiniu/x@latest</code> 中没有 <code>github.com/qiniu/x/bytes.v7/seekable</code>；</li></ol><p>这看起来应该是一个问题， <code>qiniupkg.com/x</code> 和<code>github.com/qiniu/x</code>  应该是同一个包，不同镜像。于是我到 Github 看一下 <code>@lastet</code> 版本的代码，确实没有<code>bytes.v7</code> 包了。人肉查找，最后在 <code>v1.7.8</code> 版本，我们找到了 <code>bytes.v7</code> 包。  </p><p>于是，我们可以指定一下版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -replace qiniupkg.com/x=qiniupkg.com/x@v1.7.8</span><br><span class="line">go mod edit -replace github.com/qiniu/x=github.com/qiniu/x@v1.7.8</span><br></pre></td></tr></table></figure><p>继续往下看，接下来的几个问题是一类的，都是<code>etcd</code>导致的。 </p><p>意思是 <code>go.etcd.io/etcd/clientv3</code> 导入了 <code>github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context</code>, 同时 <code>github.com/coreos/etcd@v2.3.8</code>  中 提供了 <code>github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context</code> 。 但是，我们这里需要 <code>github.com/coreos/etcd@v3.3.10</code>, 而该版本并不提供  <code>github.com/coreos/etcd/Godeps/_workspace/src/golang.org/x/net/context</code> 。</p><p>我们直接更新 etcd 到的 <code>v3.3.10</code> 试试。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -replace go.etcd.io/etcd=go.etcd.io/etcd@v3.3.20+incompatible</span><br></pre></td></tr></table></figure><p>我们再 <code> go mod tidy</code> 下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ go mod tidy</span><br><span class="line">go: demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 tested by</span><br><span class="line">        go.etcd.io/etcd/clientv3.<span class="built_in">test</span> imports</span><br><span class="line">        github.com/coreos/etcd/auth imports</span><br><span class="line">        github.com/coreos/etcd/mvcc/backend imports</span><br><span class="line">        github.com/coreos/bbolt: github.com/coreos/bbolt@v1.3.6: parsing go.mod:</span><br><span class="line">        module declares its path as: go.etcd.io/bbolt</span><br><span class="line">                but was required as: github.com/coreos/bbolt</span><br></pre></td></tr></table></figure><p>这个错误和鸟窝这篇 <a href="https://colobu.com/2020/04/09/accidents-of-etcd-and-go-module/">Etcd使用go module的灾难</a>一致，<code>go.etcd.io/bbolt</code> 和 <code>github.com/coreos/bbolt</code> 包名不一致，我们替换一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -replace github.com/coreos/bbolt@v1.3.6=go.etcd.io/bbolt@v1.3.6</span><br></pre></td></tr></table></figure><p>继续，<code>go mod tidy</code> 一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ go mod tidy</span><br><span class="line">...</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 imports</span><br><span class="line">        github.com/coreos/etcd/clientv3/balancer: module github.com/coreos/etcd@latest found (v2.3.8+incompatible), but does not contain package github.com/coreos/etcd/clientv3/balancer</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 imports</span><br><span class="line">        github.com/coreos/etcd/clientv3/balancer/picker: module github.com/coreos/etcd@latest found (v2.3.8+incompatible), but does not contain package github.com/coreos/etcd/clientv3/balancer/picker</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 imports</span><br><span class="line">        github.com/coreos/etcd/clientv3/balancer/resolver/endpoint: module github.com/coreos/etcd@latest found (v2.3.8+incompatible), but does not contain package github.com/coreos/etcd/clientv3/balancer/resolver/endpoint</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 imports</span><br><span class="line">        github.com/coreos/etcd/clientv3/credentials: module github.com/coreos/etcd@latest found (v2.3.8+incompatible), but does not contain package github.com/coreos/etcd/clientv3/credentials</span><br><span class="line">demo-go/gomod imports</span><br><span class="line">        go.etcd.io/etcd/clientv3 tested by</span><br><span class="line">        go.etcd.io/etcd/clientv3.<span class="built_in">test</span> imports</span><br><span class="line">        github.com/coreos/etcd/integration imports</span><br><span class="line">        github.com/coreos/etcd/proxy/grpcproxy imports</span><br><span class="line">        google.golang.org/grpc/naming: module google.golang.org/grpc@latest found (v1.39.0), but does not contain package google.golang.org/grpc/naming</span><br></pre></td></tr></table></figure><p>好家伙，又是<code>etcd</code>。 仔细一看，我们导入了<code>github.com/coreos/etcd</code> 和 <code>go.etcd.io/etcd</code> 两个版本<code>etcd</code>, 我们前面只替换了一个。现在我们把另外一个也替换了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -replace github.com/coreos/etcd=github.com/coreos/etcd@v3.3.20+incompatible</span><br></pre></td></tr></table></figure><p>再<code>go mod tidy</code>下，这个错误没有了，但还有个<code>grpc</code>的错误，继续找原因。原来是<code> google.golang.org/grpc</code> <code>v1.39.0</code> 版本没有<code> google.golang.org/grpc/naming</code> 包。 上 Github 仓库， 找了一下历史版本，<code>v1.29.1</code>上是有这个包的，我们继续替换。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -replace google.golang.org/grpc=google.golang.org/grpc@v1.29.1</span><br></pre></td></tr></table></figure><p>这下，终于，<code>go mod tidy</code>通过了，可以开心的输出<code>hello world</code> 了。</p><p>然而，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line"><span class="comment"># github.com/coreos/etcd/clientv3/balancer/resolver/endpoint</span></span><br><span class="line">../../../go/pkg/mod/github.com/coreos/etcd@v3.3.20+incompatible/clientv3/balancer/resolver/endpoint/endpoint.go:114:78: undefined: resolver.BuildOption</span><br><span class="line">../../../go/pkg/mod/github.com/coreos/etcd@v3.3.20+incompatible/clientv3/balancer/resolver/endpoint/endpoint.go:182:31: undefined: resolver.ResolveNowOption</span><br><span class="line"><span class="comment"># github.com/coreos/etcd/clientv3/balancer/picker</span></span><br><span class="line">../../../go/pkg/mod/github.com/coreos/etcd@v3.3.20+incompatible/clientv3/balancer/picker/err.go:37:44: undefined: balancer.PickOptions</span><br><span class="line">../../../go/pkg/mod/github.com/coreos/etcd@v3.3.20+incompatible/clientv3/balancer/picker/roundrobin_balanced.go:55:54: undefined: balancer.PickOptions</span><br></pre></td></tr></table></figure><p>意不意外，惊不惊喜！!</p><p>原来<code>etcd</code>包依赖了<code>grpc</code>的<code>resolver</code>包，但我导入的<code>v1.29.1</code>版本的<code>grpc</code>是没有这个包的。到 <code>grpc</code><a href="https://github.com/grpc/grpc-go/blob/v1.26.0/resolver/resolver.go">仓库</a> 挨个版本看了一下，确实只有<code>v1.26.0</code>版本才声明了<code>type BuildOption</code> 。于是，我们再次使用替换大法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">go mod edit -replace google.golang.org/grpc=google.golang.org/grpc@v1.26.0</span><br></pre></td></tr></table></figure><p>再次<code>tidy</code>, 运行！ 终于，看到了久违的<code>hello world!</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ go run main.go</span><br><span class="line">2021/07/20 12:27:09.642431 [INFO] /Users/razeen/wspace/github/demo-go/gomod/main.go:26: hello world</span><br></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="项目规范"><a href="#项目规范" class="headerlink" title="项目规范"></a>项目规范</h4><p>现在我们回过头看下这个 demo 项目，其实很有问题。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;github.com/coreos/etcd/pkg/transport&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/google/certificate-transparency-go/tls&quot;</span></span><br><span class="line"><span class="string">&quot;github.com/qiniu/api.v7/auth/qbox&quot;</span></span><br><span class="line"><span class="string">&quot;go.etcd.io/etcd/clientv3&quot;</span></span><br><span class="line"><span class="string">&quot;google.golang.org/grpc&quot;</span></span><br><span class="line"><span class="string">&quot;qiniupkg.com/x/log.v7&quot;</span></span><br></pre></td></tr></table></figure><p><code>etcd</code> 和 <code>qiniupkg</code>的包完全可以统一，只导入一种！而且，后来我们发现<code>log.v7</code>这包也是意外导入的….</p><p>这也是在改造我们一些老的项目时遇到的问题，以前用<code>vendor</code> <code>go get</code> 没有注意到这些问题，这是需要提前规范的。</p><h4 id="看懂-go-mod"><a href="#看懂-go-mod" class="headerlink" title="看懂 go.mod"></a>看懂 <code>go.mod</code></h4><p>我们来简单看一下，经历各种坎坷后，得出的<code>go.mod</code> 文件。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">module demo-<span class="keyword">go</span>/gomod</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="number">1.16</span></span><br><span class="line"></span><br><span class="line">replace qiniupkg.com/x =&gt; qiniupkg.com/x v1<span class="number">.7</span><span class="number">.8</span></span><br><span class="line"></span><br><span class="line">replace github.com/qiniu/x =&gt; github.com/qiniu/x v1<span class="number">.7</span><span class="number">.8</span></span><br><span class="line"></span><br><span class="line">replace <span class="keyword">go</span>.etcd.io/etcd =&gt; <span class="keyword">go</span>.etcd.io/etcd v3<span class="number">.3</span><span class="number">.20</span>+incompatible</span><br><span class="line"></span><br><span class="line">replace github.com/coreos/bbolt v1<span class="number">.3</span><span class="number">.6</span> =&gt; <span class="keyword">go</span>.etcd.io/bbolt v1<span class="number">.3</span><span class="number">.6</span></span><br><span class="line"></span><br><span class="line">replace github.com/coreos/etcd =&gt; github.com/coreos/etcd v3<span class="number">.3</span><span class="number">.20</span>+incompatible</span><br><span class="line"></span><br><span class="line">replace google.golang.org/grpc =&gt; google.golang.org/grpc v1<span class="number">.26</span><span class="number">.0</span></span><br><span class="line"></span><br><span class="line">require (</span><br><span class="line">github.com/coreos/bbolt v1<span class="number">.3</span><span class="number">.6</span> <span class="comment">// indirect</span></span><br><span class="line">github.com/coreos/etcd v3<span class="number">.3</span><span class="number">.10</span>+incompatible</span><br><span class="line">github.com/dgrijalva/jwt-<span class="keyword">go</span> v3<span class="number">.2</span><span class="number">.0</span>+incompatible <span class="comment">// indirect</span></span><br><span class="line">github.com/google/certificate-transparency-<span class="keyword">go</span> v1<span class="number">.1</span><span class="number">.1</span></span><br><span class="line">github.com/grpc-ecosystem/<span class="keyword">go</span>-grpc-prometheus v1<span class="number">.2</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">github.com/qiniu/api.v7 v7<span class="number">.2</span><span class="number">.5</span>+incompatible</span><br><span class="line">github.com/qiniu/x v0<span class="number">.0</span><span class="number">.0</span><span class="number">-00010101000000</span><span class="number">-000000000000</span> <span class="comment">// indirect</span></span><br><span class="line">github.com/soheilhy/cmux v0<span class="number">.1</span><span class="number">.5</span> <span class="comment">// indirect</span></span><br><span class="line">github.com/xiang90/probing v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20190116061207</span><span class="number">-43</span>a291ad63a2 <span class="comment">// indirect</span></span><br><span class="line"><span class="keyword">go</span>.etcd.io/etcd v0<span class="number">.0</span><span class="number">.0</span><span class="number">-20200513171258</span>-e048e166ab9c</span><br><span class="line">google.golang.org/grpc v1<span class="number">.29</span><span class="number">.1</span></span><br><span class="line">qiniupkg.com/x v0<span class="number">.0</span><span class="number">.0</span><span class="number">-00010101000000</span><span class="number">-000000000000</span></span><br><span class="line">sigs.k8s.io/yaml v1<span class="number">.2</span><span class="number">.0</span> <span class="comment">// indirect</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>我们先看一个常见的这几个<a href="https://golang.org/ref/mod#go-mod-file-module">指令</a>，</p><ul><li><code>module</code> 定义主模块的路径；</li><li><code>go</code> 编写该<code>mod</code>文件时的go版本；</li><li><code>require</code> 声明给定模块依赖项的最低要求版本;</li><li><code>replace</code> 手动指定的依赖模块 (可以替换全部的版本、指定的版本、本地的版本等等 )；</li></ul><p>还有就是 <code>v3.3.20+incompatible</code> 后面的 <code>+incompatible</code> , 这是指兼容的版本，指依赖库的版本是<code>v2</code> 或以上，但<code>go.mod</code>和 依赖库路径 没有按照官方指定的方式命名，会加上这个。</p><p><code>v0.0.0-00010101000000-000000000000</code> 这是一个伪版本，在和 不兼容 module 或 标记的版本不可用的时候，回打上这个伪版本。</p><p><code>// indirect</code> 这指明这些不是我们直接引用的依赖。</p><p>除此之外，以下指令也可了解一下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前模块以及所有的依赖模块</span></span><br><span class="line">go list -m all</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看某个模块的以及打标签的版本</span></span><br><span class="line">go list -m -versions go.etcd.io/etcd</span><br><span class="line"></span><br><span class="line"><span class="comment"># 升级特定的包</span></span><br><span class="line">go get xx@version 升级特定的包</span><br><span class="line"></span><br><span class="line"><span class="comment"># 了解为什么需要模块</span></span><br><span class="line">go mod why -m all  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 为什么需要指定（google.golang.org/grpc）的模块</span></span><br><span class="line">go mod why -m google.golang.org/grpc</span><br></pre></td></tr></table></figure><p>更多可以细读<a href="https://golang.org/ref/mod#incompatible-versions">官方文档</a>，感谢阅读。</p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul><li><a href="https://blog.golang.org/using-go-modules">Using Go Modules</a></li><li><a href="https://research.swtch.com/vgo-mvs">Minimal Version Selection</a></li><li><a href="https://colobu.com/2018/08/27/learn-go-module/">跳出Go module的泥潭</a></li><li><a href="https://colobu.com/2020/04/09/accidents-of-etcd-and-go-module/">Etcd使用go module的灾难</a></li><li><a href="https://duyanghao.github.io/golang-module/">浅谈Go Modules原理</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近在改造一个比较早期的一个项目，其中就涉及到用将原来 &lt;code&gt;Vendor&lt;/code&gt; 管理依赖换成 &lt;code&gt;Go Modules&lt;/code&gt; 来管理。 然而过程真是一波三折，在这里总结一下此次 &lt;code&gt;Go Modules&lt;/code&gt; 改造中遇到的问题，以及解决方法。&lt;/p&gt;</summary>
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Golang中的RESTful API最佳实践</title>
    <link href="https://timmy6.github.io/2018/10/22/restful/"/>
    <id>https://timmy6.github.io/2018/10/22/restful/</id>
    <published>2018-10-22T08:17:50.000Z</published>
    <updated>2022-05-11T09:46:15.199Z</updated>
    
    <content type="html"><![CDATA[<p>RESRful  API已经流行很多年了，我也一直在使用它。最佳实践也看过不少，但当一个项目完成，再次回顾&#x2F;梳理项目时，会发现很多API和规范还是多少有些出入。在这篇文章中，我们结合Go Web再次梳理一下RESTful API的相关最佳实践。</p><span id="more"></span><h3 id="关于RESTful-API"><a href="#关于RESTful-API" class="headerlink" title="关于RESTful API"></a>关于RESTful API</h3><p>关于什么是RESTful API，不再累述。推荐几个相关链接。</p><ul><li><a href="https://www.ruanyifeng.com/blog/2011/09/restful.html">理解RESTful架构</a></li><li><a href="https://restfulapi.net/">REST API Tutorial</a></li></ul><h3 id="1-使用JSON"><a href="#1-使用JSON" class="headerlink" title="1.使用JSON"></a>1.使用JSON</h3><p>不管是接收还是返回数据都推荐使用JSON。</p><p>通常返回数据的格式有JSON和XML，但XML过于冗长，可读性差，而且各种语言的解析上也不如JSON，使用JSON的好处，显而易见。</p><p>而接收数据，我们这里也推荐使用JSON，对于后端开发而言，入参直接与模型绑定，省去冗长的参数解析能简化不少代码，而且JSON能更简单的传递一些更复杂的结构等。</p><p>正如示例代码中的这一段，我们以<code>gin</code>框架为例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleLogin doc</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleLogin</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">param := &amp;LoginParams&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> err := c.BindJSON(param); err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, &amp;Resp&#123;Error: <span class="string">&quot;parameters error&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 做一些校验</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"></span><br><span class="line">session := sessions.Default(c)</span><br><span class="line">session.Set(sessionsKey, param.UserID)</span><br><span class="line">session.Save()</span><br><span class="line">c.JSON(http.StatusOK, &amp;Resp&#123;Data: <span class="string">&quot;login succeed&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>c.BindJSON</code>,轻松的将入参于模型<code>LoginParams</code>绑定；通过<code>c.JSON</code>轻松的将数据JSON序列化返回。</p><p>但所有接口都必须用JSON么？那也未必。比如文件上传，这时我们使用<code>FormData</code>比把文件base64之类的放到JSON里面更高效。</p><h3 id="2-路径中不包含动词"><a href="#2-路径中不包含动词" class="headerlink" title="2.路径中不包含动词"></a>2.路径中不包含动词</h3><p>我们的HTTP请求方法中已经有<code>GET</code>,<code>POST</code>等这些动作了，完全没有必要再路径中加上动词。</p><p>我们常用HTTP请求方法包括<code>GET</code>,<code>POST</code>,<code>PUT</code>和<code>DELETE</code>, 这也对应了我们经常需要做的数据库操作。<code>GET</code>查找&#x2F;获取资源，<code>POST</code>新增资源，<code>PUT</code>修改资源，<code>DELETE</code>删除资源。</p><p>如下，这些路径中没有任何动词，简洁明了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取文章列表</span></span><br><span class="line">v1.GET(<span class="string">&quot;/articles&quot;</span>, HandleGetArticles)</span><br><span class="line"><span class="comment">// 发布文章</span></span><br><span class="line">v1.POST(<span class="string">&quot;/articles&quot;</span>, HandlePostArticles)</span><br><span class="line"><span class="comment">// 修改文章</span></span><br><span class="line">v1.PUT(<span class="string">&quot;/articles&quot;</span>, HandleUpdateArticles)</span><br><span class="line"><span class="comment">// 删除文章</span></span><br><span class="line">v1.DELETE(<span class="string">&quot;/articles/:id&quot;</span>, HandleDeleteArticles)</span><br></pre></td></tr></table></figure><h3 id="3-路径中对应资源用复数"><a href="#3-路径中对应资源用复数" class="headerlink" title="3.路径中对应资源用复数"></a>3.路径中对应资源用复数</h3><p>就像我们上面这段代码，<code>articles</code>对于的是我们的文章资源，背后就是一张数据库表<code>articles</code>, 所以操作这个资源的应该都用复数形式。</p><h3 id="4-次要资源可分层展示"><a href="#4-次要资源可分层展示" class="headerlink" title="4.次要资源可分层展示"></a>4.次要资源可分层展示</h3><p>一个博客系统中，最主要的应该是文章了，而评论应该是其子资源，我们可以评论嵌套在它的父资源后面，如：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取评论列表</span></span><br><span class="line">v1.GET(<span class="string">&quot;/articles/:articles_id/comments&quot;</span>, HandleGetComments)</span><br><span class="line"><span class="comment">// 添加评论</span></span><br><span class="line">v1.POST(<span class="string">&quot;/articles/:articles_id/comments&quot;</span>, HandleAddComments)</span><br><span class="line"><span class="comment">// 修改评论</span></span><br><span class="line">v1.PUT(<span class="string">&quot;/articles/:articles_id/comments/:id&quot;</span>, HandleUpdateComments)</span><br><span class="line"><span class="comment">// 删除评论</span></span><br><span class="line">v1.DELETE(<span class="string">&quot;/articles/:articles_id/comments/:id&quot;</span>, HandleDeleteComments)</span><br></pre></td></tr></table></figure><p>那么，我们需要获取所有文章的评论怎么办？可以这么写：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v1.GET(<span class="string">&quot;/articles/-/comments&quot;</span>, HandleGetComments)</span><br></pre></td></tr></table></figure><p>但这也不是决对的，资源虽然有层级关系，但这种层级关系不宜太深，个人感觉两层最多了，如果超过，可以直接拿出来放在一级。</p><h3 id="5-分页、排序、过滤"><a href="#5-分页、排序、过滤" class="headerlink" title="5.分页、排序、过滤"></a>5.分页、排序、过滤</h3><p>获取列表时，会使用到分页、排序过滤。一般：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">?page=1&amp;page_size=10  <span class="comment"># 指定页面page与分页大小page_size</span></span><br><span class="line">?<span class="built_in">sort</span>=-create_at,+author <span class="comment"># 按照创建时间create_at降序，作者author升序排序</span></span><br><span class="line">?title=helloworld <span class="comment"># 按字段title搜索</span></span><br></pre></td></tr></table></figure><h3 id="6-统一数据格式"><a href="#6-统一数据格式" class="headerlink" title="6.统一数据格式"></a>6.统一数据格式</h3><p>不管是路径的格式，还是参数的格式，还是返回值的格式建议统一形式。</p><p>一般常用的格式有<code>蛇形</code>,<code>大驼峰</code>和<code>小驼峰</code>，个人比较喜欢<code>蛇形</code>。Anyway, 不管哪种，只要统一即可。</p><p>除了参数的命名统一外，返回的数据格式，最好统一，方便前端对接。</p><p>如下，我们定义<code>Resp</code>为通用返回数据结构，<code>Data</code>中存放返回的数据，如果出错，将错误信息放在<code>Error</code>中。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Resp doc</span></span><br><span class="line"><span class="keyword">type</span> Resp <span class="keyword">struct</span> &#123;</span><br><span class="line">Data  <span class="keyword">interface</span>&#123;&#125; <span class="string">`json:&quot;data&quot;`</span></span><br><span class="line">Error <span class="type">string</span>      <span class="string">`json:&quot;error&quot;`</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 登陆成功返回</span></span><br><span class="line">  c.JSON(http.StatusOK, &amp;Resp&#123;Data: <span class="string">&quot;login succeed&quot;</span>&#125;)</span><br><span class="line"><span class="comment">// 查询列表</span></span><br><span class="line">c.JSON(http.StatusOK, &amp;Resp&#123;Data: <span class="keyword">map</span>[<span class="type">string</span>]<span class="keyword">interface</span>&#123;&#125;&#123;</span><br><span class="line"><span class="string">&quot;result&quot;</span>: tempStorage,</span><br><span class="line"><span class="string">&quot;total&quot;</span>:  <span class="built_in">len</span>(tempStorage),</span><br><span class="line">&#125;&#125;)</span><br><span class="line"><span class="comment">// 参数错误</span></span><br><span class="line">c.JSON(http.StatusBadRequest, &amp;Resp&#123;Error: <span class="string">&quot;parameters error&quot;</span>&#125;)</span><br></pre></td></tr></table></figure><h3 id="7-善用HTTP状态码"><a href="#7-善用HTTP状态码" class="headerlink" title="7.善用HTTP状态码"></a>7.善用HTTP状态码</h3><p>HTTP状态码有很多，我们没有必要也不可能全部用上，常用如下：</p><ul><li>200 StatusOK - 只有成功请求都返回200。</li><li>400 StatusBadRequest - 当出现参数不对，用户参数校验不通过时，给出该状态，并返回Error</li><li>401 StatusUnauthorized - 没有登陆&#x2F;经过认证</li><li>403 Forbidden - 服务端拒绝授权(如密码错误)，不允许访问</li><li>404 Not Found - 路径不存在</li><li>500 Internal Server Error - 所请求的服务器遇到意外的情况并阻止其执行请求</li><li>502 Bad Gateway - 网关或代理从上游接收到了无效的响应 </li><li>503 Service Unavailable - 服务器尚未处于可以接受请求的状态</li></ul><p>其中<code>502</code>,<code>503</code>，我们写程序时并不会明确去抛出。所以我们平常用6个状态码已经能很好的展示服务端状态了。</p><p>同时，我们将状态与返回值对应起来，<code>200</code>状态下，返回<code>Data</code>数据；其他状态返回<code>Error</code>。</p><h3 id="8-API版本化"><a href="#8-API版本化" class="headerlink" title="8.API版本化"></a>8.API版本化</h3><p>正如Demo中所示，我们将路由分组到了<code>/api/v1</code>路径下面，版本化API。如果后续的服务端升级，但可能仍有很大部分客户端请求未升级，依然请求老版本的API，那么我们只需要增加<code>/api/v2</code>，然后在该路径下为已升级的客户端提供服务。这样，我们就做到了API的版本控制，可以平滑的从一个版本切换到另外一个版本。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">v1 := r.Group(<span class="string">&quot;/api/v1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">v1.POST(<span class="string">&quot;/login&quot;</span>, HandleLogin)</span><br><span class="line">v1.GET(<span class="string">&quot;/articles&quot;</span>, HandleGetArticles)</span><br><span class="line">v1.GET(<span class="string">&quot;/articles/:id/comments&quot;</span>, HandleGetComments)</span><br><span class="line">   <span class="comment">// ....</span></span><br></pre></td></tr></table></figure><h3 id="9-统一-‘-x2F-‘-开头"><a href="#9-统一-‘-x2F-‘-开头" class="headerlink" title="9. 统一 ‘&#x2F;‘ 开头"></a>9. 统一 ‘&#x2F;‘ 开头</h3><p>所以路由中，路径都以’&#x2F;‘开头，虽然框架会为我们做这件事，但还是建议统一加上。</p><h3 id="10-增加-x2F-更新操作-返回资源"><a href="#10-增加-x2F-更新操作-返回资源" class="headerlink" title="10. 增加&#x2F;更新操作 返回资源"></a>10. 增加&#x2F;更新操作 返回资源</h3><p>对于<code>POST</code>,<code>PUT</code>操作，建议操作后，返回更新后的资源。</p><h3 id="11-使用HTTPS"><a href="#11-使用HTTPS" class="headerlink" title="11. 使用HTTPS"></a>11. 使用HTTPS</h3><p>对于暴露出去的接口&#x2F;OpenAPI，一定使用HTTPS。一般时候，我们可以直接在服务前面架设一个WebServer，在WebServer内部署证书即可。当然，如果是直接由后端暴露出的接口，有必要直接在后端开启HTTPS！</p><h3 id="12-规范的API文档"><a href="#12-规范的API文档" class="headerlink" title="12. 规范的API文档"></a>12. 规范的API文档</h3><p>对于我们这种前后端分离的架构，API文档是很重要。在Go中，我们很容易的能用swag结合代码注释自动生成API文档。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>API写的好不好，重要的还是看是否遵循WEB标准和保持一致性，最终目的也是让这些API更清晰，易懂，安全，希望这些建议对你有所帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;RESRful  API已经流行很多年了，我也一直在使用它。最佳实践也看过不少，但当一个项目完成，再次回顾&amp;#x2F;梳理项目时，会发现很多API和规范还是多少有些出入。在这篇文章中，我们结合Go Web再次梳理一下RESTful API的相关最佳实践。&lt;/p&gt;</summary>
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>gin文件上传与下载</title>
    <link href="https://timmy6.github.io/2018/10/12/gin-file/"/>
    <id>https://timmy6.github.io/2018/10/12/gin-file/</id>
    <published>2018-10-12T08:17:50.000Z</published>
    <updated>2022-05-11T09:46:09.526Z</updated>
    
    <content type="html"><![CDATA[<p>Gin是用Go编写的web框架。性能还不错，而且使用比较简单，还支持RESTful API。</p><p>日常的使用中我们可能要处理一些文件的上传与下载，我这里简单总结一下。</p><h3 id="单文件上传"><a href="#单文件上传" class="headerlink" title="单文件上传"></a>单文件上传</h3><p>我们使用<code>multipart/form-data</code>格式上传文件，利用<code>c.Request.FormFile</code>解析文件。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleUploadFile 上传单个文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleUploadFile</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">file, header, err := c.Request.FormFile(<span class="string">&quot;file&quot;</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;文件上传失败&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">content, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;文件读取失败&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(header.Filename)</span><br><span class="line">fmt.Println(<span class="type">string</span>(content))</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;上传成功&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们上传文件可以看到。</p><p><img src="https://st.razeen.me/bcj/201809/jietu20180906-002227.png" alt="jietu20180906-002227"></p><p>我们已经看到文件上传成功，已经文件名字与内容。</p><h3 id="多文件上传"><a href="#多文件上传" class="headerlink" title="多文件上传"></a>多文件上传</h3><p>多文件的上传利用<code>c.Request.MultipartForm</code>解析。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleUploadMutiFile 上传多个文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleUploadMutiFile</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line"><span class="comment">// 限制放入内存的文件大小</span></span><br><span class="line">err := c.Request.ParseMultipartForm(<span class="number">4</span> &lt;&lt; <span class="number">20</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;文件太大&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">formdata := c.Request.MultipartForm</span><br><span class="line">files := formdata.File[<span class="string">&quot;file&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> _, v := <span class="keyword">range</span> files &#123;</span><br><span class="line">file, err := v.Open()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;文件读取失败&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">content, err := ioutil.ReadAll(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">c.JSON(http.StatusBadRequest, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;文件读取失败&quot;</span>&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Println(v.Filename)</span><br><span class="line">fmt.Println(<span class="type">string</span>(content))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;<span class="string">&quot;msg&quot;</span>: <span class="string">&quot;上传成功&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多个文件，遍历文件内容即可读取。</p><p><del>利用<code>c.Request.ParseMultipartForm()</code>可设置上传文件的大小，这里限制了4MB。</del><br> <code>c.Request.ParseMultipartForm()</code>并不能限制上传文件的大小，只是限制了上传的文件读取到内存部分的大小，如果超过了就存入了系统的临时文件中。<br>如果需要限制文件大小，需要使用<code>github.com/gin-contrib/size</code>中间件，如demo中使用<code>r.Use(limits.RequestSizeLimiter(4 &lt;&lt; 20))</code>限制最大4Mb。</p><p>我们看到</p><p><img src="https://st.razeen.me/bcj/201809/jietu20180906-002143.png" alt="jietu20180906-002143"></p><p>两个文件已经上传成功。</p><h3 id="文件下载"><a href="#文件下载" class="headerlink" title="文件下载"></a>文件下载</h3><p>文件的下载主要是注意设置文件名，文件类型等。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// HandleDownloadFile 下载文件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">HandleDownloadFile</span><span class="params">(c *gin.Context)</span></span> &#123;</span><br><span class="line">content := c.Query(<span class="string">&quot;content&quot;</span>)</span><br><span class="line"></span><br><span class="line">content = <span class="string">&quot;hello world, 我是一个文件，&quot;</span> + content</span><br><span class="line"></span><br><span class="line">c.Writer.WriteHeader(http.StatusOK)</span><br><span class="line">c.Header(<span class="string">&quot;Content-Disposition&quot;</span>, <span class="string">&quot;attachment; filename=hello.txt&quot;</span>)</span><br><span class="line">c.Header(<span class="string">&quot;Content-Type&quot;</span>, <span class="string">&quot;application/text/plain&quot;</span>)</span><br><span class="line">c.Header(<span class="string">&quot;Accept-Length&quot;</span>, fmt.Sprintf(<span class="string">&quot;%d&quot;</span>, <span class="built_in">len</span>(content)))</span><br><span class="line">c.Writer.Write([]<span class="type">byte</span>(content))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过</p><ul><li><code>Content-Disposition</code>设置文件名字；</li><li><code>Content-Type</code>设置文件类型，可以到<a href="http://www.runoob.com/http/http-content-type.html">这里</a>查阅；</li><li><code>Accept-Length</code>这个设置文件长度；</li><li><code>c.Writer.Write</code>写出文件。</li></ul><p>成功下载可以看到：</p><p><img src="https://st.razeen.me/bcj/201809/jietu20180906-004014.png" alt="jietu20180906-004014"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Gin是用Go编写的web框架。性能还不错，而且使用比较简单，还支持RESTful API。&lt;/p&gt;
&lt;p&gt;日常的使用中我们可能要处理一些文件的上传与下载，我这里简单总结一下。&lt;/p&gt;
&lt;h3 id=&quot;单文件上传&quot;&gt;&lt;a href=&quot;#单文件上传&quot; class=&quot;heade</summary>
      
    
    
    
    <category term="Go开发" scheme="https://timmy6.github.io/categories/Go%E5%BC%80%E5%8F%91/"/>
    
    
    <category term="Go基础" scheme="https://timmy6.github.io/tags/Go%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
